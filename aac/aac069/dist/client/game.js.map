{"version":3,"file":"game.js","sources":["../../node_modules/@trpc/client/dist/objectSpread2-BvkFp-_Y.mjs","../../node_modules/@trpc/server/dist/observable-UMO3vUa_.mjs","../../node_modules/@trpc/server/dist/observable-CUiPknO-.mjs","../../node_modules/@trpc/client/dist/splitLink-B7Cuf2c_.mjs","../../node_modules/@trpc/server/dist/codes-DagpWZLc.mjs","../../node_modules/@trpc/server/dist/getErrorShape-vC8mUXJD.mjs","../../node_modules/@trpc/server/dist/resolveResponse-C7AcnFLN.mjs","../../node_modules/@trpc/client/dist/TRPCClientError-CjKyS10w.mjs","../../node_modules/@trpc/client/dist/unstable-internals-Bg7n9BBj.mjs","../../node_modules/@trpc/client/dist/httpUtils-Dv57hbOd.mjs","../../node_modules/@trpc/client/dist/httpLink-DCFpUmZF.mjs","../../node_modules/@trpc/client/dist/httpBatchLink-BOe5aCcR.mjs","../../node_modules/@trpc/client/dist/loggerLink-ineCN1PO.mjs","../../node_modules/@trpc/client/dist/wsLink-CatceK3c.mjs","../../node_modules/@trpc/client/dist/index.mjs","../../node_modules/superjson/dist/double-indexed-kv.js","../../node_modules/superjson/dist/registry.js","../../node_modules/superjson/dist/class-registry.js","../../node_modules/superjson/dist/util.js","../../node_modules/superjson/dist/custom-transformer-registry.js","../../node_modules/superjson/dist/is.js","../../node_modules/superjson/dist/pathstringifier.js","../../node_modules/superjson/dist/transformer.js","../../node_modules/superjson/dist/accessDeep.js","../../node_modules/superjson/dist/plainer.js","../../node_modules/is-what/dist/getType.js","../../node_modules/is-what/dist/isArray.js","../../node_modules/is-what/dist/isPlainObject.js","../../node_modules/copy-anything/dist/index.js","../../node_modules/superjson/dist/index.js","../../src/shared/transformer.ts","../../src/client/trpc.ts","../../src/client/game.tsx"],"sourcesContent":["//#region rolldown:runtime\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function() {\n\treturn mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n\tif (from && typeof from === \"object\" || typeof from === \"function\") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {\n\t\tkey = keys[i];\n\t\tif (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n\t\t\tget: ((k) => from[k]).bind(null, key),\n\t\t\tenumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n\t\t});\n\t}\n\treturn to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n\tvalue: mod,\n\tenumerable: true\n}) : target, mod));\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/typeof.js\nvar require_typeof = __commonJS({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/typeof.js\"(exports, module) {\n\tfunction _typeof$2(o) {\n\t\t\"@babel/helpers - typeof\";\n\t\treturn module.exports = _typeof$2 = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o$1) {\n\t\t\treturn typeof o$1;\n\t\t} : function(o$1) {\n\t\t\treturn o$1 && \"function\" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? \"symbol\" : typeof o$1;\n\t\t}, module.exports.__esModule = true, module.exports[\"default\"] = module.exports, _typeof$2(o);\n\t}\n\tmodule.exports = _typeof$2, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n} });\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPrimitive.js\nvar require_toPrimitive = __commonJS({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPrimitive.js\"(exports, module) {\n\tvar _typeof$1 = require_typeof()[\"default\"];\n\tfunction toPrimitive$1(t, r) {\n\t\tif (\"object\" != _typeof$1(t) || !t) return t;\n\t\tvar e = t[Symbol.toPrimitive];\n\t\tif (void 0 !== e) {\n\t\t\tvar i = e.call(t, r || \"default\");\n\t\t\tif (\"object\" != _typeof$1(i)) return i;\n\t\t\tthrow new TypeError(\"@@toPrimitive must return a primitive value.\");\n\t\t}\n\t\treturn (\"string\" === r ? String : Number)(t);\n\t}\n\tmodule.exports = toPrimitive$1, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n} });\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPropertyKey.js\nvar require_toPropertyKey = __commonJS({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPropertyKey.js\"(exports, module) {\n\tvar _typeof = require_typeof()[\"default\"];\n\tvar toPrimitive = require_toPrimitive();\n\tfunction toPropertyKey$1(t) {\n\t\tvar i = toPrimitive(t, \"string\");\n\t\treturn \"symbol\" == _typeof(i) ? i : i + \"\";\n\t}\n\tmodule.exports = toPropertyKey$1, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n} });\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/defineProperty.js\nvar require_defineProperty = __commonJS({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/defineProperty.js\"(exports, module) {\n\tvar toPropertyKey = require_toPropertyKey();\n\tfunction _defineProperty(e, r, t) {\n\t\treturn (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n\t\t\tvalue: t,\n\t\t\tenumerable: !0,\n\t\t\tconfigurable: !0,\n\t\t\twritable: !0\n\t\t}) : e[r] = t, e;\n\t}\n\tmodule.exports = _defineProperty, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n} });\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/objectSpread2.js\nvar require_objectSpread2 = __commonJS({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/objectSpread2.js\"(exports, module) {\n\tvar defineProperty = require_defineProperty();\n\tfunction ownKeys(e, r) {\n\t\tvar t = Object.keys(e);\n\t\tif (Object.getOwnPropertySymbols) {\n\t\t\tvar o = Object.getOwnPropertySymbols(e);\n\t\t\tr && (o = o.filter(function(r$1) {\n\t\t\t\treturn Object.getOwnPropertyDescriptor(e, r$1).enumerable;\n\t\t\t})), t.push.apply(t, o);\n\t\t}\n\t\treturn t;\n\t}\n\tfunction _objectSpread2(e) {\n\t\tfor (var r = 1; r < arguments.length; r++) {\n\t\t\tvar t = null != arguments[r] ? arguments[r] : {};\n\t\t\tr % 2 ? ownKeys(Object(t), !0).forEach(function(r$1) {\n\t\t\t\tdefineProperty(e, r$1, t[r$1]);\n\t\t\t}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r$1) {\n\t\t\t\tObject.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));\n\t\t\t});\n\t\t}\n\t\treturn e;\n\t}\n\tmodule.exports = _objectSpread2, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n} });\n\n//#endregion\nexport { __commonJS, __toESM, require_defineProperty, require_objectSpread2 };\n//# sourceMappingURL=objectSpread2-BvkFp-_Y.mjs.map","//#region src/observable/observable.ts\n/** @public */\nfunction isObservable(x) {\n\treturn typeof x === \"object\" && x !== null && \"subscribe\" in x;\n}\n/** @public */\nfunction observable(subscribe) {\n\tconst self = {\n\t\tsubscribe(observer) {\n\t\t\tlet teardownRef = null;\n\t\t\tlet isDone = false;\n\t\t\tlet unsubscribed = false;\n\t\t\tlet teardownImmediately = false;\n\t\t\tfunction unsubscribe() {\n\t\t\t\tif (teardownRef === null) {\n\t\t\t\t\tteardownImmediately = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (unsubscribed) return;\n\t\t\t\tunsubscribed = true;\n\t\t\t\tif (typeof teardownRef === \"function\") teardownRef();\n\t\t\t\telse if (teardownRef) teardownRef.unsubscribe();\n\t\t\t}\n\t\t\tteardownRef = subscribe({\n\t\t\t\tnext(value) {\n\t\t\t\t\tvar _observer$next;\n\t\t\t\t\tif (isDone) return;\n\t\t\t\t\t(_observer$next = observer.next) === null || _observer$next === void 0 || _observer$next.call(observer, value);\n\t\t\t\t},\n\t\t\t\terror(err) {\n\t\t\t\t\tvar _observer$error;\n\t\t\t\t\tif (isDone) return;\n\t\t\t\t\tisDone = true;\n\t\t\t\t\t(_observer$error = observer.error) === null || _observer$error === void 0 || _observer$error.call(observer, err);\n\t\t\t\t\tunsubscribe();\n\t\t\t\t},\n\t\t\t\tcomplete() {\n\t\t\t\t\tvar _observer$complete;\n\t\t\t\t\tif (isDone) return;\n\t\t\t\t\tisDone = true;\n\t\t\t\t\t(_observer$complete = observer.complete) === null || _observer$complete === void 0 || _observer$complete.call(observer);\n\t\t\t\t\tunsubscribe();\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (teardownImmediately) unsubscribe();\n\t\t\treturn { unsubscribe };\n\t\t},\n\t\tpipe(...operations) {\n\t\t\treturn operations.reduce(pipeReducer, self);\n\t\t}\n\t};\n\treturn self;\n}\nfunction pipeReducer(prev, fn) {\n\treturn fn(prev);\n}\n/** @internal */\nfunction observableToPromise(observable$1) {\n\tconst ac = new AbortController();\n\tconst promise = new Promise((resolve, reject) => {\n\t\tlet isDone = false;\n\t\tfunction onDone() {\n\t\t\tif (isDone) return;\n\t\t\tisDone = true;\n\t\t\tobs$.unsubscribe();\n\t\t}\n\t\tac.signal.addEventListener(\"abort\", () => {\n\t\t\treject(ac.signal.reason);\n\t\t});\n\t\tconst obs$ = observable$1.subscribe({\n\t\t\tnext(data) {\n\t\t\t\tisDone = true;\n\t\t\t\tresolve(data);\n\t\t\t\tonDone();\n\t\t\t},\n\t\t\terror(data) {\n\t\t\t\treject(data);\n\t\t\t},\n\t\t\tcomplete() {\n\t\t\t\tac.abort();\n\t\t\t\tonDone();\n\t\t\t}\n\t\t});\n\t});\n\treturn promise;\n}\n/**\n* @internal\n*/\nfunction observableToReadableStream(observable$1, signal) {\n\tlet unsub = null;\n\tconst onAbort = () => {\n\t\tunsub === null || unsub === void 0 || unsub.unsubscribe();\n\t\tunsub = null;\n\t\tsignal.removeEventListener(\"abort\", onAbort);\n\t};\n\treturn new ReadableStream({\n\t\tstart(controller) {\n\t\t\tunsub = observable$1.subscribe({\n\t\t\t\tnext(data) {\n\t\t\t\t\tcontroller.enqueue({\n\t\t\t\t\t\tok: true,\n\t\t\t\t\t\tvalue: data\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\terror(error) {\n\t\t\t\t\tcontroller.enqueue({\n\t\t\t\t\t\tok: false,\n\t\t\t\t\t\terror\n\t\t\t\t\t});\n\t\t\t\t\tcontroller.close();\n\t\t\t\t},\n\t\t\t\tcomplete() {\n\t\t\t\t\tcontroller.close();\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (signal.aborted) onAbort();\n\t\t\telse signal.addEventListener(\"abort\", onAbort, { once: true });\n\t\t},\n\t\tcancel() {\n\t\t\tonAbort();\n\t\t}\n\t});\n}\n/** @internal */\nfunction observableToAsyncIterable(observable$1, signal) {\n\tconst stream = observableToReadableStream(observable$1, signal);\n\tconst reader = stream.getReader();\n\tconst iterator = {\n\t\tasync next() {\n\t\t\tconst value = await reader.read();\n\t\t\tif (value.done) return {\n\t\t\t\tvalue: void 0,\n\t\t\t\tdone: true\n\t\t\t};\n\t\t\tconst { value: result } = value;\n\t\t\tif (!result.ok) throw result.error;\n\t\t\treturn {\n\t\t\t\tvalue: result.value,\n\t\t\t\tdone: false\n\t\t\t};\n\t\t},\n\t\tasync return() {\n\t\t\tawait reader.cancel();\n\t\t\treturn {\n\t\t\t\tvalue: void 0,\n\t\t\t\tdone: true\n\t\t\t};\n\t\t}\n\t};\n\treturn { [Symbol.asyncIterator]() {\n\t\treturn iterator;\n\t} };\n}\n\n//#endregion\nexport { isObservable, observable, observableToAsyncIterable, observableToPromise };\n//# sourceMappingURL=observable-UMO3vUa_.mjs.map","import { observable } from \"./observable-UMO3vUa_.mjs\";\n\n//#region src/observable/operators.ts\nfunction map(project) {\n\treturn (source) => {\n\t\treturn observable((destination) => {\n\t\t\tlet index = 0;\n\t\t\tconst subscription = source.subscribe({\n\t\t\t\tnext(value) {\n\t\t\t\t\tdestination.next(project(value, index++));\n\t\t\t\t},\n\t\t\t\terror(error) {\n\t\t\t\t\tdestination.error(error);\n\t\t\t\t},\n\t\t\t\tcomplete() {\n\t\t\t\t\tdestination.complete();\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn subscription;\n\t\t});\n\t};\n}\nfunction share(_opts) {\n\treturn (source) => {\n\t\tlet refCount = 0;\n\t\tlet subscription = null;\n\t\tconst observers = [];\n\t\tfunction startIfNeeded() {\n\t\t\tif (subscription) return;\n\t\t\tsubscription = source.subscribe({\n\t\t\t\tnext(value) {\n\t\t\t\t\tfor (const observer of observers) {\n\t\t\t\t\t\tvar _observer$next;\n\t\t\t\t\t\t(_observer$next = observer.next) === null || _observer$next === void 0 || _observer$next.call(observer, value);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\terror(error) {\n\t\t\t\t\tfor (const observer of observers) {\n\t\t\t\t\t\tvar _observer$error;\n\t\t\t\t\t\t(_observer$error = observer.error) === null || _observer$error === void 0 || _observer$error.call(observer, error);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tcomplete() {\n\t\t\t\t\tfor (const observer of observers) {\n\t\t\t\t\t\tvar _observer$complete;\n\t\t\t\t\t\t(_observer$complete = observer.complete) === null || _observer$complete === void 0 || _observer$complete.call(observer);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tfunction resetIfNeeded() {\n\t\t\tif (refCount === 0 && subscription) {\n\t\t\t\tconst _sub = subscription;\n\t\t\t\tsubscription = null;\n\t\t\t\t_sub.unsubscribe();\n\t\t\t}\n\t\t}\n\t\treturn observable((subscriber) => {\n\t\t\trefCount++;\n\t\t\tobservers.push(subscriber);\n\t\t\tstartIfNeeded();\n\t\t\treturn { unsubscribe() {\n\t\t\t\trefCount--;\n\t\t\t\tresetIfNeeded();\n\t\t\t\tconst index = observers.findIndex((v) => v === subscriber);\n\t\t\t\tif (index > -1) observers.splice(index, 1);\n\t\t\t} };\n\t\t});\n\t};\n}\nfunction tap(observer) {\n\treturn (source) => {\n\t\treturn observable((destination) => {\n\t\t\treturn source.subscribe({\n\t\t\t\tnext(value) {\n\t\t\t\t\tvar _observer$next2;\n\t\t\t\t\t(_observer$next2 = observer.next) === null || _observer$next2 === void 0 || _observer$next2.call(observer, value);\n\t\t\t\t\tdestination.next(value);\n\t\t\t\t},\n\t\t\t\terror(error) {\n\t\t\t\t\tvar _observer$error2;\n\t\t\t\t\t(_observer$error2 = observer.error) === null || _observer$error2 === void 0 || _observer$error2.call(observer, error);\n\t\t\t\t\tdestination.error(error);\n\t\t\t\t},\n\t\t\t\tcomplete() {\n\t\t\t\t\tvar _observer$complete2;\n\t\t\t\t\t(_observer$complete2 = observer.complete) === null || _observer$complete2 === void 0 || _observer$complete2.call(observer);\n\t\t\t\t\tdestination.complete();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t};\n}\nconst distinctUnsetMarker = Symbol();\nfunction distinctUntilChanged(compare = (a, b) => a === b) {\n\treturn (source) => {\n\t\treturn observable((destination) => {\n\t\t\tlet lastValue = distinctUnsetMarker;\n\t\t\treturn source.subscribe({\n\t\t\t\tnext(value) {\n\t\t\t\t\tif (lastValue !== distinctUnsetMarker && compare(lastValue, value)) return;\n\t\t\t\t\tlastValue = value;\n\t\t\t\t\tdestination.next(value);\n\t\t\t\t},\n\t\t\t\terror(error) {\n\t\t\t\t\tdestination.error(error);\n\t\t\t\t},\n\t\t\t\tcomplete() {\n\t\t\t\t\tdestination.complete();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t};\n}\nconst isDeepEqual = (a, b) => {\n\tif (a === b) return true;\n\tconst bothAreObjects = a && b && typeof a === \"object\" && typeof b === \"object\";\n\treturn !!bothAreObjects && Object.keys(a).length === Object.keys(b).length && Object.entries(a).every(([k, v]) => isDeepEqual(v, b[k]));\n};\nfunction distinctUntilDeepChanged() {\n\treturn distinctUntilChanged(isDeepEqual);\n}\n\n//#endregion\n//#region src/observable/behaviorSubject.ts\n/**\n* @internal\n* An observable that maintains and provides a \"current value\" to subscribers\n* @see https://www.learnrxjs.io/learn-rxjs/subjects/behaviorsubject\n*/\nfunction behaviorSubject(initialValue) {\n\tlet value = initialValue;\n\tconst observerList = [];\n\tconst addObserver = (observer) => {\n\t\tif (value !== void 0) observer.next(value);\n\t\tobserverList.push(observer);\n\t};\n\tconst removeObserver = (observer) => {\n\t\tobserverList.splice(observerList.indexOf(observer), 1);\n\t};\n\tconst obs = observable((observer) => {\n\t\taddObserver(observer);\n\t\treturn () => {\n\t\t\tremoveObserver(observer);\n\t\t};\n\t});\n\tobs.next = (nextValue) => {\n\t\tif (value === nextValue) return;\n\t\tvalue = nextValue;\n\t\tfor (const observer of observerList) observer.next(nextValue);\n\t};\n\tobs.get = () => value;\n\treturn obs;\n}\n\n//#endregion\nexport { behaviorSubject, distinctUntilChanged, distinctUntilDeepChanged, map, share, tap };\n//# sourceMappingURL=observable-CUiPknO-.mjs.map","import { observable } from \"@trpc/server/observable\";\n\n//#region src/links/internals/createChain.ts\n/** @internal */\nfunction createChain(opts) {\n\treturn observable((observer) => {\n\t\tfunction execute(index = 0, op = opts.op) {\n\t\t\tconst next = opts.links[index];\n\t\t\tif (!next) throw new Error(\"No more links to execute - did you forget to add an ending link?\");\n\t\t\tconst subscription = next({\n\t\t\t\top,\n\t\t\t\tnext(nextOp) {\n\t\t\t\t\tconst nextObserver = execute(index + 1, nextOp);\n\t\t\t\t\treturn nextObserver;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn subscription;\n\t\t}\n\t\tconst obs$ = execute();\n\t\treturn obs$.subscribe(observer);\n\t});\n}\n\n//#endregion\n//#region src/links/splitLink.ts\nfunction asArray(value) {\n\treturn Array.isArray(value) ? value : [value];\n}\nfunction splitLink(opts) {\n\treturn (runtime) => {\n\t\tconst yes = asArray(opts.true).map((link) => link(runtime));\n\t\tconst no = asArray(opts.false).map((link) => link(runtime));\n\t\treturn (props) => {\n\t\t\treturn observable((observer) => {\n\t\t\t\tconst links = opts.condition(props.op) ? yes : no;\n\t\t\t\treturn createChain({\n\t\t\t\t\top: props.op,\n\t\t\t\t\tlinks\n\t\t\t\t}).subscribe(observer);\n\t\t\t});\n\t\t};\n\t};\n}\n\n//#endregion\nexport { createChain, splitLink };\n//# sourceMappingURL=splitLink-B7Cuf2c_.mjs.map","//#region src/unstable-core-do-not-import/utils.ts\n/**\n* Ensures there are no duplicate keys when building a procedure.\n* @internal\n*/\nfunction mergeWithoutOverrides(obj1, ...objs) {\n\tconst newObj = Object.assign(emptyObject(), obj1);\n\tfor (const overrides of objs) for (const key in overrides) {\n\t\tif (key in newObj && newObj[key] !== overrides[key]) throw new Error(`Duplicate key ${key}`);\n\t\tnewObj[key] = overrides[key];\n\t}\n\treturn newObj;\n}\n/**\n* Check that value is object\n* @internal\n*/\nfunction isObject(value) {\n\treturn !!value && !Array.isArray(value) && typeof value === \"object\";\n}\nfunction isFunction(fn) {\n\treturn typeof fn === \"function\";\n}\n/**\n* Create an object without inheriting anything from `Object.prototype`\n* @internal\n*/\nfunction emptyObject() {\n\treturn Object.create(null);\n}\nconst asyncIteratorsSupported = typeof Symbol === \"function\" && !!Symbol.asyncIterator;\nfunction isAsyncIterable(value) {\n\treturn asyncIteratorsSupported && isObject(value) && Symbol.asyncIterator in value;\n}\n/**\n* Run an IIFE\n*/\nconst run = (fn) => fn();\nfunction noop() {}\nfunction identity(it) {\n\treturn it;\n}\n/**\n* Generic runtime assertion function. Throws, if the condition is not `true`.\n*\n* Can be used as a slightly less dangerous variant of type assertions. Code\n* mistakes would be revealed at runtime then (hopefully during testing).\n*/\nfunction assert(condition, msg = \"no additional info\") {\n\tif (!condition) throw new Error(`AssertionError: ${msg}`);\n}\nfunction sleep(ms = 0) {\n\treturn new Promise((res) => setTimeout(res, ms));\n}\n/**\n* Ponyfill for\n* [`AbortSignal.any`](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/any_static).\n*/\nfunction abortSignalsAnyPonyfill(signals) {\n\tif (typeof AbortSignal.any === \"function\") return AbortSignal.any(signals);\n\tconst ac = new AbortController();\n\tfor (const signal of signals) {\n\t\tif (signal.aborted) {\n\t\t\ttrigger();\n\t\t\tbreak;\n\t\t}\n\t\tsignal.addEventListener(\"abort\", trigger, { once: true });\n\t}\n\treturn ac.signal;\n\tfunction trigger() {\n\t\tac.abort();\n\t\tfor (const signal of signals) signal.removeEventListener(\"abort\", trigger);\n\t}\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/rpc/codes.ts\n/**\n* JSON-RPC 2.0 Error codes\n*\n* `-32000` to `-32099` are reserved for implementation-defined server-errors.\n* For tRPC we're copying the last digits of HTTP 4XX errors.\n*/\nconst TRPC_ERROR_CODES_BY_KEY = {\n\tPARSE_ERROR: -32700,\n\tBAD_REQUEST: -32600,\n\tINTERNAL_SERVER_ERROR: -32603,\n\tNOT_IMPLEMENTED: -32603,\n\tBAD_GATEWAY: -32603,\n\tSERVICE_UNAVAILABLE: -32603,\n\tGATEWAY_TIMEOUT: -32603,\n\tUNAUTHORIZED: -32001,\n\tPAYMENT_REQUIRED: -32002,\n\tFORBIDDEN: -32003,\n\tNOT_FOUND: -32004,\n\tMETHOD_NOT_SUPPORTED: -32005,\n\tTIMEOUT: -32008,\n\tCONFLICT: -32009,\n\tPRECONDITION_FAILED: -32012,\n\tPAYLOAD_TOO_LARGE: -32013,\n\tUNSUPPORTED_MEDIA_TYPE: -32015,\n\tUNPROCESSABLE_CONTENT: -32022,\n\tPRECONDITION_REQUIRED: -32028,\n\tTOO_MANY_REQUESTS: -32029,\n\tCLIENT_CLOSED_REQUEST: -32099\n};\nconst TRPC_ERROR_CODES_BY_NUMBER = {\n\t[-32700]: \"PARSE_ERROR\",\n\t[-32600]: \"BAD_REQUEST\",\n\t[-32603]: \"INTERNAL_SERVER_ERROR\",\n\t[-32001]: \"UNAUTHORIZED\",\n\t[-32002]: \"PAYMENT_REQUIRED\",\n\t[-32003]: \"FORBIDDEN\",\n\t[-32004]: \"NOT_FOUND\",\n\t[-32005]: \"METHOD_NOT_SUPPORTED\",\n\t[-32008]: \"TIMEOUT\",\n\t[-32009]: \"CONFLICT\",\n\t[-32012]: \"PRECONDITION_FAILED\",\n\t[-32013]: \"PAYLOAD_TOO_LARGE\",\n\t[-32015]: \"UNSUPPORTED_MEDIA_TYPE\",\n\t[-32022]: \"UNPROCESSABLE_CONTENT\",\n\t[-32028]: \"PRECONDITION_REQUIRED\",\n\t[-32029]: \"TOO_MANY_REQUESTS\",\n\t[-32099]: \"CLIENT_CLOSED_REQUEST\"\n};\n/**\n* tRPC error codes that are considered retryable\n* With out of the box SSE, the client will reconnect when these errors are encountered\n*/\nconst retryableRpcCodes = [\n\tTRPC_ERROR_CODES_BY_KEY.BAD_GATEWAY,\n\tTRPC_ERROR_CODES_BY_KEY.SERVICE_UNAVAILABLE,\n\tTRPC_ERROR_CODES_BY_KEY.GATEWAY_TIMEOUT,\n\tTRPC_ERROR_CODES_BY_KEY.INTERNAL_SERVER_ERROR\n];\n\n//#endregion\nexport { TRPC_ERROR_CODES_BY_KEY, TRPC_ERROR_CODES_BY_NUMBER, abortSignalsAnyPonyfill, assert, emptyObject, identity, isAsyncIterable, isFunction, isObject, mergeWithoutOverrides, noop, retryableRpcCodes, run, sleep };\n//# sourceMappingURL=codes-DagpWZLc.mjs.map","import { TRPC_ERROR_CODES_BY_KEY, TRPC_ERROR_CODES_BY_NUMBER, emptyObject, isObject } from \"./codes-DagpWZLc.mjs\";\n\n//#region rolldown:runtime\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function() {\n\treturn mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n\tif (from && typeof from === \"object\" || typeof from === \"function\") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {\n\t\tkey = keys[i];\n\t\tif (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n\t\t\tget: ((k) => from[k]).bind(null, key),\n\t\t\tenumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n\t\t});\n\t}\n\treturn to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n\tvalue: mod,\n\tenumerable: true\n}) : target, mod));\n\n//#endregion\n//#region src/unstable-core-do-not-import/createProxy.ts\nconst noop = () => {};\nconst freezeIfAvailable = (obj) => {\n\tif (Object.freeze) Object.freeze(obj);\n};\nfunction createInnerProxy(callback, path, memo) {\n\tvar _memo$cacheKey;\n\tconst cacheKey = path.join(\".\");\n\t(_memo$cacheKey = memo[cacheKey]) !== null && _memo$cacheKey !== void 0 || (memo[cacheKey] = new Proxy(noop, {\n\t\tget(_obj, key) {\n\t\t\tif (typeof key !== \"string\" || key === \"then\") return void 0;\n\t\t\treturn createInnerProxy(callback, [...path, key], memo);\n\t\t},\n\t\tapply(_1, _2, args) {\n\t\t\tconst lastOfPath = path[path.length - 1];\n\t\t\tlet opts = {\n\t\t\t\targs,\n\t\t\t\tpath\n\t\t\t};\n\t\t\tif (lastOfPath === \"call\") opts = {\n\t\t\t\targs: args.length >= 2 ? [args[1]] : [],\n\t\t\t\tpath: path.slice(0, -1)\n\t\t\t};\n\t\t\telse if (lastOfPath === \"apply\") opts = {\n\t\t\t\targs: args.length >= 2 ? args[1] : [],\n\t\t\t\tpath: path.slice(0, -1)\n\t\t\t};\n\t\t\tfreezeIfAvailable(opts.args);\n\t\t\tfreezeIfAvailable(opts.path);\n\t\t\treturn callback(opts);\n\t\t}\n\t}));\n\treturn memo[cacheKey];\n}\n/**\n* Creates a proxy that calls the callback with the path and arguments\n*\n* @internal\n*/\nconst createRecursiveProxy = (callback) => createInnerProxy(callback, [], emptyObject());\n/**\n* Used in place of `new Proxy` where each handler will map 1 level deep to another value.\n*\n* @internal\n*/\nconst createFlatProxy = (callback) => {\n\treturn new Proxy(noop, { get(_obj, name) {\n\t\tif (name === \"then\") return void 0;\n\t\treturn callback(name);\n\t} });\n};\n\n//#endregion\n//#region src/unstable-core-do-not-import/http/getHTTPStatusCode.ts\nconst JSONRPC2_TO_HTTP_CODE = {\n\tPARSE_ERROR: 400,\n\tBAD_REQUEST: 400,\n\tUNAUTHORIZED: 401,\n\tPAYMENT_REQUIRED: 402,\n\tFORBIDDEN: 403,\n\tNOT_FOUND: 404,\n\tMETHOD_NOT_SUPPORTED: 405,\n\tTIMEOUT: 408,\n\tCONFLICT: 409,\n\tPRECONDITION_FAILED: 412,\n\tPAYLOAD_TOO_LARGE: 413,\n\tUNSUPPORTED_MEDIA_TYPE: 415,\n\tUNPROCESSABLE_CONTENT: 422,\n\tPRECONDITION_REQUIRED: 428,\n\tTOO_MANY_REQUESTS: 429,\n\tCLIENT_CLOSED_REQUEST: 499,\n\tINTERNAL_SERVER_ERROR: 500,\n\tNOT_IMPLEMENTED: 501,\n\tBAD_GATEWAY: 502,\n\tSERVICE_UNAVAILABLE: 503,\n\tGATEWAY_TIMEOUT: 504\n};\nconst HTTP_CODE_TO_JSONRPC2 = {\n\t400: \"BAD_REQUEST\",\n\t401: \"UNAUTHORIZED\",\n\t402: \"PAYMENT_REQUIRED\",\n\t403: \"FORBIDDEN\",\n\t404: \"NOT_FOUND\",\n\t405: \"METHOD_NOT_SUPPORTED\",\n\t408: \"TIMEOUT\",\n\t409: \"CONFLICT\",\n\t412: \"PRECONDITION_FAILED\",\n\t413: \"PAYLOAD_TOO_LARGE\",\n\t415: \"UNSUPPORTED_MEDIA_TYPE\",\n\t422: \"UNPROCESSABLE_CONTENT\",\n\t428: \"PRECONDITION_REQUIRED\",\n\t429: \"TOO_MANY_REQUESTS\",\n\t499: \"CLIENT_CLOSED_REQUEST\",\n\t500: \"INTERNAL_SERVER_ERROR\",\n\t501: \"NOT_IMPLEMENTED\",\n\t502: \"BAD_GATEWAY\",\n\t503: \"SERVICE_UNAVAILABLE\",\n\t504: \"GATEWAY_TIMEOUT\"\n};\nfunction getStatusCodeFromKey(code) {\n\tvar _JSONRPC2_TO_HTTP_COD;\n\treturn (_JSONRPC2_TO_HTTP_COD = JSONRPC2_TO_HTTP_CODE[code]) !== null && _JSONRPC2_TO_HTTP_COD !== void 0 ? _JSONRPC2_TO_HTTP_COD : 500;\n}\nfunction getStatusKeyFromCode(code) {\n\tvar _HTTP_CODE_TO_JSONRPC;\n\treturn (_HTTP_CODE_TO_JSONRPC = HTTP_CODE_TO_JSONRPC2[code]) !== null && _HTTP_CODE_TO_JSONRPC !== void 0 ? _HTTP_CODE_TO_JSONRPC : \"INTERNAL_SERVER_ERROR\";\n}\nfunction getHTTPStatusCode(json) {\n\tconst arr = Array.isArray(json) ? json : [json];\n\tconst httpStatuses = new Set(arr.map((res) => {\n\t\tif (\"error\" in res && isObject(res.error.data)) {\n\t\t\tvar _res$error$data;\n\t\t\tif (typeof ((_res$error$data = res.error.data) === null || _res$error$data === void 0 ? void 0 : _res$error$data[\"httpStatus\"]) === \"number\") return res.error.data[\"httpStatus\"];\n\t\t\tconst code = TRPC_ERROR_CODES_BY_NUMBER[res.error.code];\n\t\t\treturn getStatusCodeFromKey(code);\n\t\t}\n\t\treturn 200;\n\t}));\n\tif (httpStatuses.size !== 1) return 207;\n\tconst httpStatus = httpStatuses.values().next().value;\n\treturn httpStatus;\n}\nfunction getHTTPStatusCodeFromError(error) {\n\treturn getStatusCodeFromKey(error.code);\n}\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/typeof.js\nvar require_typeof = __commonJS({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/typeof.js\"(exports, module) {\n\tfunction _typeof$2(o) {\n\t\t\"@babel/helpers - typeof\";\n\t\treturn module.exports = _typeof$2 = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o$1) {\n\t\t\treturn typeof o$1;\n\t\t} : function(o$1) {\n\t\t\treturn o$1 && \"function\" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? \"symbol\" : typeof o$1;\n\t\t}, module.exports.__esModule = true, module.exports[\"default\"] = module.exports, _typeof$2(o);\n\t}\n\tmodule.exports = _typeof$2, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n} });\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPrimitive.js\nvar require_toPrimitive = __commonJS({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPrimitive.js\"(exports, module) {\n\tvar _typeof$1 = require_typeof()[\"default\"];\n\tfunction toPrimitive$1(t, r) {\n\t\tif (\"object\" != _typeof$1(t) || !t) return t;\n\t\tvar e = t[Symbol.toPrimitive];\n\t\tif (void 0 !== e) {\n\t\t\tvar i = e.call(t, r || \"default\");\n\t\t\tif (\"object\" != _typeof$1(i)) return i;\n\t\t\tthrow new TypeError(\"@@toPrimitive must return a primitive value.\");\n\t\t}\n\t\treturn (\"string\" === r ? String : Number)(t);\n\t}\n\tmodule.exports = toPrimitive$1, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n} });\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPropertyKey.js\nvar require_toPropertyKey = __commonJS({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPropertyKey.js\"(exports, module) {\n\tvar _typeof = require_typeof()[\"default\"];\n\tvar toPrimitive = require_toPrimitive();\n\tfunction toPropertyKey$1(t) {\n\t\tvar i = toPrimitive(t, \"string\");\n\t\treturn \"symbol\" == _typeof(i) ? i : i + \"\";\n\t}\n\tmodule.exports = toPropertyKey$1, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n} });\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/defineProperty.js\nvar require_defineProperty = __commonJS({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/defineProperty.js\"(exports, module) {\n\tvar toPropertyKey = require_toPropertyKey();\n\tfunction _defineProperty(e, r, t) {\n\t\treturn (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n\t\t\tvalue: t,\n\t\t\tenumerable: !0,\n\t\t\tconfigurable: !0,\n\t\t\twritable: !0\n\t\t}) : e[r] = t, e;\n\t}\n\tmodule.exports = _defineProperty, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n} });\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/objectSpread2.js\nvar require_objectSpread2 = __commonJS({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/objectSpread2.js\"(exports, module) {\n\tvar defineProperty = require_defineProperty();\n\tfunction ownKeys(e, r) {\n\t\tvar t = Object.keys(e);\n\t\tif (Object.getOwnPropertySymbols) {\n\t\t\tvar o = Object.getOwnPropertySymbols(e);\n\t\t\tr && (o = o.filter(function(r$1) {\n\t\t\t\treturn Object.getOwnPropertyDescriptor(e, r$1).enumerable;\n\t\t\t})), t.push.apply(t, o);\n\t\t}\n\t\treturn t;\n\t}\n\tfunction _objectSpread2(e) {\n\t\tfor (var r = 1; r < arguments.length; r++) {\n\t\t\tvar t = null != arguments[r] ? arguments[r] : {};\n\t\t\tr % 2 ? ownKeys(Object(t), !0).forEach(function(r$1) {\n\t\t\t\tdefineProperty(e, r$1, t[r$1]);\n\t\t\t}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r$1) {\n\t\t\t\tObject.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));\n\t\t\t});\n\t\t}\n\t\treturn e;\n\t}\n\tmodule.exports = _objectSpread2, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n} });\n\n//#endregion\n//#region src/unstable-core-do-not-import/error/getErrorShape.ts\nvar import_objectSpread2 = __toESM(require_objectSpread2(), 1);\n/**\n* @internal\n*/\nfunction getErrorShape(opts) {\n\tconst { path, error, config } = opts;\n\tconst { code } = opts.error;\n\tconst shape = {\n\t\tmessage: error.message,\n\t\tcode: TRPC_ERROR_CODES_BY_KEY[code],\n\t\tdata: {\n\t\t\tcode,\n\t\t\thttpStatus: getHTTPStatusCodeFromError(error)\n\t\t}\n\t};\n\tif (config.isDev && typeof opts.error.stack === \"string\") shape.data.stack = opts.error.stack;\n\tif (typeof path === \"string\") shape.data.path = path;\n\treturn config.errorFormatter((0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, opts), {}, { shape }));\n}\n\n//#endregion\nexport { HTTP_CODE_TO_JSONRPC2, JSONRPC2_TO_HTTP_CODE, __commonJS, __toESM, createFlatProxy, createRecursiveProxy, getErrorShape, getHTTPStatusCode, getHTTPStatusCodeFromError, getStatusCodeFromKey, getStatusKeyFromCode, require_defineProperty, require_objectSpread2 };\n//# sourceMappingURL=getErrorShape-vC8mUXJD.mjs.map","import { __commonJS, __toESM, getErrorShape, getHTTPStatusCode, require_defineProperty, require_objectSpread2 } from \"./getErrorShape-vC8mUXJD.mjs\";\nimport { abortSignalsAnyPonyfill, emptyObject, identity, isAsyncIterable, isFunction, isObject, run } from \"./codes-DagpWZLc.mjs\";\nimport { TRPCError, getProcedureAtPath, getTRPCErrorFromUnknown, isTrackedEnvelope, transformTRPCResponse } from \"./tracked-D4V22yc5.mjs\";\nimport { isObservable, observableToAsyncIterable } from \"./observable-UMO3vUa_.mjs\";\n\n//#region src/unstable-core-do-not-import/http/parseConnectionParams.ts\nfunction parseConnectionParamsFromUnknown(parsed) {\n\ttry {\n\t\tif (parsed === null) return null;\n\t\tif (!isObject(parsed)) throw new Error(\"Expected object\");\n\t\tconst nonStringValues = Object.entries(parsed).filter(([_key, value]) => typeof value !== \"string\");\n\t\tif (nonStringValues.length > 0) throw new Error(`Expected connectionParams to be string values. Got ${nonStringValues.map(([key, value]) => `${key}: ${typeof value}`).join(\", \")}`);\n\t\treturn parsed;\n\t} catch (cause) {\n\t\tthrow new TRPCError({\n\t\t\tcode: \"PARSE_ERROR\",\n\t\t\tmessage: \"Invalid connection params shape\",\n\t\t\tcause\n\t\t});\n\t}\n}\nfunction parseConnectionParamsFromString(str) {\n\tlet parsed;\n\ttry {\n\t\tparsed = JSON.parse(str);\n\t} catch (cause) {\n\t\tthrow new TRPCError({\n\t\t\tcode: \"PARSE_ERROR\",\n\t\t\tmessage: \"Not JSON-parsable query params\",\n\t\t\tcause\n\t\t});\n\t}\n\treturn parseConnectionParamsFromUnknown(parsed);\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/http/contentType.ts\nvar import_objectSpread2$1 = __toESM(require_objectSpread2(), 1);\n/**\n* Memoize a function that takes no arguments\n* @internal\n*/\nfunction memo(fn) {\n\tlet promise = null;\n\tconst sym = Symbol.for(\"@trpc/server/http/memo\");\n\tlet value = sym;\n\treturn {\n\t\tread: async () => {\n\t\t\tvar _promise;\n\t\t\tif (value !== sym) return value;\n\t\t\t(_promise = promise) !== null && _promise !== void 0 || (promise = fn().catch((cause) => {\n\t\t\t\tif (cause instanceof TRPCError) throw cause;\n\t\t\t\tthrow new TRPCError({\n\t\t\t\t\tcode: \"BAD_REQUEST\",\n\t\t\t\t\tmessage: cause instanceof Error ? cause.message : \"Invalid input\",\n\t\t\t\t\tcause\n\t\t\t\t});\n\t\t\t}));\n\t\t\tvalue = await promise;\n\t\t\tpromise = null;\n\t\t\treturn value;\n\t\t},\n\t\tresult: () => {\n\t\t\treturn value !== sym ? value : void 0;\n\t\t}\n\t};\n}\nconst jsonContentTypeHandler = {\n\tisMatch(req) {\n\t\tvar _req$headers$get;\n\t\treturn !!((_req$headers$get = req.headers.get(\"content-type\")) === null || _req$headers$get === void 0 ? void 0 : _req$headers$get.startsWith(\"application/json\"));\n\t},\n\tasync parse(opts) {\n\t\tvar _types$values$next$va;\n\t\tconst { req } = opts;\n\t\tconst isBatchCall = opts.searchParams.get(\"batch\") === \"1\";\n\t\tconst paths = isBatchCall ? opts.path.split(\",\") : [opts.path];\n\t\tconst getInputs = memo(async () => {\n\t\t\tlet inputs = void 0;\n\t\t\tif (req.method === \"GET\") {\n\t\t\t\tconst queryInput = opts.searchParams.get(\"input\");\n\t\t\t\tif (queryInput) inputs = JSON.parse(queryInput);\n\t\t\t} else inputs = await req.json();\n\t\t\tif (inputs === void 0) return emptyObject();\n\t\t\tif (!isBatchCall) {\n\t\t\t\tconst result = emptyObject();\n\t\t\t\tresult[0] = opts.router._def._config.transformer.input.deserialize(inputs);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tif (!isObject(inputs)) throw new TRPCError({\n\t\t\t\tcode: \"BAD_REQUEST\",\n\t\t\t\tmessage: \"\\\"input\\\" needs to be an object when doing a batch call\"\n\t\t\t});\n\t\t\tconst acc = emptyObject();\n\t\t\tfor (const index of paths.keys()) {\n\t\t\t\tconst input = inputs[index];\n\t\t\t\tif (input !== void 0) acc[index] = opts.router._def._config.transformer.input.deserialize(input);\n\t\t\t}\n\t\t\treturn acc;\n\t\t});\n\t\tconst calls = await Promise.all(paths.map(async (path, index) => {\n\t\t\tconst procedure = await getProcedureAtPath(opts.router, path);\n\t\t\treturn {\n\t\t\t\tpath,\n\t\t\t\tprocedure,\n\t\t\t\tgetRawInput: async () => {\n\t\t\t\t\tconst inputs = await getInputs.read();\n\t\t\t\t\tlet input = inputs[index];\n\t\t\t\t\tif ((procedure === null || procedure === void 0 ? void 0 : procedure._def.type) === \"subscription\") {\n\t\t\t\t\t\tvar _ref, _opts$headers$get;\n\t\t\t\t\t\tconst lastEventId = (_ref = (_opts$headers$get = opts.headers.get(\"last-event-id\")) !== null && _opts$headers$get !== void 0 ? _opts$headers$get : opts.searchParams.get(\"lastEventId\")) !== null && _ref !== void 0 ? _ref : opts.searchParams.get(\"Last-Event-Id\");\n\t\t\t\t\t\tif (lastEventId) if (isObject(input)) input = (0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, input), {}, { lastEventId });\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar _input;\n\t\t\t\t\t\t\t(_input = input) !== null && _input !== void 0 || (input = { lastEventId });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn input;\n\t\t\t\t},\n\t\t\t\tresult: () => {\n\t\t\t\t\tvar _getInputs$result;\n\t\t\t\t\treturn (_getInputs$result = getInputs.result()) === null || _getInputs$result === void 0 ? void 0 : _getInputs$result[index];\n\t\t\t\t}\n\t\t\t};\n\t\t}));\n\t\tconst types = new Set(calls.map((call) => {\n\t\t\tvar _call$procedure;\n\t\t\treturn (_call$procedure = call.procedure) === null || _call$procedure === void 0 ? void 0 : _call$procedure._def.type;\n\t\t}).filter(Boolean));\n\t\t/* istanbul ignore if -- @preserve */\n\t\tif (types.size > 1) throw new TRPCError({\n\t\t\tcode: \"BAD_REQUEST\",\n\t\t\tmessage: `Cannot mix procedure types in call: ${Array.from(types).join(\", \")}`\n\t\t});\n\t\tconst type = (_types$values$next$va = types.values().next().value) !== null && _types$values$next$va !== void 0 ? _types$values$next$va : \"unknown\";\n\t\tconst connectionParamsStr = opts.searchParams.get(\"connectionParams\");\n\t\tconst info = {\n\t\t\tisBatchCall,\n\t\t\taccept: req.headers.get(\"trpc-accept\"),\n\t\t\tcalls,\n\t\t\ttype,\n\t\t\tconnectionParams: connectionParamsStr === null ? null : parseConnectionParamsFromString(connectionParamsStr),\n\t\t\tsignal: req.signal,\n\t\t\turl: opts.url\n\t\t};\n\t\treturn info;\n\t}\n};\nconst formDataContentTypeHandler = {\n\tisMatch(req) {\n\t\tvar _req$headers$get2;\n\t\treturn !!((_req$headers$get2 = req.headers.get(\"content-type\")) === null || _req$headers$get2 === void 0 ? void 0 : _req$headers$get2.startsWith(\"multipart/form-data\"));\n\t},\n\tasync parse(opts) {\n\t\tconst { req } = opts;\n\t\tif (req.method !== \"POST\") throw new TRPCError({\n\t\t\tcode: \"METHOD_NOT_SUPPORTED\",\n\t\t\tmessage: \"Only POST requests are supported for multipart/form-data requests\"\n\t\t});\n\t\tconst getInputs = memo(async () => {\n\t\t\tconst fd = await req.formData();\n\t\t\treturn fd;\n\t\t});\n\t\tconst procedure = await getProcedureAtPath(opts.router, opts.path);\n\t\treturn {\n\t\t\taccept: null,\n\t\t\tcalls: [{\n\t\t\t\tpath: opts.path,\n\t\t\t\tgetRawInput: getInputs.read,\n\t\t\t\tresult: getInputs.result,\n\t\t\t\tprocedure\n\t\t\t}],\n\t\t\tisBatchCall: false,\n\t\t\ttype: \"mutation\",\n\t\t\tconnectionParams: null,\n\t\t\tsignal: req.signal,\n\t\t\turl: opts.url\n\t\t};\n\t}\n};\nconst octetStreamContentTypeHandler = {\n\tisMatch(req) {\n\t\tvar _req$headers$get3;\n\t\treturn !!((_req$headers$get3 = req.headers.get(\"content-type\")) === null || _req$headers$get3 === void 0 ? void 0 : _req$headers$get3.startsWith(\"application/octet-stream\"));\n\t},\n\tasync parse(opts) {\n\t\tconst { req } = opts;\n\t\tif (req.method !== \"POST\") throw new TRPCError({\n\t\t\tcode: \"METHOD_NOT_SUPPORTED\",\n\t\t\tmessage: \"Only POST requests are supported for application/octet-stream requests\"\n\t\t});\n\t\tconst getInputs = memo(async () => {\n\t\t\treturn req.body;\n\t\t});\n\t\treturn {\n\t\t\tcalls: [{\n\t\t\t\tpath: opts.path,\n\t\t\t\tgetRawInput: getInputs.read,\n\t\t\t\tresult: getInputs.result,\n\t\t\t\tprocedure: await getProcedureAtPath(opts.router, opts.path)\n\t\t\t}],\n\t\t\tisBatchCall: false,\n\t\t\taccept: null,\n\t\t\ttype: \"mutation\",\n\t\t\tconnectionParams: null,\n\t\t\tsignal: req.signal,\n\t\t\turl: opts.url\n\t\t};\n\t}\n};\nconst handlers = [\n\tjsonContentTypeHandler,\n\tformDataContentTypeHandler,\n\toctetStreamContentTypeHandler\n];\nfunction getContentTypeHandler(req) {\n\tconst handler = handlers.find((handler$1) => handler$1.isMatch(req));\n\tif (handler) return handler;\n\tif (!handler && req.method === \"GET\") return jsonContentTypeHandler;\n\tthrow new TRPCError({\n\t\tcode: \"UNSUPPORTED_MEDIA_TYPE\",\n\t\tmessage: req.headers.has(\"content-type\") ? `Unsupported content-type \"${req.headers.get(\"content-type\")}` : \"Missing content-type header\"\n\t});\n}\nasync function getRequestInfo(opts) {\n\tconst handler = getContentTypeHandler(opts.req);\n\treturn await handler.parse(opts);\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/http/abortError.ts\nfunction isAbortError(error) {\n\treturn isObject(error) && error[\"name\"] === \"AbortError\";\n}\nfunction throwAbortError(message = \"AbortError\") {\n\tthrow new DOMException(message, \"AbortError\");\n}\n\n//#endregion\n//#region src/vendor/is-plain-object.ts\n/*!\n* is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n*\n* Copyright (c) 2014-2017, Jon Schlinkert.\n* Released under the MIT License.\n*/\nfunction isObject$1(o) {\n\treturn Object.prototype.toString.call(o) === \"[object Object]\";\n}\nfunction isPlainObject(o) {\n\tvar ctor, prot;\n\tif (isObject$1(o) === false) return false;\n\tctor = o.constructor;\n\tif (ctor === void 0) return true;\n\tprot = ctor.prototype;\n\tif (isObject$1(prot) === false) return false;\n\tif (prot.hasOwnProperty(\"isPrototypeOf\") === false) return false;\n\treturn true;\n}\n\n//#endregion\n//#region src/vendor/unpromise/unpromise.ts\nvar import_defineProperty = __toESM(require_defineProperty(), 1);\nlet _Symbol$toStringTag;\n/** Memory safe (weakmapped) cache of the ProxyPromise for each Promise,\n* which is retained for the lifetime of the original Promise.\n*/\nconst subscribableCache = /* @__PURE__ */ new WeakMap();\n/** A NOOP function allowing a consistent interface for settled\n* SubscribedPromises (settled promises are not subscribed - they resolve\n* immediately). */\nconst NOOP = () => {};\n_Symbol$toStringTag = Symbol.toStringTag;\n/**\n* Every `Promise<T>` can be shadowed by a single `ProxyPromise<T>`. It is\n* created once, cached and reused throughout the lifetime of the Promise. Get a\n* Promise's ProxyPromise using `Unpromise.proxy(promise)`.\n*\n* The `ProxyPromise<T>` attaches handlers to the original `Promise<T>`\n* `.then()` and `.catch()` just once. Promises derived from it use a\n* subscription- (and unsubscription-) based mechanism that monitors these\n* handlers.\n*\n* Every time you call `.subscribe()`, `.then()` `.catch()` or `.finally()` on a\n* `ProxyPromise<T>` it returns a `SubscribedPromise<T>` having an additional\n* `unsubscribe()` method. Calling `unsubscribe()` detaches reference chains\n* from the original, potentially long-lived Promise, eliminating memory leaks.\n*\n* This approach can eliminate the memory leaks that otherwise come about from\n* repeated `race()` or `any()` calls invoking `.then()` and `.catch()` multiple\n* times on the same long-lived native Promise (subscriptions which can never be\n* cleaned up).\n*\n* `Unpromise.race(promises)` is a reference implementation of `Promise.race`\n* avoiding memory leaks when using long-lived unsettled Promises.\n*\n* `Unpromise.any(promises)` is a reference implementation of `Promise.any`\n* avoiding memory leaks when using long-lived unsettled Promises.\n*\n* `Unpromise.resolve(promise)` returns an ephemeral `SubscribedPromise<T>` for\n* any given `Promise<T>` facilitating arbitrary async/await patterns. Behind\n* the scenes, `resolve` is implemented simply as\n* `Unpromise.proxy(promise).subscribe()`. Don't forget to call `.unsubscribe()`\n* to tidy up!\n*\n*/\nvar Unpromise = class Unpromise {\n\tconstructor(arg) {\n\t\t(0, import_defineProperty.default)(this, \"promise\", void 0);\n\t\t(0, import_defineProperty.default)(this, \"subscribers\", []);\n\t\t(0, import_defineProperty.default)(this, \"settlement\", null);\n\t\t(0, import_defineProperty.default)(this, _Symbol$toStringTag, \"Unpromise\");\n\t\tif (typeof arg === \"function\") this.promise = new Promise(arg);\n\t\telse this.promise = arg;\n\t\tconst thenReturn = this.promise.then((value) => {\n\t\t\tconst { subscribers } = this;\n\t\t\tthis.subscribers = null;\n\t\t\tthis.settlement = {\n\t\t\t\tstatus: \"fulfilled\",\n\t\t\t\tvalue\n\t\t\t};\n\t\t\tsubscribers === null || subscribers === void 0 || subscribers.forEach(({ resolve }) => {\n\t\t\t\tresolve(value);\n\t\t\t});\n\t\t});\n\t\tif (\"catch\" in thenReturn) thenReturn.catch((reason) => {\n\t\t\tconst { subscribers } = this;\n\t\t\tthis.subscribers = null;\n\t\t\tthis.settlement = {\n\t\t\t\tstatus: \"rejected\",\n\t\t\t\treason\n\t\t\t};\n\t\t\tsubscribers === null || subscribers === void 0 || subscribers.forEach(({ reject }) => {\n\t\t\t\treject(reason);\n\t\t\t});\n\t\t});\n\t}\n\t/** Create a promise that mitigates uncontrolled subscription to a long-lived\n\t* Promise via .then() and .catch() - otherwise a source of memory leaks.\n\t*\n\t* The returned promise has an `unsubscribe()` method which can be called when\n\t* the Promise is no longer being tracked by application logic, and which\n\t* ensures that there is no reference chain from the original promise to the\n\t* new one, and therefore no memory leak.\n\t*\n\t* If original promise has not yet settled, this adds a new unique promise\n\t* that listens to then/catch events, along with an `unsubscribe()` method to\n\t* detach it.\n\t*\n\t* If original promise has settled, then creates a new Promise.resolve() or\n\t* Promise.reject() and provided unsubscribe is a noop.\n\t*\n\t* If you call `unsubscribe()` before the returned Promise has settled, it\n\t* will never settle.\n\t*/\n\tsubscribe() {\n\t\tlet promise;\n\t\tlet unsubscribe;\n\t\tconst { settlement } = this;\n\t\tif (settlement === null) {\n\t\t\tif (this.subscribers === null) throw new Error(\"Unpromise settled but still has subscribers\");\n\t\t\tconst subscriber = withResolvers();\n\t\t\tthis.subscribers = listWithMember(this.subscribers, subscriber);\n\t\t\tpromise = subscriber.promise;\n\t\t\tunsubscribe = () => {\n\t\t\t\tif (this.subscribers !== null) this.subscribers = listWithoutMember(this.subscribers, subscriber);\n\t\t\t};\n\t\t} else {\n\t\t\tconst { status } = settlement;\n\t\t\tif (status === \"fulfilled\") promise = Promise.resolve(settlement.value);\n\t\t\telse promise = Promise.reject(settlement.reason);\n\t\t\tunsubscribe = NOOP;\n\t\t}\n\t\treturn Object.assign(promise, { unsubscribe });\n\t}\n\t/** STANDARD PROMISE METHODS (but returning a SubscribedPromise) */\n\tthen(onfulfilled, onrejected) {\n\t\tconst subscribed = this.subscribe();\n\t\tconst { unsubscribe } = subscribed;\n\t\treturn Object.assign(subscribed.then(onfulfilled, onrejected), { unsubscribe });\n\t}\n\tcatch(onrejected) {\n\t\tconst subscribed = this.subscribe();\n\t\tconst { unsubscribe } = subscribed;\n\t\treturn Object.assign(subscribed.catch(onrejected), { unsubscribe });\n\t}\n\tfinally(onfinally) {\n\t\tconst subscribed = this.subscribe();\n\t\tconst { unsubscribe } = subscribed;\n\t\treturn Object.assign(subscribed.finally(onfinally), { unsubscribe });\n\t}\n\t/** Unpromise STATIC METHODS */\n\t/** Create or Retrieve the proxy Unpromise (a re-used Unpromise for the VM lifetime\n\t* of the provided Promise reference) */\n\tstatic proxy(promise) {\n\t\tconst cached = Unpromise.getSubscribablePromise(promise);\n\t\treturn typeof cached !== \"undefined\" ? cached : Unpromise.createSubscribablePromise(promise);\n\t}\n\t/** Create and store an Unpromise keyed by an original Promise. */\n\tstatic createSubscribablePromise(promise) {\n\t\tconst created = new Unpromise(promise);\n\t\tsubscribableCache.set(promise, created);\n\t\tsubscribableCache.set(created, created);\n\t\treturn created;\n\t}\n\t/** Retrieve a previously-created Unpromise keyed by an original Promise. */\n\tstatic getSubscribablePromise(promise) {\n\t\treturn subscribableCache.get(promise);\n\t}\n\t/** Promise STATIC METHODS */\n\t/** Lookup the Unpromise for this promise, and derive a SubscribedPromise from\n\t* it (that can be later unsubscribed to eliminate Memory leaks) */\n\tstatic resolve(value) {\n\t\tconst promise = typeof value === \"object\" && value !== null && \"then\" in value && typeof value.then === \"function\" ? value : Promise.resolve(value);\n\t\treturn Unpromise.proxy(promise).subscribe();\n\t}\n\tstatic async any(values) {\n\t\tconst valuesArray = Array.isArray(values) ? values : [...values];\n\t\tconst subscribedPromises = valuesArray.map(Unpromise.resolve);\n\t\ttry {\n\t\t\treturn await Promise.any(subscribedPromises);\n\t\t} finally {\n\t\t\tsubscribedPromises.forEach(({ unsubscribe }) => {\n\t\t\t\tunsubscribe();\n\t\t\t});\n\t\t}\n\t}\n\tstatic async race(values) {\n\t\tconst valuesArray = Array.isArray(values) ? values : [...values];\n\t\tconst subscribedPromises = valuesArray.map(Unpromise.resolve);\n\t\ttry {\n\t\t\treturn await Promise.race(subscribedPromises);\n\t\t} finally {\n\t\t\tsubscribedPromises.forEach(({ unsubscribe }) => {\n\t\t\t\tunsubscribe();\n\t\t\t});\n\t\t}\n\t}\n\t/** Create a race of SubscribedPromises that will fulfil to a single winning\n\t* Promise (in a 1-Tuple). Eliminates memory leaks from long-lived promises\n\t* accumulating .then() and .catch() subscribers. Allows simple logic to\n\t* consume the result, like...\n\t* ```ts\n\t* const [ winner ] = await Unpromise.race([ promiseA, promiseB ]);\n\t* if(winner === promiseB){\n\t*   const result = await promiseB;\n\t*   // do the thing\n\t* }\n\t* ```\n\t* */\n\tstatic async raceReferences(promises) {\n\t\tconst selfPromises = promises.map(resolveSelfTuple);\n\t\ttry {\n\t\t\treturn await Promise.race(selfPromises);\n\t\t} finally {\n\t\t\tfor (const promise of selfPromises) promise.unsubscribe();\n\t\t}\n\t}\n};\n/** Promises a 1-tuple containing the original promise when it resolves. Allows\n* awaiting the eventual Promise ***reference*** (easy to destructure and\n* exactly compare with ===). Avoids resolving to the Promise ***value*** (which\n* may be ambiguous and therefore hard to identify as the winner of a race).\n* You can call unsubscribe on the Promise to mitigate memory leaks.\n* */\nfunction resolveSelfTuple(promise) {\n\treturn Unpromise.proxy(promise).then(() => [promise]);\n}\n/** VENDORED (Future) PROMISE UTILITIES */\n/** Reference implementation of https://github.com/tc39/proposal-promise-with-resolvers */\nfunction withResolvers() {\n\tlet resolve;\n\tlet reject;\n\tconst promise = new Promise((_resolve, _reject) => {\n\t\tresolve = _resolve;\n\t\treject = _reject;\n\t});\n\treturn {\n\t\tpromise,\n\t\tresolve,\n\t\treject\n\t};\n}\n/** IMMUTABLE LIST OPERATIONS */\nfunction listWithMember(arr, member) {\n\treturn [...arr, member];\n}\nfunction listWithoutIndex(arr, index) {\n\treturn [...arr.slice(0, index), ...arr.slice(index + 1)];\n}\nfunction listWithoutMember(arr, member) {\n\tconst index = arr.indexOf(member);\n\tif (index !== -1) return listWithoutIndex(arr, index);\n\treturn arr;\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/disposable.ts\nvar _Symbol, _Symbol$dispose, _Symbol2, _Symbol2$asyncDispose;\n(_Symbol$dispose = (_Symbol = Symbol).dispose) !== null && _Symbol$dispose !== void 0 || (_Symbol.dispose = Symbol());\n(_Symbol2$asyncDispose = (_Symbol2 = Symbol).asyncDispose) !== null && _Symbol2$asyncDispose !== void 0 || (_Symbol2.asyncDispose = Symbol());\n/**\n* Takes a value and a dispose function and returns a new object that implements the Disposable interface.\n* The returned object is the original value augmented with a Symbol.dispose method.\n* @param thing The value to make disposable\n* @param dispose Function to call when disposing the resource\n* @returns The original value with Symbol.dispose method added\n*/\nfunction makeResource(thing, dispose) {\n\tconst it = thing;\n\tconst existing = it[Symbol.dispose];\n\tit[Symbol.dispose] = () => {\n\t\tdispose();\n\t\texisting === null || existing === void 0 || existing();\n\t};\n\treturn it;\n}\n/**\n* Takes a value and an async dispose function and returns a new object that implements the AsyncDisposable interface.\n* The returned object is the original value augmented with a Symbol.asyncDispose method.\n* @param thing The value to make async disposable\n* @param dispose Async function to call when disposing the resource\n* @returns The original value with Symbol.asyncDispose method added\n*/\nfunction makeAsyncResource(thing, dispose) {\n\tconst it = thing;\n\tconst existing = it[Symbol.asyncDispose];\n\tit[Symbol.asyncDispose] = async () => {\n\t\tawait dispose();\n\t\tawait (existing === null || existing === void 0 ? void 0 : existing());\n\t};\n\treturn it;\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/timerResource.ts\nconst disposablePromiseTimerResult = Symbol();\nfunction timerResource(ms) {\n\tlet timer = null;\n\treturn makeResource({ start() {\n\t\tif (timer) throw new Error(\"Timer already started\");\n\t\tconst promise = new Promise((resolve) => {\n\t\t\ttimer = setTimeout(() => resolve(disposablePromiseTimerResult), ms);\n\t\t});\n\t\treturn promise;\n\t} }, () => {\n\t\tif (timer) clearTimeout(timer);\n\t});\n}\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/usingCtx.js\nvar require_usingCtx = __commonJS({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/usingCtx.js\"(exports, module) {\n\tfunction _usingCtx() {\n\t\tvar r = \"function\" == typeof SuppressedError ? SuppressedError : function(r$1, e$1) {\n\t\t\tvar n$1 = Error();\n\t\t\treturn n$1.name = \"SuppressedError\", n$1.error = r$1, n$1.suppressed = e$1, n$1;\n\t\t}, e = {}, n = [];\n\t\tfunction using(r$1, e$1) {\n\t\t\tif (null != e$1) {\n\t\t\t\tif (Object(e$1) !== e$1) throw new TypeError(\"using declarations can only be used with objects, functions, null, or undefined.\");\n\t\t\t\tif (r$1) var o = e$1[Symbol.asyncDispose || Symbol[\"for\"](\"Symbol.asyncDispose\")];\n\t\t\t\tif (void 0 === o && (o = e$1[Symbol.dispose || Symbol[\"for\"](\"Symbol.dispose\")], r$1)) var t = o;\n\t\t\t\tif (\"function\" != typeof o) throw new TypeError(\"Object is not disposable.\");\n\t\t\t\tt && (o = function o$1() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tt.call(e$1);\n\t\t\t\t\t} catch (r$2) {\n\t\t\t\t\t\treturn Promise.reject(r$2);\n\t\t\t\t\t}\n\t\t\t\t}), n.push({\n\t\t\t\t\tv: e$1,\n\t\t\t\t\td: o,\n\t\t\t\t\ta: r$1\n\t\t\t\t});\n\t\t\t} else r$1 && n.push({\n\t\t\t\td: e$1,\n\t\t\t\ta: r$1\n\t\t\t});\n\t\t\treturn e$1;\n\t\t}\n\t\treturn {\n\t\t\te,\n\t\t\tu: using.bind(null, !1),\n\t\t\ta: using.bind(null, !0),\n\t\t\td: function d() {\n\t\t\t\tvar o, t = this.e, s = 0;\n\t\t\t\tfunction next() {\n\t\t\t\t\tfor (; o = n.pop();) try {\n\t\t\t\t\t\tif (!o.a && 1 === s) return s = 0, n.push(o), Promise.resolve().then(next);\n\t\t\t\t\t\tif (o.d) {\n\t\t\t\t\t\t\tvar r$1 = o.d.call(o.v);\n\t\t\t\t\t\t\tif (o.a) return s |= 2, Promise.resolve(r$1).then(next, err);\n\t\t\t\t\t\t} else s |= 1;\n\t\t\t\t\t} catch (r$2) {\n\t\t\t\t\t\treturn err(r$2);\n\t\t\t\t\t}\n\t\t\t\t\tif (1 === s) return t !== e ? Promise.reject(t) : Promise.resolve();\n\t\t\t\t\tif (t !== e) throw t;\n\t\t\t\t}\n\t\t\t\tfunction err(n$1) {\n\t\t\t\t\treturn t = t !== e ? new r(n$1, t) : n$1, next();\n\t\t\t\t}\n\t\t\t\treturn next();\n\t\t\t}\n\t\t};\n\t}\n\tmodule.exports = _usingCtx, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n} });\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/OverloadYield.js\nvar require_OverloadYield = __commonJS({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/OverloadYield.js\"(exports, module) {\n\tfunction _OverloadYield(e, d) {\n\t\tthis.v = e, this.k = d;\n\t}\n\tmodule.exports = _OverloadYield, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n} });\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/awaitAsyncGenerator.js\nvar require_awaitAsyncGenerator = __commonJS({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/awaitAsyncGenerator.js\"(exports, module) {\n\tvar OverloadYield$2 = require_OverloadYield();\n\tfunction _awaitAsyncGenerator$5(e) {\n\t\treturn new OverloadYield$2(e, 0);\n\t}\n\tmodule.exports = _awaitAsyncGenerator$5, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n} });\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/wrapAsyncGenerator.js\nvar require_wrapAsyncGenerator = __commonJS({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/wrapAsyncGenerator.js\"(exports, module) {\n\tvar OverloadYield$1 = require_OverloadYield();\n\tfunction _wrapAsyncGenerator$6(e) {\n\t\treturn function() {\n\t\t\treturn new AsyncGenerator(e.apply(this, arguments));\n\t\t};\n\t}\n\tfunction AsyncGenerator(e) {\n\t\tvar r, t;\n\t\tfunction resume(r$1, t$1) {\n\t\t\ttry {\n\t\t\t\tvar n = e[r$1](t$1), o = n.value, u = o instanceof OverloadYield$1;\n\t\t\t\tPromise.resolve(u ? o.v : o).then(function(t$2) {\n\t\t\t\t\tif (u) {\n\t\t\t\t\t\tvar i = \"return\" === r$1 ? \"return\" : \"next\";\n\t\t\t\t\t\tif (!o.k || t$2.done) return resume(i, t$2);\n\t\t\t\t\t\tt$2 = e[i](t$2).value;\n\t\t\t\t\t}\n\t\t\t\t\tsettle(n.done ? \"return\" : \"normal\", t$2);\n\t\t\t\t}, function(e$1) {\n\t\t\t\t\tresume(\"throw\", e$1);\n\t\t\t\t});\n\t\t\t} catch (e$1) {\n\t\t\t\tsettle(\"throw\", e$1);\n\t\t\t}\n\t\t}\n\t\tfunction settle(e$1, n) {\n\t\t\tswitch (e$1) {\n\t\t\t\tcase \"return\":\n\t\t\t\t\tr.resolve({\n\t\t\t\t\t\tvalue: n,\n\t\t\t\t\t\tdone: !0\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"throw\":\n\t\t\t\t\tr.reject(n);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault: r.resolve({\n\t\t\t\t\tvalue: n,\n\t\t\t\t\tdone: !1\n\t\t\t\t});\n\t\t\t}\n\t\t\t(r = r.next) ? resume(r.key, r.arg) : t = null;\n\t\t}\n\t\tthis._invoke = function(e$1, n) {\n\t\t\treturn new Promise(function(o, u) {\n\t\t\t\tvar i = {\n\t\t\t\t\tkey: e$1,\n\t\t\t\t\targ: n,\n\t\t\t\t\tresolve: o,\n\t\t\t\t\treject: u,\n\t\t\t\t\tnext: null\n\t\t\t\t};\n\t\t\t\tt ? t = t.next = i : (r = t = i, resume(e$1, n));\n\t\t\t});\n\t\t}, \"function\" != typeof e[\"return\"] && (this[\"return\"] = void 0);\n\t}\n\tAsyncGenerator.prototype[\"function\" == typeof Symbol && Symbol.asyncIterator || \"@@asyncIterator\"] = function() {\n\t\treturn this;\n\t}, AsyncGenerator.prototype.next = function(e) {\n\t\treturn this._invoke(\"next\", e);\n\t}, AsyncGenerator.prototype[\"throw\"] = function(e) {\n\t\treturn this._invoke(\"throw\", e);\n\t}, AsyncGenerator.prototype[\"return\"] = function(e) {\n\t\treturn this._invoke(\"return\", e);\n\t};\n\tmodule.exports = _wrapAsyncGenerator$6, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n} });\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/asyncIterable.ts\nvar import_usingCtx$4 = __toESM(require_usingCtx(), 1);\nvar import_awaitAsyncGenerator$4 = __toESM(require_awaitAsyncGenerator(), 1);\nvar import_wrapAsyncGenerator$5 = __toESM(require_wrapAsyncGenerator(), 1);\nfunction iteratorResource(iterable) {\n\tconst iterator = iterable[Symbol.asyncIterator]();\n\tif (iterator[Symbol.asyncDispose]) return iterator;\n\treturn makeAsyncResource(iterator, async () => {\n\t\tvar _iterator$return;\n\t\tawait ((_iterator$return = iterator.return) === null || _iterator$return === void 0 ? void 0 : _iterator$return.call(iterator));\n\t});\n}\n/**\n* Derives a new {@link AsyncGenerator} based of {@link iterable}, that yields its first\n* {@link count} values. Then, a grace period of {@link gracePeriodMs} is started in which further\n* values may still come through. After this period, the generator aborts.\n*/\nfunction takeWithGrace(_x, _x2) {\n\treturn _takeWithGrace.apply(this, arguments);\n}\nfunction _takeWithGrace() {\n\t_takeWithGrace = (0, import_wrapAsyncGenerator$5.default)(function* (iterable, opts) {\n\t\ttry {\n\t\t\tvar _usingCtx$1 = (0, import_usingCtx$4.default)();\n\t\t\tconst iterator = _usingCtx$1.a(iteratorResource(iterable));\n\t\t\tlet result;\n\t\t\tconst timer = _usingCtx$1.u(timerResource(opts.gracePeriodMs));\n\t\t\tlet count = opts.count;\n\t\t\tlet timerPromise = new Promise(() => {});\n\t\t\twhile (true) {\n\t\t\t\tresult = yield (0, import_awaitAsyncGenerator$4.default)(Unpromise.race([iterator.next(), timerPromise]));\n\t\t\t\tif (result === disposablePromiseTimerResult) throwAbortError();\n\t\t\t\tif (result.done) return result.value;\n\t\t\t\tyield result.value;\n\t\t\t\tif (--count === 0) timerPromise = timer.start();\n\t\t\t\tresult = null;\n\t\t\t}\n\t\t} catch (_) {\n\t\t\t_usingCtx$1.e = _;\n\t\t} finally {\n\t\t\tyield (0, import_awaitAsyncGenerator$4.default)(_usingCtx$1.d());\n\t\t}\n\t});\n\treturn _takeWithGrace.apply(this, arguments);\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/createDeferred.ts\nfunction createDeferred() {\n\tlet resolve;\n\tlet reject;\n\tconst promise = new Promise((res, rej) => {\n\t\tresolve = res;\n\t\treject = rej;\n\t});\n\treturn {\n\t\tpromise,\n\t\tresolve,\n\t\treject\n\t};\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/mergeAsyncIterables.ts\nvar import_usingCtx$3 = __toESM(require_usingCtx(), 1);\nvar import_awaitAsyncGenerator$3 = __toESM(require_awaitAsyncGenerator(), 1);\nvar import_wrapAsyncGenerator$4 = __toESM(require_wrapAsyncGenerator(), 1);\nfunction createManagedIterator(iterable, onResult) {\n\tconst iterator = iterable[Symbol.asyncIterator]();\n\tlet state = \"idle\";\n\tfunction cleanup() {\n\t\tstate = \"done\";\n\t\tonResult = () => {};\n\t}\n\tfunction pull() {\n\t\tif (state !== \"idle\") return;\n\t\tstate = \"pending\";\n\t\tconst next = iterator.next();\n\t\tnext.then((result) => {\n\t\t\tif (result.done) {\n\t\t\t\tstate = \"done\";\n\t\t\t\tonResult({\n\t\t\t\t\tstatus: \"return\",\n\t\t\t\t\tvalue: result.value\n\t\t\t\t});\n\t\t\t\tcleanup();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstate = \"idle\";\n\t\t\tonResult({\n\t\t\t\tstatus: \"yield\",\n\t\t\t\tvalue: result.value\n\t\t\t});\n\t\t}).catch((cause) => {\n\t\t\tonResult({\n\t\t\t\tstatus: \"error\",\n\t\t\t\terror: cause\n\t\t\t});\n\t\t\tcleanup();\n\t\t});\n\t}\n\treturn {\n\t\tpull,\n\t\tdestroy: async () => {\n\t\t\tvar _iterator$return;\n\t\t\tcleanup();\n\t\t\tawait ((_iterator$return = iterator.return) === null || _iterator$return === void 0 ? void 0 : _iterator$return.call(iterator));\n\t\t}\n\t};\n}\n/**\n* Creates a new async iterable that merges multiple async iterables into a single stream.\n* Values from the input iterables are yielded in the order they resolve, similar to Promise.race().\n*\n* New iterables can be added dynamically using the returned {@link MergedAsyncIterables.add} method, even after iteration has started.\n*\n* If any of the input iterables throws an error, that error will be propagated through the merged stream.\n* Other iterables will not continue to be processed.\n*\n* @template TYield The type of values yielded by the input iterables\n*/\nfunction mergeAsyncIterables() {\n\tlet state = \"idle\";\n\tlet flushSignal = createDeferred();\n\t/**\n\t* used while {@link state} is `idle`\n\t*/\n\tconst iterables = [];\n\t/**\n\t* used while {@link state} is `pending`\n\t*/\n\tconst iterators = /* @__PURE__ */ new Set();\n\tconst buffer = [];\n\tfunction initIterable(iterable) {\n\t\tif (state !== \"pending\") return;\n\t\tconst iterator = createManagedIterator(iterable, (result) => {\n\t\t\tif (state !== \"pending\") return;\n\t\t\tswitch (result.status) {\n\t\t\t\tcase \"yield\":\n\t\t\t\t\tbuffer.push([iterator, result]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"return\":\n\t\t\t\t\titerators.delete(iterator);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"error\":\n\t\t\t\t\tbuffer.push([iterator, result]);\n\t\t\t\t\titerators.delete(iterator);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tflushSignal.resolve();\n\t\t});\n\t\titerators.add(iterator);\n\t\titerator.pull();\n\t}\n\treturn {\n\t\tadd(iterable) {\n\t\t\tswitch (state) {\n\t\t\t\tcase \"idle\":\n\t\t\t\t\titerables.push(iterable);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"pending\":\n\t\t\t\t\tinitIterable(iterable);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"done\": break;\n\t\t\t}\n\t\t},\n\t\t[Symbol.asyncIterator]() {\n\t\t\treturn (0, import_wrapAsyncGenerator$4.default)(function* () {\n\t\t\t\ttry {\n\t\t\t\t\tvar _usingCtx$1 = (0, import_usingCtx$3.default)();\n\t\t\t\t\tif (state !== \"idle\") throw new Error(\"Cannot iterate twice\");\n\t\t\t\t\tstate = \"pending\";\n\t\t\t\t\tconst _finally = _usingCtx$1.a(makeAsyncResource({}, async () => {\n\t\t\t\t\t\tstate = \"done\";\n\t\t\t\t\t\tconst errors = [];\n\t\t\t\t\t\tawait Promise.all(Array.from(iterators.values()).map(async (it) => {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tawait it.destroy();\n\t\t\t\t\t\t\t} catch (cause) {\n\t\t\t\t\t\t\t\terrors.push(cause);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}));\n\t\t\t\t\t\tbuffer.length = 0;\n\t\t\t\t\t\titerators.clear();\n\t\t\t\t\t\tflushSignal.resolve();\n\t\t\t\t\t\tif (errors.length > 0) throw new AggregateError(errors);\n\t\t\t\t\t}));\n\t\t\t\t\twhile (iterables.length > 0) initIterable(iterables.shift());\n\t\t\t\t\twhile (iterators.size > 0) {\n\t\t\t\t\t\tyield (0, import_awaitAsyncGenerator$3.default)(flushSignal.promise);\n\t\t\t\t\t\twhile (buffer.length > 0) {\n\t\t\t\t\t\t\tconst [iterator, result] = buffer.shift();\n\t\t\t\t\t\t\tswitch (result.status) {\n\t\t\t\t\t\t\t\tcase \"yield\":\n\t\t\t\t\t\t\t\t\tyield result.value;\n\t\t\t\t\t\t\t\t\titerator.pull();\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"error\": throw result.error;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tflushSignal = createDeferred();\n\t\t\t\t\t}\n\t\t\t\t} catch (_) {\n\t\t\t\t\t_usingCtx$1.e = _;\n\t\t\t\t} finally {\n\t\t\t\t\tyield (0, import_awaitAsyncGenerator$3.default)(_usingCtx$1.d());\n\t\t\t\t}\n\t\t\t})();\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/readableStreamFrom.ts\n/**\n* Creates a ReadableStream from an AsyncIterable.\n*\n* @param iterable - The source AsyncIterable to stream from\n* @returns A ReadableStream that yields values from the AsyncIterable\n*/\nfunction readableStreamFrom(iterable) {\n\tconst iterator = iterable[Symbol.asyncIterator]();\n\treturn new ReadableStream({\n\t\tasync cancel() {\n\t\t\tvar _iterator$return;\n\t\t\tawait ((_iterator$return = iterator.return) === null || _iterator$return === void 0 ? void 0 : _iterator$return.call(iterator));\n\t\t},\n\t\tasync pull(controller) {\n\t\t\tconst result = await iterator.next();\n\t\t\tif (result.done) {\n\t\t\t\tcontroller.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcontroller.enqueue(result.value);\n\t\t}\n\t});\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/withPing.ts\nvar import_usingCtx$2 = __toESM(require_usingCtx(), 1);\nvar import_awaitAsyncGenerator$2 = __toESM(require_awaitAsyncGenerator(), 1);\nvar import_wrapAsyncGenerator$3 = __toESM(require_wrapAsyncGenerator(), 1);\nconst PING_SYM = Symbol(\"ping\");\n/**\n* Derives a new {@link AsyncGenerator} based of {@link iterable}, that yields {@link PING_SYM}\n* whenever no value has been yielded for {@link pingIntervalMs}.\n*/\nfunction withPing(_x, _x2) {\n\treturn _withPing.apply(this, arguments);\n}\nfunction _withPing() {\n\t_withPing = (0, import_wrapAsyncGenerator$3.default)(function* (iterable, pingIntervalMs) {\n\t\ttry {\n\t\t\tvar _usingCtx$1 = (0, import_usingCtx$2.default)();\n\t\t\tconst iterator = _usingCtx$1.a(iteratorResource(iterable));\n\t\t\tlet result;\n\t\t\tlet nextPromise = iterator.next();\n\t\t\twhile (true) try {\n\t\t\t\tvar _usingCtx3 = (0, import_usingCtx$2.default)();\n\t\t\t\tconst pingPromise = _usingCtx3.u(timerResource(pingIntervalMs));\n\t\t\t\tresult = yield (0, import_awaitAsyncGenerator$2.default)(Unpromise.race([nextPromise, pingPromise.start()]));\n\t\t\t\tif (result === disposablePromiseTimerResult) {\n\t\t\t\t\tyield PING_SYM;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (result.done) return result.value;\n\t\t\t\tnextPromise = iterator.next();\n\t\t\t\tyield result.value;\n\t\t\t\tresult = null;\n\t\t\t} catch (_) {\n\t\t\t\t_usingCtx3.e = _;\n\t\t\t} finally {\n\t\t\t\t_usingCtx3.d();\n\t\t\t}\n\t\t} catch (_) {\n\t\t\t_usingCtx$1.e = _;\n\t\t} finally {\n\t\t\tyield (0, import_awaitAsyncGenerator$2.default)(_usingCtx$1.d());\n\t\t}\n\t});\n\treturn _withPing.apply(this, arguments);\n}\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/asyncIterator.js\nvar require_asyncIterator = __commonJS({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/asyncIterator.js\"(exports, module) {\n\tfunction _asyncIterator$2(r) {\n\t\tvar n, t, o, e = 2;\n\t\tfor (\"undefined\" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) {\n\t\t\tif (t && null != (n = r[t])) return n.call(r);\n\t\t\tif (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r));\n\t\t\tt = \"@@asyncIterator\", o = \"@@iterator\";\n\t\t}\n\t\tthrow new TypeError(\"Object is not async iterable\");\n\t}\n\tfunction AsyncFromSyncIterator(r) {\n\t\tfunction AsyncFromSyncIteratorContinuation(r$1) {\n\t\t\tif (Object(r$1) !== r$1) return Promise.reject(new TypeError(r$1 + \" is not an object.\"));\n\t\t\tvar n = r$1.done;\n\t\t\treturn Promise.resolve(r$1.value).then(function(r$2) {\n\t\t\t\treturn {\n\t\t\t\t\tvalue: r$2,\n\t\t\t\t\tdone: n\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\t\treturn AsyncFromSyncIterator = function AsyncFromSyncIterator$1(r$1) {\n\t\t\tthis.s = r$1, this.n = r$1.next;\n\t\t}, AsyncFromSyncIterator.prototype = {\n\t\t\ts: null,\n\t\t\tn: null,\n\t\t\tnext: function next() {\n\t\t\t\treturn AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));\n\t\t\t},\n\t\t\t\"return\": function _return(r$1) {\n\t\t\t\tvar n = this.s[\"return\"];\n\t\t\t\treturn void 0 === n ? Promise.resolve({\n\t\t\t\t\tvalue: r$1,\n\t\t\t\t\tdone: !0\n\t\t\t\t}) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));\n\t\t\t},\n\t\t\t\"throw\": function _throw(r$1) {\n\t\t\t\tvar n = this.s[\"return\"];\n\t\t\t\treturn void 0 === n ? Promise.reject(r$1) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));\n\t\t\t}\n\t\t}, new AsyncFromSyncIterator(r);\n\t}\n\tmodule.exports = _asyncIterator$2, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n} });\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/jsonl.ts\nvar import_awaitAsyncGenerator$1 = __toESM(require_awaitAsyncGenerator(), 1);\nvar import_wrapAsyncGenerator$2 = __toESM(require_wrapAsyncGenerator(), 1);\nvar import_usingCtx$1 = __toESM(require_usingCtx(), 1);\nvar import_asyncIterator$1 = __toESM(require_asyncIterator(), 1);\nconst CHUNK_VALUE_TYPE_PROMISE = 0;\nconst CHUNK_VALUE_TYPE_ASYNC_ITERABLE = 1;\nconst PROMISE_STATUS_FULFILLED = 0;\nconst PROMISE_STATUS_REJECTED = 1;\nconst ASYNC_ITERABLE_STATUS_RETURN = 0;\nconst ASYNC_ITERABLE_STATUS_YIELD = 1;\nconst ASYNC_ITERABLE_STATUS_ERROR = 2;\nfunction isPromise(value) {\n\treturn (isObject(value) || isFunction(value)) && typeof (value === null || value === void 0 ? void 0 : value[\"then\"]) === \"function\" && typeof (value === null || value === void 0 ? void 0 : value[\"catch\"]) === \"function\";\n}\nvar MaxDepthError = class extends Error {\n\tconstructor(path) {\n\t\tsuper(\"Max depth reached at path: \" + path.join(\".\"));\n\t\tthis.path = path;\n\t}\n};\nfunction createBatchStreamProducer(_x3) {\n\treturn _createBatchStreamProducer.apply(this, arguments);\n}\nfunction _createBatchStreamProducer() {\n\t_createBatchStreamProducer = (0, import_wrapAsyncGenerator$2.default)(function* (opts) {\n\t\tconst { data } = opts;\n\t\tlet counter = 0;\n\t\tconst placeholder = 0;\n\t\tconst mergedIterables = mergeAsyncIterables();\n\t\tfunction registerAsync(callback) {\n\t\t\tconst idx = counter++;\n\t\t\tconst iterable$1 = callback(idx);\n\t\t\tmergedIterables.add(iterable$1);\n\t\t\treturn idx;\n\t\t}\n\t\tfunction encodePromise(promise, path) {\n\t\t\treturn registerAsync(/* @__PURE__ */ function() {\n\t\t\t\tvar _ref = (0, import_wrapAsyncGenerator$2.default)(function* (idx) {\n\t\t\t\t\tconst error = checkMaxDepth(path);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tpromise.catch((cause) => {\n\t\t\t\t\t\t\tvar _opts$onError;\n\t\t\t\t\t\t\t(_opts$onError = opts.onError) === null || _opts$onError === void 0 || _opts$onError.call(opts, {\n\t\t\t\t\t\t\t\terror: cause,\n\t\t\t\t\t\t\t\tpath\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\tpromise = Promise.reject(error);\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst next = yield (0, import_awaitAsyncGenerator$1.default)(promise);\n\t\t\t\t\t\tyield [\n\t\t\t\t\t\t\tidx,\n\t\t\t\t\t\t\tPROMISE_STATUS_FULFILLED,\n\t\t\t\t\t\t\tencode(next, path)\n\t\t\t\t\t\t];\n\t\t\t\t\t} catch (cause) {\n\t\t\t\t\t\tvar _opts$onError2, _opts$formatError;\n\t\t\t\t\t\t(_opts$onError2 = opts.onError) === null || _opts$onError2 === void 0 || _opts$onError2.call(opts, {\n\t\t\t\t\t\t\terror: cause,\n\t\t\t\t\t\t\tpath\n\t\t\t\t\t\t});\n\t\t\t\t\t\tyield [\n\t\t\t\t\t\t\tidx,\n\t\t\t\t\t\t\tPROMISE_STATUS_REJECTED,\n\t\t\t\t\t\t\t(_opts$formatError = opts.formatError) === null || _opts$formatError === void 0 ? void 0 : _opts$formatError.call(opts, {\n\t\t\t\t\t\t\t\terror: cause,\n\t\t\t\t\t\t\t\tpath\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn function(_x) {\n\t\t\t\t\treturn _ref.apply(this, arguments);\n\t\t\t\t};\n\t\t\t}());\n\t\t}\n\t\tfunction encodeAsyncIterable(iterable$1, path) {\n\t\t\treturn registerAsync(/* @__PURE__ */ function() {\n\t\t\t\tvar _ref2 = (0, import_wrapAsyncGenerator$2.default)(function* (idx) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar _usingCtx$1 = (0, import_usingCtx$1.default)();\n\t\t\t\t\t\tconst error = checkMaxDepth(path);\n\t\t\t\t\t\tif (error) throw error;\n\t\t\t\t\t\tconst iterator = _usingCtx$1.a(iteratorResource(iterable$1));\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\tconst next = yield (0, import_awaitAsyncGenerator$1.default)(iterator.next());\n\t\t\t\t\t\t\t\tif (next.done) {\n\t\t\t\t\t\t\t\t\tyield [\n\t\t\t\t\t\t\t\t\t\tidx,\n\t\t\t\t\t\t\t\t\t\tASYNC_ITERABLE_STATUS_RETURN,\n\t\t\t\t\t\t\t\t\t\tencode(next.value, path)\n\t\t\t\t\t\t\t\t\t];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tyield [\n\t\t\t\t\t\t\t\t\tidx,\n\t\t\t\t\t\t\t\t\tASYNC_ITERABLE_STATUS_YIELD,\n\t\t\t\t\t\t\t\t\tencode(next.value, path)\n\t\t\t\t\t\t\t\t];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (cause) {\n\t\t\t\t\t\t\tvar _opts$onError3, _opts$formatError2;\n\t\t\t\t\t\t\t(_opts$onError3 = opts.onError) === null || _opts$onError3 === void 0 || _opts$onError3.call(opts, {\n\t\t\t\t\t\t\t\terror: cause,\n\t\t\t\t\t\t\t\tpath\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tyield [\n\t\t\t\t\t\t\t\tidx,\n\t\t\t\t\t\t\t\tASYNC_ITERABLE_STATUS_ERROR,\n\t\t\t\t\t\t\t\t(_opts$formatError2 = opts.formatError) === null || _opts$formatError2 === void 0 ? void 0 : _opts$formatError2.call(opts, {\n\t\t\t\t\t\t\t\t\terror: cause,\n\t\t\t\t\t\t\t\t\tpath\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t];\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (_) {\n\t\t\t\t\t\t_usingCtx$1.e = _;\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tyield (0, import_awaitAsyncGenerator$1.default)(_usingCtx$1.d());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn function(_x2) {\n\t\t\t\t\treturn _ref2.apply(this, arguments);\n\t\t\t\t};\n\t\t\t}());\n\t\t}\n\t\tfunction checkMaxDepth(path) {\n\t\t\tif (opts.maxDepth && path.length > opts.maxDepth) return new MaxDepthError(path);\n\t\t\treturn null;\n\t\t}\n\t\tfunction encodeAsync(value, path) {\n\t\t\tif (isPromise(value)) return [CHUNK_VALUE_TYPE_PROMISE, encodePromise(value, path)];\n\t\t\tif (isAsyncIterable(value)) {\n\t\t\t\tif (opts.maxDepth && path.length >= opts.maxDepth) throw new Error(\"Max depth reached\");\n\t\t\t\treturn [CHUNK_VALUE_TYPE_ASYNC_ITERABLE, encodeAsyncIterable(value, path)];\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tfunction encode(value, path) {\n\t\t\tif (value === void 0) return [[]];\n\t\t\tconst reg = encodeAsync(value, path);\n\t\t\tif (reg) return [[placeholder], [null, ...reg]];\n\t\t\tif (!isPlainObject(value)) return [[value]];\n\t\t\tconst newObj = emptyObject();\n\t\t\tconst asyncValues = [];\n\t\t\tfor (const [key, item] of Object.entries(value)) {\n\t\t\t\tconst transformed = encodeAsync(item, [...path, key]);\n\t\t\t\tif (!transformed) {\n\t\t\t\t\tnewObj[key] = item;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnewObj[key] = placeholder;\n\t\t\t\tasyncValues.push([key, ...transformed]);\n\t\t\t}\n\t\t\treturn [[newObj], ...asyncValues];\n\t\t}\n\t\tconst newHead = emptyObject();\n\t\tfor (const [key, item] of Object.entries(data)) newHead[key] = encode(item, [key]);\n\t\tyield newHead;\n\t\tlet iterable = mergedIterables;\n\t\tif (opts.pingMs) iterable = withPing(mergedIterables, opts.pingMs);\n\t\tvar _iteratorAbruptCompletion = false;\n\t\tvar _didIteratorError = false;\n\t\tvar _iteratorError;\n\t\ttry {\n\t\t\tfor (var _iterator = (0, import_asyncIterator$1.default)(iterable), _step; _iteratorAbruptCompletion = !(_step = yield (0, import_awaitAsyncGenerator$1.default)(_iterator.next())).done; _iteratorAbruptCompletion = false) {\n\t\t\t\tconst value = _step.value;\n\t\t\t\tyield value;\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError = true;\n\t\t\t_iteratorError = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (_iteratorAbruptCompletion && _iterator.return != null) yield (0, import_awaitAsyncGenerator$1.default)(_iterator.return());\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError) throw _iteratorError;\n\t\t\t}\n\t\t}\n\t});\n\treturn _createBatchStreamProducer.apply(this, arguments);\n}\n/**\n* JSON Lines stream producer\n* @see https://jsonlines.org/\n*/\nfunction jsonlStreamProducer(opts) {\n\tlet stream = readableStreamFrom(createBatchStreamProducer(opts));\n\tconst { serialize } = opts;\n\tif (serialize) stream = stream.pipeThrough(new TransformStream({ transform(chunk, controller) {\n\t\tif (chunk === PING_SYM) controller.enqueue(PING_SYM);\n\t\telse controller.enqueue(serialize(chunk));\n\t} }));\n\treturn stream.pipeThrough(new TransformStream({ transform(chunk, controller) {\n\t\tif (chunk === PING_SYM) controller.enqueue(\" \");\n\t\telse controller.enqueue(JSON.stringify(chunk) + \"\\n\");\n\t} })).pipeThrough(new TextEncoderStream());\n}\nvar AsyncError = class extends Error {\n\tconstructor(data) {\n\t\tsuper(\"Received error from server\");\n\t\tthis.data = data;\n\t}\n};\nconst nodeJsStreamToReaderEsque = (source) => {\n\treturn { getReader() {\n\t\tconst stream = new ReadableStream({ start(controller) {\n\t\t\tsource.on(\"data\", (chunk) => {\n\t\t\t\tcontroller.enqueue(chunk);\n\t\t\t});\n\t\t\tsource.on(\"end\", () => {\n\t\t\t\tcontroller.close();\n\t\t\t});\n\t\t\tsource.on(\"error\", (error) => {\n\t\t\t\tcontroller.error(error);\n\t\t\t});\n\t\t} });\n\t\treturn stream.getReader();\n\t} };\n};\nfunction createLineAccumulator(from) {\n\tconst reader = \"getReader\" in from ? from.getReader() : nodeJsStreamToReaderEsque(from).getReader();\n\tlet lineAggregate = \"\";\n\treturn new ReadableStream({\n\t\tasync pull(controller) {\n\t\t\tconst { done, value } = await reader.read();\n\t\t\tif (done) controller.close();\n\t\t\telse controller.enqueue(value);\n\t\t},\n\t\tcancel() {\n\t\t\treturn reader.cancel();\n\t\t}\n\t}).pipeThrough(new TextDecoderStream()).pipeThrough(new TransformStream({ transform(chunk, controller) {\n\t\tvar _parts$pop;\n\t\tlineAggregate += chunk;\n\t\tconst parts = lineAggregate.split(\"\\n\");\n\t\tlineAggregate = (_parts$pop = parts.pop()) !== null && _parts$pop !== void 0 ? _parts$pop : \"\";\n\t\tfor (const part of parts) controller.enqueue(part);\n\t} }));\n}\nfunction createConsumerStream(from) {\n\tconst stream = createLineAccumulator(from);\n\tlet sentHead = false;\n\treturn stream.pipeThrough(new TransformStream({ transform(line, controller) {\n\t\tif (!sentHead) {\n\t\t\tconst head = JSON.parse(line);\n\t\t\tcontroller.enqueue(head);\n\t\t\tsentHead = true;\n\t\t} else {\n\t\t\tconst chunk = JSON.parse(line);\n\t\t\tcontroller.enqueue(chunk);\n\t\t}\n\t} }));\n}\n/**\n* Creates a handler for managing stream controllers and their lifecycle\n*/\nfunction createStreamsManager(abortController) {\n\tconst controllerMap = /* @__PURE__ */ new Map();\n\t/**\n\t* Checks if there are no pending controllers or deferred promises\n\t*/\n\tfunction isEmpty() {\n\t\treturn Array.from(controllerMap.values()).every((c) => c.closed);\n\t}\n\t/**\n\t* Creates a stream controller\n\t*/\n\tfunction createStreamController() {\n\t\tlet originalController;\n\t\tconst stream = new ReadableStream({ start(controller) {\n\t\t\toriginalController = controller;\n\t\t} });\n\t\tconst streamController = {\n\t\t\tenqueue: (v) => originalController.enqueue(v),\n\t\t\tclose: () => {\n\t\t\t\toriginalController.close();\n\t\t\t\tclear();\n\t\t\t\tif (isEmpty()) abortController.abort();\n\t\t\t},\n\t\t\tclosed: false,\n\t\t\tgetReaderResource: () => {\n\t\t\t\tconst reader = stream.getReader();\n\t\t\t\treturn makeResource(reader, () => {\n\t\t\t\t\tstreamController.close();\n\t\t\t\t\treader.releaseLock();\n\t\t\t\t});\n\t\t\t},\n\t\t\terror: (reason) => {\n\t\t\t\toriginalController.error(reason);\n\t\t\t\tclear();\n\t\t\t}\n\t\t};\n\t\tfunction clear() {\n\t\t\tObject.assign(streamController, {\n\t\t\t\tclosed: true,\n\t\t\t\tclose: () => {},\n\t\t\t\tenqueue: () => {},\n\t\t\t\tgetReaderResource: null,\n\t\t\t\terror: () => {}\n\t\t\t});\n\t\t}\n\t\treturn streamController;\n\t}\n\t/**\n\t* Gets or creates a stream controller\n\t*/\n\tfunction getOrCreate(chunkId) {\n\t\tlet c = controllerMap.get(chunkId);\n\t\tif (!c) {\n\t\t\tc = createStreamController();\n\t\t\tcontrollerMap.set(chunkId, c);\n\t\t}\n\t\treturn c;\n\t}\n\t/**\n\t* Cancels all pending controllers and rejects deferred promises\n\t*/\n\tfunction cancelAll(reason) {\n\t\tfor (const controller of controllerMap.values()) controller.error(reason);\n\t}\n\treturn {\n\t\tgetOrCreate,\n\t\tcancelAll\n\t};\n}\n/**\n* JSON Lines stream consumer\n* @see https://jsonlines.org/\n*/\nasync function jsonlStreamConsumer(opts) {\n\tconst { deserialize = (v) => v } = opts;\n\tlet source = createConsumerStream(opts.from);\n\tif (deserialize) source = source.pipeThrough(new TransformStream({ transform(chunk, controller) {\n\t\tcontroller.enqueue(deserialize(chunk));\n\t} }));\n\tlet headDeferred = createDeferred();\n\tconst streamManager = createStreamsManager(opts.abortController);\n\tfunction decodeChunkDefinition(value) {\n\t\tconst [_path, type, chunkId] = value;\n\t\tconst controller = streamManager.getOrCreate(chunkId);\n\t\tswitch (type) {\n\t\t\tcase CHUNK_VALUE_TYPE_PROMISE: return run(async () => {\n\t\t\t\ttry {\n\t\t\t\t\tvar _usingCtx3 = (0, import_usingCtx$1.default)();\n\t\t\t\t\tconst reader = _usingCtx3.u(controller.getReaderResource());\n\t\t\t\t\tconst { value: value$1 } = await reader.read();\n\t\t\t\t\tconst [_chunkId, status, data] = value$1;\n\t\t\t\t\tswitch (status) {\n\t\t\t\t\t\tcase PROMISE_STATUS_FULFILLED: return decode(data);\n\t\t\t\t\t\tcase PROMISE_STATUS_REJECTED:\n\t\t\t\t\t\t\tvar _opts$formatError3, _opts$formatError4;\n\t\t\t\t\t\t\tthrow (_opts$formatError3 = (_opts$formatError4 = opts.formatError) === null || _opts$formatError4 === void 0 ? void 0 : _opts$formatError4.call(opts, { error: data })) !== null && _opts$formatError3 !== void 0 ? _opts$formatError3 : new AsyncError(data);\n\t\t\t\t\t}\n\t\t\t\t} catch (_) {\n\t\t\t\t\t_usingCtx3.e = _;\n\t\t\t\t} finally {\n\t\t\t\t\t_usingCtx3.d();\n\t\t\t\t}\n\t\t\t});\n\t\t\tcase CHUNK_VALUE_TYPE_ASYNC_ITERABLE: return run((0, import_wrapAsyncGenerator$2.default)(function* () {\n\t\t\t\ttry {\n\t\t\t\t\tvar _usingCtx4 = (0, import_usingCtx$1.default)();\n\t\t\t\t\tconst reader = _usingCtx4.u(controller.getReaderResource());\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tconst { value: value$1 } = yield (0, import_awaitAsyncGenerator$1.default)(reader.read());\n\t\t\t\t\t\tconst [_chunkId, status, data] = value$1;\n\t\t\t\t\t\tswitch (status) {\n\t\t\t\t\t\t\tcase ASYNC_ITERABLE_STATUS_YIELD:\n\t\t\t\t\t\t\t\tyield decode(data);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase ASYNC_ITERABLE_STATUS_RETURN: return decode(data);\n\t\t\t\t\t\t\tcase ASYNC_ITERABLE_STATUS_ERROR:\n\t\t\t\t\t\t\t\tvar _opts$formatError5, _opts$formatError6;\n\t\t\t\t\t\t\t\tthrow (_opts$formatError5 = (_opts$formatError6 = opts.formatError) === null || _opts$formatError6 === void 0 ? void 0 : _opts$formatError6.call(opts, { error: data })) !== null && _opts$formatError5 !== void 0 ? _opts$formatError5 : new AsyncError(data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (_) {\n\t\t\t\t\t_usingCtx4.e = _;\n\t\t\t\t} finally {\n\t\t\t\t\t_usingCtx4.d();\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t}\n\tfunction decode(value) {\n\t\tconst [[data], ...asyncProps] = value;\n\t\tfor (const value$1 of asyncProps) {\n\t\t\tconst [key] = value$1;\n\t\t\tconst decoded = decodeChunkDefinition(value$1);\n\t\t\tif (key === null) return decoded;\n\t\t\tdata[key] = decoded;\n\t\t}\n\t\treturn data;\n\t}\n\tconst closeOrAbort = (reason) => {\n\t\theadDeferred === null || headDeferred === void 0 || headDeferred.reject(reason);\n\t\tstreamManager.cancelAll(reason);\n\t};\n\tsource.pipeTo(new WritableStream({\n\t\twrite(chunkOrHead) {\n\t\t\tif (headDeferred) {\n\t\t\t\tconst head = chunkOrHead;\n\t\t\t\tfor (const [key, value] of Object.entries(chunkOrHead)) {\n\t\t\t\t\tconst parsed = decode(value);\n\t\t\t\t\thead[key] = parsed;\n\t\t\t\t}\n\t\t\t\theadDeferred.resolve(head);\n\t\t\t\theadDeferred = null;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst chunk = chunkOrHead;\n\t\t\tconst [idx] = chunk;\n\t\t\tconst controller = streamManager.getOrCreate(idx);\n\t\t\tcontroller.enqueue(chunk);\n\t\t},\n\t\tclose: closeOrAbort,\n\t\tabort: closeOrAbort\n\t})).catch((error) => {\n\t\tvar _opts$onError4;\n\t\t(_opts$onError4 = opts.onError) === null || _opts$onError4 === void 0 || _opts$onError4.call(opts, { error });\n\t\tcloseOrAbort(error);\n\t});\n\treturn [await headDeferred.promise];\n}\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/asyncGeneratorDelegate.js\nvar require_asyncGeneratorDelegate = __commonJS({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/asyncGeneratorDelegate.js\"(exports, module) {\n\tvar OverloadYield = require_OverloadYield();\n\tfunction _asyncGeneratorDelegate$1(t) {\n\t\tvar e = {}, n = !1;\n\t\tfunction pump(e$1, r) {\n\t\t\treturn n = !0, r = new Promise(function(n$1) {\n\t\t\t\tn$1(t[e$1](r));\n\t\t\t}), {\n\t\t\t\tdone: !1,\n\t\t\t\tvalue: new OverloadYield(r, 1)\n\t\t\t};\n\t\t}\n\t\treturn e[\"undefined\" != typeof Symbol && Symbol.iterator || \"@@iterator\"] = function() {\n\t\t\treturn this;\n\t\t}, e.next = function(t$1) {\n\t\t\treturn n ? (n = !1, t$1) : pump(\"next\", t$1);\n\t\t}, \"function\" == typeof t[\"throw\"] && (e[\"throw\"] = function(t$1) {\n\t\t\tif (n) throw n = !1, t$1;\n\t\t\treturn pump(\"throw\", t$1);\n\t\t}), \"function\" == typeof t[\"return\"] && (e[\"return\"] = function(t$1) {\n\t\t\treturn n ? (n = !1, t$1) : pump(\"return\", t$1);\n\t\t}), e;\n\t}\n\tmodule.exports = _asyncGeneratorDelegate$1, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n} });\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/sse.ts\nvar import_asyncIterator = __toESM(require_asyncIterator(), 1);\nvar import_awaitAsyncGenerator = __toESM(require_awaitAsyncGenerator(), 1);\nvar import_wrapAsyncGenerator$1 = __toESM(require_wrapAsyncGenerator(), 1);\nvar import_asyncGeneratorDelegate = __toESM(require_asyncGeneratorDelegate(), 1);\nvar import_usingCtx = __toESM(require_usingCtx(), 1);\nconst PING_EVENT = \"ping\";\nconst SERIALIZED_ERROR_EVENT = \"serialized-error\";\nconst CONNECTED_EVENT = \"connected\";\nconst RETURN_EVENT = \"return\";\n/**\n*\n* @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n*/\nfunction sseStreamProducer(opts) {\n\tvar _opts$ping$enabled, _opts$ping, _opts$ping$intervalMs, _opts$ping2, _opts$client;\n\tconst { serialize = identity } = opts;\n\tconst ping = {\n\t\tenabled: (_opts$ping$enabled = (_opts$ping = opts.ping) === null || _opts$ping === void 0 ? void 0 : _opts$ping.enabled) !== null && _opts$ping$enabled !== void 0 ? _opts$ping$enabled : false,\n\t\tintervalMs: (_opts$ping$intervalMs = (_opts$ping2 = opts.ping) === null || _opts$ping2 === void 0 ? void 0 : _opts$ping2.intervalMs) !== null && _opts$ping$intervalMs !== void 0 ? _opts$ping$intervalMs : 1e3\n\t};\n\tconst client = (_opts$client = opts.client) !== null && _opts$client !== void 0 ? _opts$client : {};\n\tif (ping.enabled && client.reconnectAfterInactivityMs && ping.intervalMs > client.reconnectAfterInactivityMs) throw new Error(`Ping interval must be less than client reconnect interval to prevent unnecessary reconnection - ping.intervalMs: ${ping.intervalMs} client.reconnectAfterInactivityMs: ${client.reconnectAfterInactivityMs}`);\n\tfunction generator() {\n\t\treturn _generator.apply(this, arguments);\n\t}\n\tfunction _generator() {\n\t\t_generator = (0, import_wrapAsyncGenerator$1.default)(function* () {\n\t\t\tyield {\n\t\t\t\tevent: CONNECTED_EVENT,\n\t\t\t\tdata: JSON.stringify(client)\n\t\t\t};\n\t\t\tlet iterable = opts.data;\n\t\t\tif (opts.emitAndEndImmediately) iterable = takeWithGrace(iterable, {\n\t\t\t\tcount: 1,\n\t\t\t\tgracePeriodMs: 1\n\t\t\t});\n\t\t\tif (ping.enabled && ping.intervalMs !== Infinity && ping.intervalMs > 0) iterable = withPing(iterable, ping.intervalMs);\n\t\t\tlet value;\n\t\t\tlet chunk;\n\t\t\tvar _iteratorAbruptCompletion = false;\n\t\t\tvar _didIteratorError = false;\n\t\t\tvar _iteratorError;\n\t\t\ttry {\n\t\t\t\tfor (var _iterator = (0, import_asyncIterator.default)(iterable), _step; _iteratorAbruptCompletion = !(_step = yield (0, import_awaitAsyncGenerator.default)(_iterator.next())).done; _iteratorAbruptCompletion = false) {\n\t\t\t\t\tvalue = _step.value;\n\t\t\t\t\t{\n\t\t\t\t\t\tif (value === PING_SYM) {\n\t\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\t\tevent: PING_EVENT,\n\t\t\t\t\t\t\t\tdata: \"\"\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchunk = isTrackedEnvelope(value) ? {\n\t\t\t\t\t\t\tid: value[0],\n\t\t\t\t\t\t\tdata: value[1]\n\t\t\t\t\t\t} : { data: value };\n\t\t\t\t\t\tchunk.data = JSON.stringify(serialize(chunk.data));\n\t\t\t\t\t\tyield chunk;\n\t\t\t\t\t\tvalue = null;\n\t\t\t\t\t\tchunk = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError = true;\n\t\t\t\t_iteratorError = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (_iteratorAbruptCompletion && _iterator.return != null) yield (0, import_awaitAsyncGenerator.default)(_iterator.return());\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError) throw _iteratorError;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn _generator.apply(this, arguments);\n\t}\n\tfunction generatorWithErrorHandling() {\n\t\treturn _generatorWithErrorHandling.apply(this, arguments);\n\t}\n\tfunction _generatorWithErrorHandling() {\n\t\t_generatorWithErrorHandling = (0, import_wrapAsyncGenerator$1.default)(function* () {\n\t\t\ttry {\n\t\t\t\tyield* (0, import_asyncGeneratorDelegate.default)((0, import_asyncIterator.default)(generator()));\n\t\t\t\tyield {\n\t\t\t\t\tevent: RETURN_EVENT,\n\t\t\t\t\tdata: \"\"\n\t\t\t\t};\n\t\t\t} catch (cause) {\n\t\t\t\tvar _opts$formatError, _opts$formatError2;\n\t\t\t\tif (isAbortError(cause)) return;\n\t\t\t\tconst error = getTRPCErrorFromUnknown(cause);\n\t\t\t\tconst data = (_opts$formatError = (_opts$formatError2 = opts.formatError) === null || _opts$formatError2 === void 0 ? void 0 : _opts$formatError2.call(opts, { error })) !== null && _opts$formatError !== void 0 ? _opts$formatError : null;\n\t\t\t\tyield {\n\t\t\t\t\tevent: SERIALIZED_ERROR_EVENT,\n\t\t\t\t\tdata: JSON.stringify(serialize(data))\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t\treturn _generatorWithErrorHandling.apply(this, arguments);\n\t}\n\tconst stream = readableStreamFrom(generatorWithErrorHandling());\n\treturn stream.pipeThrough(new TransformStream({ transform(chunk, controller) {\n\t\tif (\"event\" in chunk) controller.enqueue(`event: ${chunk.event}\\n`);\n\t\tif (\"data\" in chunk) controller.enqueue(`data: ${chunk.data}\\n`);\n\t\tif (\"id\" in chunk) controller.enqueue(`id: ${chunk.id}\\n`);\n\t\tif (\"comment\" in chunk) controller.enqueue(`: ${chunk.comment}\\n`);\n\t\tcontroller.enqueue(\"\\n\\n\");\n\t} })).pipeThrough(new TextEncoderStream());\n}\nasync function withTimeout(opts) {\n\ttry {\n\t\tvar _usingCtx$1 = (0, import_usingCtx.default)();\n\t\tconst timeoutPromise = _usingCtx$1.u(timerResource(opts.timeoutMs));\n\t\tconst res = await Unpromise.race([opts.promise, timeoutPromise.start()]);\n\t\tif (res === disposablePromiseTimerResult) return await opts.onTimeout();\n\t\treturn res;\n\t} catch (_) {\n\t\t_usingCtx$1.e = _;\n\t} finally {\n\t\t_usingCtx$1.d();\n\t}\n}\n/**\n* @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n*/\nfunction sseStreamConsumer(opts) {\n\tconst { deserialize = (v) => v } = opts;\n\tlet clientOptions = emptyObject();\n\tconst signal = opts.signal;\n\tlet _es = null;\n\tconst createStream = () => new ReadableStream({\n\t\tasync start(controller) {\n\t\t\tconst [url, init] = await Promise.all([opts.url(), opts.init()]);\n\t\t\tconst eventSource = _es = new opts.EventSource(url, init);\n\t\t\tcontroller.enqueue({\n\t\t\t\ttype: \"connecting\",\n\t\t\t\teventSource: _es,\n\t\t\t\tevent: null\n\t\t\t});\n\t\t\teventSource.addEventListener(CONNECTED_EVENT, (_msg) => {\n\t\t\t\tconst msg = _msg;\n\t\t\t\tconst options = JSON.parse(msg.data);\n\t\t\t\tclientOptions = options;\n\t\t\t\tcontroller.enqueue({\n\t\t\t\t\ttype: \"connected\",\n\t\t\t\t\toptions,\n\t\t\t\t\teventSource\n\t\t\t\t});\n\t\t\t});\n\t\t\teventSource.addEventListener(SERIALIZED_ERROR_EVENT, (_msg) => {\n\t\t\t\tconst msg = _msg;\n\t\t\t\tcontroller.enqueue({\n\t\t\t\t\ttype: \"serialized-error\",\n\t\t\t\t\terror: deserialize(JSON.parse(msg.data)),\n\t\t\t\t\teventSource\n\t\t\t\t});\n\t\t\t});\n\t\t\teventSource.addEventListener(PING_EVENT, () => {\n\t\t\t\tcontroller.enqueue({\n\t\t\t\t\ttype: \"ping\",\n\t\t\t\t\teventSource\n\t\t\t\t});\n\t\t\t});\n\t\t\teventSource.addEventListener(RETURN_EVENT, () => {\n\t\t\t\teventSource.close();\n\t\t\t\tcontroller.close();\n\t\t\t\t_es = null;\n\t\t\t});\n\t\t\teventSource.addEventListener(\"error\", (event) => {\n\t\t\t\tif (eventSource.readyState === eventSource.CLOSED) controller.error(event);\n\t\t\t\telse controller.enqueue({\n\t\t\t\t\ttype: \"connecting\",\n\t\t\t\t\teventSource,\n\t\t\t\t\tevent\n\t\t\t\t});\n\t\t\t});\n\t\t\teventSource.addEventListener(\"message\", (_msg) => {\n\t\t\t\tconst msg = _msg;\n\t\t\t\tconst chunk = deserialize(JSON.parse(msg.data));\n\t\t\t\tconst def = { data: chunk };\n\t\t\t\tif (msg.lastEventId) def.id = msg.lastEventId;\n\t\t\t\tcontroller.enqueue({\n\t\t\t\t\ttype: \"data\",\n\t\t\t\t\tdata: def,\n\t\t\t\t\teventSource\n\t\t\t\t});\n\t\t\t});\n\t\t\tconst onAbort = () => {\n\t\t\t\ttry {\n\t\t\t\t\teventSource.close();\n\t\t\t\t\tcontroller.close();\n\t\t\t\t} catch (_unused) {}\n\t\t\t};\n\t\t\tif (signal.aborted) onAbort();\n\t\t\telse signal.addEventListener(\"abort\", onAbort);\n\t\t},\n\t\tcancel() {\n\t\t\t_es === null || _es === void 0 || _es.close();\n\t\t}\n\t});\n\tconst getStreamResource = () => {\n\t\tlet stream = createStream();\n\t\tlet reader = stream.getReader();\n\t\tasync function dispose() {\n\t\t\tawait reader.cancel();\n\t\t\t_es = null;\n\t\t}\n\t\treturn makeAsyncResource({\n\t\t\tread() {\n\t\t\t\treturn reader.read();\n\t\t\t},\n\t\t\tasync recreate() {\n\t\t\t\tawait dispose();\n\t\t\t\tstream = createStream();\n\t\t\t\treader = stream.getReader();\n\t\t\t}\n\t\t}, dispose);\n\t};\n\treturn run((0, import_wrapAsyncGenerator$1.default)(function* () {\n\t\ttry {\n\t\t\tvar _usingCtx3 = (0, import_usingCtx.default)();\n\t\t\tconst stream = _usingCtx3.a(getStreamResource());\n\t\t\twhile (true) {\n\t\t\t\tlet promise = stream.read();\n\t\t\t\tconst timeoutMs = clientOptions.reconnectAfterInactivityMs;\n\t\t\t\tif (timeoutMs) promise = withTimeout({\n\t\t\t\t\tpromise,\n\t\t\t\t\ttimeoutMs,\n\t\t\t\t\tonTimeout: async () => {\n\t\t\t\t\t\tconst res = {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"timeout\",\n\t\t\t\t\t\t\t\tms: timeoutMs,\n\t\t\t\t\t\t\t\teventSource: _es\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdone: false\n\t\t\t\t\t\t};\n\t\t\t\t\t\tawait stream.recreate();\n\t\t\t\t\t\treturn res;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tconst result = yield (0, import_awaitAsyncGenerator.default)(promise);\n\t\t\t\tif (result.done) return result.value;\n\t\t\t\tyield result.value;\n\t\t\t}\n\t\t} catch (_) {\n\t\t\t_usingCtx3.e = _;\n\t\t} finally {\n\t\t\tyield (0, import_awaitAsyncGenerator.default)(_usingCtx3.d());\n\t\t}\n\t}));\n}\nconst sseHeaders = {\n\t\"Content-Type\": \"text/event-stream\",\n\t\"Cache-Control\": \"no-cache, no-transform\",\n\t\"X-Accel-Buffering\": \"no\",\n\tConnection: \"keep-alive\"\n};\n\n//#endregion\n//#region src/unstable-core-do-not-import/http/resolveResponse.ts\nvar import_wrapAsyncGenerator = __toESM(require_wrapAsyncGenerator(), 1);\nvar import_objectSpread2 = __toESM(require_objectSpread2(), 1);\nfunction errorToAsyncIterable(err) {\n\treturn run((0, import_wrapAsyncGenerator.default)(function* () {\n\t\tthrow err;\n\t}));\n}\nfunction combinedAbortController(signal) {\n\tconst controller = new AbortController();\n\tconst combinedSignal = abortSignalsAnyPonyfill([signal, controller.signal]);\n\treturn {\n\t\tsignal: combinedSignal,\n\t\tcontroller\n\t};\n}\nconst TYPE_ACCEPTED_METHOD_MAP = {\n\tmutation: [\"POST\"],\n\tquery: [\"GET\"],\n\tsubscription: [\"GET\"]\n};\nconst TYPE_ACCEPTED_METHOD_MAP_WITH_METHOD_OVERRIDE = {\n\tmutation: [\"POST\"],\n\tquery: [\"GET\", \"POST\"],\n\tsubscription: [\"GET\", \"POST\"]\n};\nfunction initResponse(initOpts) {\n\tvar _responseMeta, _info$calls$find$proc, _info$calls$find;\n\tconst { ctx, info, responseMeta, untransformedJSON, errors = [], headers } = initOpts;\n\tlet status = untransformedJSON ? getHTTPStatusCode(untransformedJSON) : 200;\n\tconst eagerGeneration = !untransformedJSON;\n\tconst data = eagerGeneration ? [] : Array.isArray(untransformedJSON) ? untransformedJSON : [untransformedJSON];\n\tconst meta = (_responseMeta = responseMeta === null || responseMeta === void 0 ? void 0 : responseMeta({\n\t\tctx,\n\t\tinfo,\n\t\tpaths: info === null || info === void 0 ? void 0 : info.calls.map((call) => call.path),\n\t\tdata,\n\t\terrors,\n\t\teagerGeneration,\n\t\ttype: (_info$calls$find$proc = info === null || info === void 0 || (_info$calls$find = info.calls.find((call) => {\n\t\t\tvar _call$procedure;\n\t\t\treturn (_call$procedure = call.procedure) === null || _call$procedure === void 0 ? void 0 : _call$procedure._def.type;\n\t\t})) === null || _info$calls$find === void 0 || (_info$calls$find = _info$calls$find.procedure) === null || _info$calls$find === void 0 ? void 0 : _info$calls$find._def.type) !== null && _info$calls$find$proc !== void 0 ? _info$calls$find$proc : \"unknown\"\n\t})) !== null && _responseMeta !== void 0 ? _responseMeta : {};\n\tif (meta.headers) {\n\t\tif (meta.headers instanceof Headers) for (const [key, value] of meta.headers.entries()) headers.append(key, value);\n\t\telse\n /**\n\t\t* @deprecated, delete in v12\n\t\t*/\n\t\tfor (const [key, value] of Object.entries(meta.headers)) if (Array.isArray(value)) for (const v of value) headers.append(key, v);\n\t\telse if (typeof value === \"string\") headers.set(key, value);\n\t}\n\tif (meta.status) status = meta.status;\n\treturn { status };\n}\nfunction caughtErrorToData(cause, errorOpts) {\n\tconst { router, req, onError } = errorOpts.opts;\n\tconst error = getTRPCErrorFromUnknown(cause);\n\tonError === null || onError === void 0 || onError({\n\t\terror,\n\t\tpath: errorOpts.path,\n\t\tinput: errorOpts.input,\n\t\tctx: errorOpts.ctx,\n\t\ttype: errorOpts.type,\n\t\treq\n\t});\n\tconst untransformedJSON = { error: getErrorShape({\n\t\tconfig: router._def._config,\n\t\terror,\n\t\ttype: errorOpts.type,\n\t\tpath: errorOpts.path,\n\t\tinput: errorOpts.input,\n\t\tctx: errorOpts.ctx\n\t}) };\n\tconst transformedJSON = transformTRPCResponse(router._def._config, untransformedJSON);\n\tconst body = JSON.stringify(transformedJSON);\n\treturn {\n\t\terror,\n\t\tuntransformedJSON,\n\t\tbody\n\t};\n}\n/**\n* Check if a value is a stream-like object\n* - if it's an async iterable\n* - if it's an object with async iterables or promises\n*/\nfunction isDataStream(v) {\n\tif (!isObject(v)) return false;\n\tif (isAsyncIterable(v)) return true;\n\treturn Object.values(v).some(isPromise) || Object.values(v).some(isAsyncIterable);\n}\nasync function resolveResponse(opts) {\n\tvar _ref, _opts$allowBatching, _opts$batching, _opts$allowMethodOver, _config$sse$enabled, _config$sse;\n\tconst { router, req } = opts;\n\tconst headers = new Headers([[\"vary\", \"trpc-accept\"]]);\n\tconst config = router._def._config;\n\tconst url = new URL(req.url);\n\tif (req.method === \"HEAD\") return new Response(null, { status: 204 });\n\tconst allowBatching = (_ref = (_opts$allowBatching = opts.allowBatching) !== null && _opts$allowBatching !== void 0 ? _opts$allowBatching : (_opts$batching = opts.batching) === null || _opts$batching === void 0 ? void 0 : _opts$batching.enabled) !== null && _ref !== void 0 ? _ref : true;\n\tconst allowMethodOverride = ((_opts$allowMethodOver = opts.allowMethodOverride) !== null && _opts$allowMethodOver !== void 0 ? _opts$allowMethodOver : false) && req.method === \"POST\";\n\tconst infoTuple = await run(async () => {\n\t\ttry {\n\t\t\treturn [void 0, await getRequestInfo({\n\t\t\t\treq,\n\t\t\t\tpath: decodeURIComponent(opts.path),\n\t\t\t\trouter,\n\t\t\t\tsearchParams: url.searchParams,\n\t\t\t\theaders: opts.req.headers,\n\t\t\t\turl\n\t\t\t})];\n\t\t} catch (cause) {\n\t\t\treturn [getTRPCErrorFromUnknown(cause), void 0];\n\t\t}\n\t});\n\tconst ctxManager = run(() => {\n\t\tlet result = void 0;\n\t\treturn {\n\t\t\tvalueOrUndefined: () => {\n\t\t\t\tif (!result) return void 0;\n\t\t\t\treturn result[1];\n\t\t\t},\n\t\t\tvalue: () => {\n\t\t\t\tconst [err, ctx] = result;\n\t\t\t\tif (err) throw err;\n\t\t\t\treturn ctx;\n\t\t\t},\n\t\t\tcreate: async (info) => {\n\t\t\t\tif (result) throw new Error(\"This should only be called once - report a bug in tRPC\");\n\t\t\t\ttry {\n\t\t\t\t\tconst ctx = await opts.createContext({ info });\n\t\t\t\t\tresult = [void 0, ctx];\n\t\t\t\t} catch (cause) {\n\t\t\t\t\tresult = [getTRPCErrorFromUnknown(cause), void 0];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t});\n\tconst methodMapper = allowMethodOverride ? TYPE_ACCEPTED_METHOD_MAP_WITH_METHOD_OVERRIDE : TYPE_ACCEPTED_METHOD_MAP;\n\t/**\n\t* @deprecated\n\t*/\n\tconst isStreamCall = req.headers.get(\"trpc-accept\") === \"application/jsonl\";\n\tconst experimentalSSE = (_config$sse$enabled = (_config$sse = config.sse) === null || _config$sse === void 0 ? void 0 : _config$sse.enabled) !== null && _config$sse$enabled !== void 0 ? _config$sse$enabled : true;\n\ttry {\n\t\tconst [infoError, info] = infoTuple;\n\t\tif (infoError) throw infoError;\n\t\tif (info.isBatchCall && !allowBatching) throw new TRPCError({\n\t\t\tcode: \"BAD_REQUEST\",\n\t\t\tmessage: `Batching is not enabled on the server`\n\t\t});\n\t\t/* istanbul ignore if -- @preserve */\n\t\tif (isStreamCall && !info.isBatchCall) throw new TRPCError({\n\t\t\tmessage: `Streaming requests must be batched (you can do a batch of 1)`,\n\t\t\tcode: \"BAD_REQUEST\"\n\t\t});\n\t\tawait ctxManager.create(info);\n\t\tconst rpcCalls = info.calls.map(async (call) => {\n\t\t\tconst proc = call.procedure;\n\t\t\tconst combinedAbort = combinedAbortController(opts.req.signal);\n\t\t\ttry {\n\t\t\t\tif (opts.error) throw opts.error;\n\t\t\t\tif (!proc) throw new TRPCError({\n\t\t\t\t\tcode: \"NOT_FOUND\",\n\t\t\t\t\tmessage: `No procedure found on path \"${call.path}\"`\n\t\t\t\t});\n\t\t\t\tif (!methodMapper[proc._def.type].includes(req.method)) throw new TRPCError({\n\t\t\t\t\tcode: \"METHOD_NOT_SUPPORTED\",\n\t\t\t\t\tmessage: `Unsupported ${req.method}-request to ${proc._def.type} procedure at path \"${call.path}\"`\n\t\t\t\t});\n\t\t\t\tif (proc._def.type === \"subscription\") {\n\t\t\t\t\tvar _config$sse2;\n\t\t\t\t\t/* istanbul ignore if -- @preserve */\n\t\t\t\t\tif (info.isBatchCall) throw new TRPCError({\n\t\t\t\t\t\tcode: \"BAD_REQUEST\",\n\t\t\t\t\t\tmessage: `Cannot batch subscription calls`\n\t\t\t\t\t});\n\t\t\t\t\tif ((_config$sse2 = config.sse) === null || _config$sse2 === void 0 ? void 0 : _config$sse2.maxDurationMs) {\n\t\t\t\t\t\tfunction cleanup() {\n\t\t\t\t\t\t\tclearTimeout(timer);\n\t\t\t\t\t\t\tcombinedAbort.signal.removeEventListener(\"abort\", cleanup);\n\t\t\t\t\t\t\tcombinedAbort.controller.abort();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst timer = setTimeout(cleanup, config.sse.maxDurationMs);\n\t\t\t\t\t\tcombinedAbort.signal.addEventListener(\"abort\", cleanup);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst data = await proc({\n\t\t\t\t\tpath: call.path,\n\t\t\t\t\tgetRawInput: call.getRawInput,\n\t\t\t\t\tctx: ctxManager.value(),\n\t\t\t\t\ttype: proc._def.type,\n\t\t\t\t\tsignal: combinedAbort.signal\n\t\t\t\t});\n\t\t\t\treturn [void 0, { data }];\n\t\t\t} catch (cause) {\n\t\t\t\tvar _opts$onError, _call$procedure$_def$, _call$procedure2;\n\t\t\t\tconst error = getTRPCErrorFromUnknown(cause);\n\t\t\t\tconst input = call.result();\n\t\t\t\t(_opts$onError = opts.onError) === null || _opts$onError === void 0 || _opts$onError.call(opts, {\n\t\t\t\t\terror,\n\t\t\t\t\tpath: call.path,\n\t\t\t\t\tinput,\n\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\ttype: (_call$procedure$_def$ = (_call$procedure2 = call.procedure) === null || _call$procedure2 === void 0 ? void 0 : _call$procedure2._def.type) !== null && _call$procedure$_def$ !== void 0 ? _call$procedure$_def$ : \"unknown\",\n\t\t\t\t\treq: opts.req\n\t\t\t\t});\n\t\t\t\treturn [error, void 0];\n\t\t\t}\n\t\t});\n\t\tif (!info.isBatchCall) {\n\t\t\tconst [call] = info.calls;\n\t\t\tconst [error, result] = await rpcCalls[0];\n\t\t\tswitch (info.type) {\n\t\t\t\tcase \"unknown\":\n\t\t\t\tcase \"mutation\":\n\t\t\t\tcase \"query\": {\n\t\t\t\t\theaders.set(\"content-type\", \"application/json\");\n\t\t\t\t\tif (isDataStream(result === null || result === void 0 ? void 0 : result.data)) throw new TRPCError({\n\t\t\t\t\t\tcode: \"UNSUPPORTED_MEDIA_TYPE\",\n\t\t\t\t\t\tmessage: \"Cannot use stream-like response in non-streaming request - use httpBatchStreamLink\"\n\t\t\t\t\t});\n\t\t\t\t\tconst res = error ? { error: getErrorShape({\n\t\t\t\t\t\tconfig,\n\t\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\t\terror,\n\t\t\t\t\t\tinput: call.result(),\n\t\t\t\t\t\tpath: call.path,\n\t\t\t\t\t\ttype: info.type\n\t\t\t\t\t}) } : { result: { data: result.data } };\n\t\t\t\t\tconst headResponse$1 = initResponse({\n\t\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\t\tinfo,\n\t\t\t\t\t\tresponseMeta: opts.responseMeta,\n\t\t\t\t\t\terrors: error ? [error] : [],\n\t\t\t\t\t\theaders,\n\t\t\t\t\t\tuntransformedJSON: [res]\n\t\t\t\t\t});\n\t\t\t\t\treturn new Response(JSON.stringify(transformTRPCResponse(config, res)), {\n\t\t\t\t\t\tstatus: headResponse$1.status,\n\t\t\t\t\t\theaders\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tcase \"subscription\": {\n\t\t\t\t\tconst iterable = run(() => {\n\t\t\t\t\t\tif (error) return errorToAsyncIterable(error);\n\t\t\t\t\t\tif (!experimentalSSE) return errorToAsyncIterable(new TRPCError({\n\t\t\t\t\t\t\tcode: \"METHOD_NOT_SUPPORTED\",\n\t\t\t\t\t\t\tmessage: \"Missing experimental flag \\\"sseSubscriptions\\\"\"\n\t\t\t\t\t\t}));\n\t\t\t\t\t\tif (!isObservable(result.data) && !isAsyncIterable(result.data)) return errorToAsyncIterable(new TRPCError({\n\t\t\t\t\t\t\tmessage: `Subscription ${call.path} did not return an observable or a AsyncGenerator`,\n\t\t\t\t\t\t\tcode: \"INTERNAL_SERVER_ERROR\"\n\t\t\t\t\t\t}));\n\t\t\t\t\t\tconst dataAsIterable = isObservable(result.data) ? observableToAsyncIterable(result.data, opts.req.signal) : result.data;\n\t\t\t\t\t\treturn dataAsIterable;\n\t\t\t\t\t});\n\t\t\t\t\tconst stream = sseStreamProducer((0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, config.sse), {}, {\n\t\t\t\t\t\tdata: iterable,\n\t\t\t\t\t\tserialize: (v) => config.transformer.output.serialize(v),\n\t\t\t\t\t\tformatError(errorOpts) {\n\t\t\t\t\t\t\tvar _call$procedure$_def$2, _call$procedure3, _opts$onError2;\n\t\t\t\t\t\t\tconst error$1 = getTRPCErrorFromUnknown(errorOpts.error);\n\t\t\t\t\t\t\tconst input = call === null || call === void 0 ? void 0 : call.result();\n\t\t\t\t\t\t\tconst path = call === null || call === void 0 ? void 0 : call.path;\n\t\t\t\t\t\t\tconst type = (_call$procedure$_def$2 = call === null || call === void 0 || (_call$procedure3 = call.procedure) === null || _call$procedure3 === void 0 ? void 0 : _call$procedure3._def.type) !== null && _call$procedure$_def$2 !== void 0 ? _call$procedure$_def$2 : \"unknown\";\n\t\t\t\t\t\t\t(_opts$onError2 = opts.onError) === null || _opts$onError2 === void 0 || _opts$onError2.call(opts, {\n\t\t\t\t\t\t\t\terror: error$1,\n\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\t\t\t\treq: opts.req,\n\t\t\t\t\t\t\t\ttype\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tconst shape = getErrorShape({\n\t\t\t\t\t\t\t\tconfig,\n\t\t\t\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\t\t\t\terror: error$1,\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\ttype\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\treturn shape;\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t\t\t\tfor (const [key, value] of Object.entries(sseHeaders)) headers.set(key, value);\n\t\t\t\t\tconst headResponse$1 = initResponse({\n\t\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\t\tinfo,\n\t\t\t\t\t\tresponseMeta: opts.responseMeta,\n\t\t\t\t\t\terrors: [],\n\t\t\t\t\t\theaders,\n\t\t\t\t\t\tuntransformedJSON: null\n\t\t\t\t\t});\n\t\t\t\t\treturn new Response(stream, {\n\t\t\t\t\t\theaders,\n\t\t\t\t\t\tstatus: headResponse$1.status\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (info.accept === \"application/jsonl\") {\n\t\t\theaders.set(\"content-type\", \"application/json\");\n\t\t\theaders.set(\"transfer-encoding\", \"chunked\");\n\t\t\tconst headResponse$1 = initResponse({\n\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\tinfo,\n\t\t\t\tresponseMeta: opts.responseMeta,\n\t\t\t\terrors: [],\n\t\t\t\theaders,\n\t\t\t\tuntransformedJSON: null\n\t\t\t});\n\t\t\tconst stream = jsonlStreamProducer((0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, config.jsonl), {}, {\n\t\t\t\tmaxDepth: Infinity,\n\t\t\t\tdata: rpcCalls.map(async (res) => {\n\t\t\t\t\tconst [error, result] = await res;\n\t\t\t\t\tconst call = info.calls[0];\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tvar _procedure$_def$type, _procedure;\n\t\t\t\t\t\treturn { error: getErrorShape({\n\t\t\t\t\t\t\tconfig,\n\t\t\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\t\t\terror,\n\t\t\t\t\t\t\tinput: call.result(),\n\t\t\t\t\t\t\tpath: call.path,\n\t\t\t\t\t\t\ttype: (_procedure$_def$type = (_procedure = call.procedure) === null || _procedure === void 0 ? void 0 : _procedure._def.type) !== null && _procedure$_def$type !== void 0 ? _procedure$_def$type : \"unknown\"\n\t\t\t\t\t\t}) };\n\t\t\t\t\t}\n\t\t\t\t\t/**\n\t\t\t\t\t* Not very pretty, but we need to wrap nested data in promises\n\t\t\t\t\t* Our stream producer will only resolve top-level async values or async values that are directly nested in another async value\n\t\t\t\t\t*/\n\t\t\t\t\tconst iterable = isObservable(result.data) ? observableToAsyncIterable(result.data, opts.req.signal) : Promise.resolve(result.data);\n\t\t\t\t\treturn { result: Promise.resolve({ data: iterable }) };\n\t\t\t\t}),\n\t\t\t\tserialize: (data) => config.transformer.output.serialize(data),\n\t\t\t\tonError: (cause) => {\n\t\t\t\t\tvar _opts$onError3, _info$type;\n\t\t\t\t\t(_opts$onError3 = opts.onError) === null || _opts$onError3 === void 0 || _opts$onError3.call(opts, {\n\t\t\t\t\t\terror: getTRPCErrorFromUnknown(cause),\n\t\t\t\t\t\tpath: void 0,\n\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\t\treq: opts.req,\n\t\t\t\t\t\ttype: (_info$type = info === null || info === void 0 ? void 0 : info.type) !== null && _info$type !== void 0 ? _info$type : \"unknown\"\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tformatError(errorOpts) {\n\t\t\t\t\tvar _call$procedure$_def$3, _call$procedure4;\n\t\t\t\t\tconst call = info === null || info === void 0 ? void 0 : info.calls[errorOpts.path[0]];\n\t\t\t\t\tconst error = getTRPCErrorFromUnknown(errorOpts.error);\n\t\t\t\t\tconst input = call === null || call === void 0 ? void 0 : call.result();\n\t\t\t\t\tconst path = call === null || call === void 0 ? void 0 : call.path;\n\t\t\t\t\tconst type = (_call$procedure$_def$3 = call === null || call === void 0 || (_call$procedure4 = call.procedure) === null || _call$procedure4 === void 0 ? void 0 : _call$procedure4._def.type) !== null && _call$procedure$_def$3 !== void 0 ? _call$procedure$_def$3 : \"unknown\";\n\t\t\t\t\tconst shape = getErrorShape({\n\t\t\t\t\t\tconfig,\n\t\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\t\terror,\n\t\t\t\t\t\tinput,\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\ttype\n\t\t\t\t\t});\n\t\t\t\t\treturn shape;\n\t\t\t\t}\n\t\t\t}));\n\t\t\treturn new Response(stream, {\n\t\t\t\theaders,\n\t\t\t\tstatus: headResponse$1.status\n\t\t\t});\n\t\t}\n\t\t/**\n\t\t* Non-streaming response:\n\t\t* - await all responses in parallel, blocking on the slowest one\n\t\t* - create headers with known response body\n\t\t* - return a complete HTTPResponse\n\t\t*/\n\t\theaders.set(\"content-type\", \"application/json\");\n\t\tconst results = (await Promise.all(rpcCalls)).map((res) => {\n\t\t\tconst [error, result] = res;\n\t\t\tif (error) return res;\n\t\t\tif (isDataStream(result.data)) return [new TRPCError({\n\t\t\t\tcode: \"UNSUPPORTED_MEDIA_TYPE\",\n\t\t\t\tmessage: \"Cannot use stream-like response in non-streaming request - use httpBatchStreamLink\"\n\t\t\t}), void 0];\n\t\t\treturn res;\n\t\t});\n\t\tconst resultAsRPCResponse = results.map(([error, result], index) => {\n\t\t\tconst call = info.calls[index];\n\t\t\tif (error) {\n\t\t\t\tvar _call$procedure$_def$4, _call$procedure5;\n\t\t\t\treturn { error: getErrorShape({\n\t\t\t\t\tconfig,\n\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\terror,\n\t\t\t\t\tinput: call.result(),\n\t\t\t\t\tpath: call.path,\n\t\t\t\t\ttype: (_call$procedure$_def$4 = (_call$procedure5 = call.procedure) === null || _call$procedure5 === void 0 ? void 0 : _call$procedure5._def.type) !== null && _call$procedure$_def$4 !== void 0 ? _call$procedure$_def$4 : \"unknown\"\n\t\t\t\t}) };\n\t\t\t}\n\t\t\treturn { result: { data: result.data } };\n\t\t});\n\t\tconst errors = results.map(([error]) => error).filter(Boolean);\n\t\tconst headResponse = initResponse({\n\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\tinfo,\n\t\t\tresponseMeta: opts.responseMeta,\n\t\t\tuntransformedJSON: resultAsRPCResponse,\n\t\t\terrors,\n\t\t\theaders\n\t\t});\n\t\treturn new Response(JSON.stringify(transformTRPCResponse(config, resultAsRPCResponse)), {\n\t\t\tstatus: headResponse.status,\n\t\t\theaders\n\t\t});\n\t} catch (cause) {\n\t\tvar _info$type2;\n\t\tconst [_infoError, info] = infoTuple;\n\t\tconst ctx = ctxManager.valueOrUndefined();\n\t\tconst { error, untransformedJSON, body } = caughtErrorToData(cause, {\n\t\t\topts,\n\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\ttype: (_info$type2 = info === null || info === void 0 ? void 0 : info.type) !== null && _info$type2 !== void 0 ? _info$type2 : \"unknown\"\n\t\t});\n\t\tconst headResponse = initResponse({\n\t\t\tctx,\n\t\t\tinfo,\n\t\t\tresponseMeta: opts.responseMeta,\n\t\t\tuntransformedJSON,\n\t\t\terrors: [error],\n\t\t\theaders\n\t\t});\n\t\treturn new Response(body, {\n\t\t\tstatus: headResponse.status,\n\t\t\theaders\n\t\t});\n\t}\n}\n\n//#endregion\nexport { Unpromise, createDeferred, getRequestInfo, isAbortError, isPromise, iteratorResource, jsonlStreamConsumer, jsonlStreamProducer, makeAsyncResource, makeResource, parseConnectionParamsFromString, parseConnectionParamsFromUnknown, require_usingCtx, resolveResponse, sseHeaders, sseStreamConsumer, sseStreamProducer, takeWithGrace, throwAbortError };\n//# sourceMappingURL=resolveResponse-C7AcnFLN.mjs.map","import { __toESM, require_defineProperty, require_objectSpread2 } from \"./objectSpread2-BvkFp-_Y.mjs\";\nimport { isObject } from \"@trpc/server/unstable-core-do-not-import\";\n\n//#region src/TRPCClientError.ts\nvar import_defineProperty = __toESM(require_defineProperty(), 1);\nvar import_objectSpread2 = __toESM(require_objectSpread2(), 1);\nfunction isTRPCClientError(cause) {\n\treturn cause instanceof TRPCClientError;\n}\nfunction isTRPCErrorResponse(obj) {\n\treturn isObject(obj) && isObject(obj[\"error\"]) && typeof obj[\"error\"][\"code\"] === \"number\" && typeof obj[\"error\"][\"message\"] === \"string\";\n}\nfunction getMessageFromUnknownError(err, fallback) {\n\tif (typeof err === \"string\") return err;\n\tif (isObject(err) && typeof err[\"message\"] === \"string\") return err[\"message\"];\n\treturn fallback;\n}\nvar TRPCClientError = class TRPCClientError extends Error {\n\tconstructor(message, opts) {\n\t\tvar _opts$result, _opts$result2;\n\t\tconst cause = opts === null || opts === void 0 ? void 0 : opts.cause;\n\t\tsuper(message, { cause });\n\t\t(0, import_defineProperty.default)(this, \"cause\", void 0);\n\t\t(0, import_defineProperty.default)(this, \"shape\", void 0);\n\t\t(0, import_defineProperty.default)(this, \"data\", void 0);\n\t\t(0, import_defineProperty.default)(this, \"meta\", void 0);\n\t\tthis.meta = opts === null || opts === void 0 ? void 0 : opts.meta;\n\t\tthis.cause = cause;\n\t\tthis.shape = opts === null || opts === void 0 || (_opts$result = opts.result) === null || _opts$result === void 0 ? void 0 : _opts$result.error;\n\t\tthis.data = opts === null || opts === void 0 || (_opts$result2 = opts.result) === null || _opts$result2 === void 0 ? void 0 : _opts$result2.error.data;\n\t\tthis.name = \"TRPCClientError\";\n\t\tObject.setPrototypeOf(this, TRPCClientError.prototype);\n\t}\n\tstatic from(_cause, opts = {}) {\n\t\tconst cause = _cause;\n\t\tif (isTRPCClientError(cause)) {\n\t\t\tif (opts.meta) cause.meta = (0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, cause.meta), opts.meta);\n\t\t\treturn cause;\n\t\t}\n\t\tif (isTRPCErrorResponse(cause)) return new TRPCClientError(cause.error.message, (0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, opts), {}, { result: cause }));\n\t\treturn new TRPCClientError(getMessageFromUnknownError(cause, \"Unknown error\"), (0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, opts), {}, { cause }));\n\t}\n};\n\n//#endregion\nexport { TRPCClientError, isTRPCClientError };\n//# sourceMappingURL=TRPCClientError-CjKyS10w.mjs.map","//#region src/internals/transformer.ts\n/**\n* @internal\n*/\n/**\n* @internal\n*/\nfunction getTransformer(transformer) {\n\tconst _transformer = transformer;\n\tif (!_transformer) return {\n\t\tinput: {\n\t\t\tserialize: (data) => data,\n\t\t\tdeserialize: (data) => data\n\t\t},\n\t\toutput: {\n\t\t\tserialize: (data) => data,\n\t\t\tdeserialize: (data) => data\n\t\t}\n\t};\n\tif (\"input\" in _transformer) return _transformer;\n\treturn {\n\t\tinput: _transformer,\n\t\toutput: _transformer\n\t};\n}\n\n//#endregion\nexport { getTransformer };\n//# sourceMappingURL=unstable-internals-Bg7n9BBj.mjs.map","import { __toESM, require_objectSpread2 } from \"./objectSpread2-BvkFp-_Y.mjs\";\nimport { getTransformer } from \"./unstable-internals-Bg7n9BBj.mjs\";\n\n//#region src/getFetch.ts\nconst isFunction = (fn) => typeof fn === \"function\";\nfunction getFetch(customFetchImpl) {\n\tif (customFetchImpl) return customFetchImpl;\n\tif (typeof window !== \"undefined\" && isFunction(window.fetch)) return window.fetch;\n\tif (typeof globalThis !== \"undefined\" && isFunction(globalThis.fetch)) return globalThis.fetch;\n\tthrow new Error(\"No fetch implementation found\");\n}\n\n//#endregion\n//#region src/links/internals/httpUtils.ts\nvar import_objectSpread2 = __toESM(require_objectSpread2(), 1);\nfunction resolveHTTPLinkOptions(opts) {\n\treturn {\n\t\turl: opts.url.toString(),\n\t\tfetch: opts.fetch,\n\t\ttransformer: getTransformer(opts.transformer),\n\t\tmethodOverride: opts.methodOverride\n\t};\n}\nfunction arrayToDict(array) {\n\tconst dict = {};\n\tfor (let index = 0; index < array.length; index++) {\n\t\tconst element = array[index];\n\t\tdict[index] = element;\n\t}\n\treturn dict;\n}\nconst METHOD = {\n\tquery: \"GET\",\n\tmutation: \"POST\",\n\tsubscription: \"PATCH\"\n};\nfunction getInput(opts) {\n\treturn \"input\" in opts ? opts.transformer.input.serialize(opts.input) : arrayToDict(opts.inputs.map((_input) => opts.transformer.input.serialize(_input)));\n}\nconst getUrl = (opts) => {\n\tconst parts = opts.url.split(\"?\");\n\tconst base = parts[0].replace(/\\/$/, \"\");\n\tlet url = base + \"/\" + opts.path;\n\tconst queryParts = [];\n\tif (parts[1]) queryParts.push(parts[1]);\n\tif (\"inputs\" in opts) queryParts.push(\"batch=1\");\n\tif (opts.type === \"query\" || opts.type === \"subscription\") {\n\t\tconst input = getInput(opts);\n\t\tif (input !== void 0 && opts.methodOverride !== \"POST\") queryParts.push(`input=${encodeURIComponent(JSON.stringify(input))}`);\n\t}\n\tif (queryParts.length) url += \"?\" + queryParts.join(\"&\");\n\treturn url;\n};\nconst getBody = (opts) => {\n\tif (opts.type === \"query\" && opts.methodOverride !== \"POST\") return void 0;\n\tconst input = getInput(opts);\n\treturn input !== void 0 ? JSON.stringify(input) : void 0;\n};\nconst jsonHttpRequester = (opts) => {\n\treturn httpRequest((0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, opts), {}, {\n\t\tcontentTypeHeader: \"application/json\",\n\t\tgetUrl,\n\t\tgetBody\n\t}));\n};\n/**\n* Polyfill for DOMException with AbortError name\n*/\nvar AbortError = class extends Error {\n\tconstructor() {\n\t\tconst name = \"AbortError\";\n\t\tsuper(name);\n\t\tthis.name = name;\n\t\tthis.message = name;\n\t}\n};\n/**\n* Polyfill for `signal.throwIfAborted()`\n*\n* @see https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/throwIfAborted\n*/\nconst throwIfAborted = (signal) => {\n\tvar _signal$throwIfAborte;\n\tif (!(signal === null || signal === void 0 ? void 0 : signal.aborted)) return;\n\t(_signal$throwIfAborte = signal.throwIfAborted) === null || _signal$throwIfAborte === void 0 || _signal$throwIfAborte.call(signal);\n\tif (typeof DOMException !== \"undefined\") throw new DOMException(\"AbortError\", \"AbortError\");\n\tthrow new AbortError();\n};\nasync function fetchHTTPResponse(opts) {\n\tvar _opts$methodOverride;\n\tthrowIfAborted(opts.signal);\n\tconst url = opts.getUrl(opts);\n\tconst body = opts.getBody(opts);\n\tconst method = (_opts$methodOverride = opts.methodOverride) !== null && _opts$methodOverride !== void 0 ? _opts$methodOverride : METHOD[opts.type];\n\tconst resolvedHeaders = await (async () => {\n\t\tconst heads = await opts.headers();\n\t\tif (Symbol.iterator in heads) return Object.fromEntries(heads);\n\t\treturn heads;\n\t})();\n\tconst headers = (0, import_objectSpread2.default)((0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, opts.contentTypeHeader && method !== \"GET\" ? { \"content-type\": opts.contentTypeHeader } : {}), opts.trpcAcceptHeader ? { \"trpc-accept\": opts.trpcAcceptHeader } : void 0), resolvedHeaders);\n\treturn getFetch(opts.fetch)(url, {\n\t\tmethod,\n\t\tsignal: opts.signal,\n\t\tbody,\n\t\theaders\n\t});\n}\nasync function httpRequest(opts) {\n\tconst meta = {};\n\tconst res = await fetchHTTPResponse(opts);\n\tmeta.response = res;\n\tconst json = await res.json();\n\tmeta.responseJSON = json;\n\treturn {\n\t\tjson,\n\t\tmeta\n\t};\n}\n\n//#endregion\nexport { fetchHTTPResponse, getBody, getFetch, getUrl, httpRequest, jsonHttpRequester, resolveHTTPLinkOptions };\n//# sourceMappingURL=httpUtils-Dv57hbOd.mjs.map","import { __toESM, require_objectSpread2 } from \"./objectSpread2-BvkFp-_Y.mjs\";\nimport { TRPCClientError } from \"./TRPCClientError-CjKyS10w.mjs\";\nimport { getUrl, httpRequest, jsonHttpRequester, resolveHTTPLinkOptions } from \"./httpUtils-Dv57hbOd.mjs\";\nimport { observable } from \"@trpc/server/observable\";\nimport { transformResult } from \"@trpc/server/unstable-core-do-not-import\";\n\n//#region src/links/internals/contentTypes.ts\nfunction isOctetType(input) {\n\treturn input instanceof Uint8Array || input instanceof Blob;\n}\nfunction isFormData(input) {\n\treturn input instanceof FormData;\n}\nfunction isNonJsonSerializable(input) {\n\treturn isOctetType(input) || isFormData(input);\n}\n\n//#endregion\n//#region src/links/httpLink.ts\nvar import_objectSpread2 = __toESM(require_objectSpread2(), 1);\nconst universalRequester = (opts) => {\n\tif (\"input\" in opts) {\n\t\tconst { input } = opts;\n\t\tif (isFormData(input)) {\n\t\t\tif (opts.type !== \"mutation\" && opts.methodOverride !== \"POST\") throw new Error(\"FormData is only supported for mutations\");\n\t\t\treturn httpRequest((0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, opts), {}, {\n\t\t\t\tcontentTypeHeader: void 0,\n\t\t\t\tgetUrl,\n\t\t\t\tgetBody: () => input\n\t\t\t}));\n\t\t}\n\t\tif (isOctetType(input)) {\n\t\t\tif (opts.type !== \"mutation\" && opts.methodOverride !== \"POST\") throw new Error(\"Octet type input is only supported for mutations\");\n\t\t\treturn httpRequest((0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, opts), {}, {\n\t\t\t\tcontentTypeHeader: \"application/octet-stream\",\n\t\t\t\tgetUrl,\n\t\t\t\tgetBody: () => input\n\t\t\t}));\n\t\t}\n\t}\n\treturn jsonHttpRequester(opts);\n};\n/**\n* @see https://trpc.io/docs/client/links/httpLink\n*/\nfunction httpLink(opts) {\n\tconst resolvedOpts = resolveHTTPLinkOptions(opts);\n\treturn () => {\n\t\treturn (operationOpts) => {\n\t\t\tconst { op } = operationOpts;\n\t\t\treturn observable((observer) => {\n\t\t\t\tconst { path, input, type } = op;\n\t\t\t\t/* istanbul ignore if -- @preserve */\n\t\t\t\tif (type === \"subscription\") throw new Error(\"Subscriptions are unsupported by `httpLink` - use `httpSubscriptionLink` or `wsLink`\");\n\t\t\t\tconst request = universalRequester((0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, resolvedOpts), {}, {\n\t\t\t\t\ttype,\n\t\t\t\t\tpath,\n\t\t\t\t\tinput,\n\t\t\t\t\tsignal: op.signal,\n\t\t\t\t\theaders() {\n\t\t\t\t\t\tif (!opts.headers) return {};\n\t\t\t\t\t\tif (typeof opts.headers === \"function\") return opts.headers({ op });\n\t\t\t\t\t\treturn opts.headers;\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t\tlet meta = void 0;\n\t\t\t\trequest.then((res) => {\n\t\t\t\t\tmeta = res.meta;\n\t\t\t\t\tconst transformed = transformResult(res.json, resolvedOpts.transformer.output);\n\t\t\t\t\tif (!transformed.ok) {\n\t\t\t\t\t\tobserver.error(TRPCClientError.from(transformed.error, { meta }));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tobserver.next({\n\t\t\t\t\t\tcontext: res.meta,\n\t\t\t\t\t\tresult: transformed.result\n\t\t\t\t\t});\n\t\t\t\t\tobserver.complete();\n\t\t\t\t}).catch((cause) => {\n\t\t\t\t\tobserver.error(TRPCClientError.from(cause, { meta }));\n\t\t\t\t});\n\t\t\t\treturn () => {};\n\t\t\t});\n\t\t};\n\t};\n}\n\n//#endregion\nexport { httpLink, isFormData, isNonJsonSerializable, isOctetType };\n//# sourceMappingURL=httpLink-DCFpUmZF.mjs.map","import { __toESM, require_objectSpread2 } from \"./objectSpread2-BvkFp-_Y.mjs\";\nimport { TRPCClientError } from \"./TRPCClientError-CjKyS10w.mjs\";\nimport { getUrl, jsonHttpRequester, resolveHTTPLinkOptions } from \"./httpUtils-Dv57hbOd.mjs\";\nimport { observable } from \"@trpc/server/observable\";\nimport { transformResult } from \"@trpc/server/unstable-core-do-not-import\";\n\n//#region src/internals/dataLoader.ts\n/**\n* A function that should never be called unless we messed something up.\n*/\nconst throwFatalError = () => {\n\tthrow new Error(\"Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new\");\n};\n/**\n* Dataloader that's very inspired by https://github.com/graphql/dataloader\n* Less configuration, no caching, and allows you to cancel requests\n* When cancelling a single fetch the whole batch will be cancelled only when _all_ items are cancelled\n*/\nfunction dataLoader(batchLoader) {\n\tlet pendingItems = null;\n\tlet dispatchTimer = null;\n\tconst destroyTimerAndPendingItems = () => {\n\t\tclearTimeout(dispatchTimer);\n\t\tdispatchTimer = null;\n\t\tpendingItems = null;\n\t};\n\t/**\n\t* Iterate through the items and split them into groups based on the `batchLoader`'s validate function\n\t*/\n\tfunction groupItems(items) {\n\t\tconst groupedItems = [[]];\n\t\tlet index = 0;\n\t\twhile (true) {\n\t\t\tconst item = items[index];\n\t\t\tif (!item) break;\n\t\t\tconst lastGroup = groupedItems[groupedItems.length - 1];\n\t\t\tif (item.aborted) {\n\t\t\t\tvar _item$reject;\n\t\t\t\t(_item$reject = item.reject) === null || _item$reject === void 0 || _item$reject.call(item, new Error(\"Aborted\"));\n\t\t\t\tindex++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst isValid = batchLoader.validate(lastGroup.concat(item).map((it) => it.key));\n\t\t\tif (isValid) {\n\t\t\t\tlastGroup.push(item);\n\t\t\t\tindex++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (lastGroup.length === 0) {\n\t\t\t\tvar _item$reject2;\n\t\t\t\t(_item$reject2 = item.reject) === null || _item$reject2 === void 0 || _item$reject2.call(item, new Error(\"Input is too big for a single dispatch\"));\n\t\t\t\tindex++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgroupedItems.push([]);\n\t\t}\n\t\treturn groupedItems;\n\t}\n\tfunction dispatch() {\n\t\tconst groupedItems = groupItems(pendingItems);\n\t\tdestroyTimerAndPendingItems();\n\t\tfor (const items of groupedItems) {\n\t\t\tif (!items.length) continue;\n\t\t\tconst batch = { items };\n\t\t\tfor (const item of items) item.batch = batch;\n\t\t\tconst promise = batchLoader.fetch(batch.items.map((_item) => _item.key));\n\t\t\tpromise.then(async (result) => {\n\t\t\t\tawait Promise.all(result.map(async (valueOrPromise, index) => {\n\t\t\t\t\tconst item = batch.items[index];\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar _item$resolve;\n\t\t\t\t\t\tconst value = await Promise.resolve(valueOrPromise);\n\t\t\t\t\t\t(_item$resolve = item.resolve) === null || _item$resolve === void 0 || _item$resolve.call(item, value);\n\t\t\t\t\t} catch (cause) {\n\t\t\t\t\t\tvar _item$reject3;\n\t\t\t\t\t\t(_item$reject3 = item.reject) === null || _item$reject3 === void 0 || _item$reject3.call(item, cause);\n\t\t\t\t\t}\n\t\t\t\t\titem.batch = null;\n\t\t\t\t\titem.reject = null;\n\t\t\t\t\titem.resolve = null;\n\t\t\t\t}));\n\t\t\t\tfor (const item of batch.items) {\n\t\t\t\t\tvar _item$reject4;\n\t\t\t\t\t(_item$reject4 = item.reject) === null || _item$reject4 === void 0 || _item$reject4.call(item, new Error(\"Missing result\"));\n\t\t\t\t\titem.batch = null;\n\t\t\t\t}\n\t\t\t}).catch((cause) => {\n\t\t\t\tfor (const item of batch.items) {\n\t\t\t\t\tvar _item$reject5;\n\t\t\t\t\t(_item$reject5 = item.reject) === null || _item$reject5 === void 0 || _item$reject5.call(item, cause);\n\t\t\t\t\titem.batch = null;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\tfunction load(key) {\n\t\tvar _dispatchTimer;\n\t\tconst item = {\n\t\t\taborted: false,\n\t\t\tkey,\n\t\t\tbatch: null,\n\t\t\tresolve: throwFatalError,\n\t\t\treject: throwFatalError\n\t\t};\n\t\tconst promise = new Promise((resolve, reject) => {\n\t\t\tvar _pendingItems;\n\t\t\titem.reject = reject;\n\t\t\titem.resolve = resolve;\n\t\t\t(_pendingItems = pendingItems) !== null && _pendingItems !== void 0 || (pendingItems = []);\n\t\t\tpendingItems.push(item);\n\t\t});\n\t\t(_dispatchTimer = dispatchTimer) !== null && _dispatchTimer !== void 0 || (dispatchTimer = setTimeout(dispatch));\n\t\treturn promise;\n\t}\n\treturn { load };\n}\n\n//#endregion\n//#region src/internals/signals.ts\n/**\n* Like `Promise.all()` but for abort signals\n* - When all signals have been aborted, the merged signal will be aborted\n* - If one signal is `null`, no signal will be aborted\n*/\nfunction allAbortSignals(...signals) {\n\tconst ac = new AbortController();\n\tconst count = signals.length;\n\tlet abortedCount = 0;\n\tconst onAbort = () => {\n\t\tif (++abortedCount === count) ac.abort();\n\t};\n\tfor (const signal of signals) if (signal === null || signal === void 0 ? void 0 : signal.aborted) onAbort();\n\telse signal === null || signal === void 0 || signal.addEventListener(\"abort\", onAbort, { once: true });\n\treturn ac.signal;\n}\n/**\n* Like `Promise.race` but for abort signals\n*\n* Basically, a ponyfill for\n* [`AbortSignal.any`](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/any_static).\n*/\nfunction raceAbortSignals(...signals) {\n\tconst ac = new AbortController();\n\tfor (const signal of signals) if (signal === null || signal === void 0 ? void 0 : signal.aborted) ac.abort();\n\telse signal === null || signal === void 0 || signal.addEventListener(\"abort\", () => ac.abort(), { once: true });\n\treturn ac.signal;\n}\nfunction abortSignalToPromise(signal) {\n\treturn new Promise((_, reject) => {\n\t\tif (signal.aborted) {\n\t\t\treject(signal.reason);\n\t\t\treturn;\n\t\t}\n\t\tsignal.addEventListener(\"abort\", () => {\n\t\t\treject(signal.reason);\n\t\t}, { once: true });\n\t});\n}\n\n//#endregion\n//#region src/links/httpBatchLink.ts\nvar import_objectSpread2 = __toESM(require_objectSpread2(), 1);\n/**\n* @see https://trpc.io/docs/client/links/httpBatchLink\n*/\nfunction httpBatchLink(opts) {\n\tvar _opts$maxURLLength, _opts$maxItems;\n\tconst resolvedOpts = resolveHTTPLinkOptions(opts);\n\tconst maxURLLength = (_opts$maxURLLength = opts.maxURLLength) !== null && _opts$maxURLLength !== void 0 ? _opts$maxURLLength : Infinity;\n\tconst maxItems = (_opts$maxItems = opts.maxItems) !== null && _opts$maxItems !== void 0 ? _opts$maxItems : Infinity;\n\treturn () => {\n\t\tconst batchLoader = (type) => {\n\t\t\treturn {\n\t\t\t\tvalidate(batchOps) {\n\t\t\t\t\tif (maxURLLength === Infinity && maxItems === Infinity) return true;\n\t\t\t\t\tif (batchOps.length > maxItems) return false;\n\t\t\t\t\tconst path = batchOps.map((op) => op.path).join(\",\");\n\t\t\t\t\tconst inputs = batchOps.map((op) => op.input);\n\t\t\t\t\tconst url = getUrl((0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, resolvedOpts), {}, {\n\t\t\t\t\t\ttype,\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\tinputs,\n\t\t\t\t\t\tsignal: null\n\t\t\t\t\t}));\n\t\t\t\t\treturn url.length <= maxURLLength;\n\t\t\t\t},\n\t\t\t\tasync fetch(batchOps) {\n\t\t\t\t\tconst path = batchOps.map((op) => op.path).join(\",\");\n\t\t\t\t\tconst inputs = batchOps.map((op) => op.input);\n\t\t\t\t\tconst signal = allAbortSignals(...batchOps.map((op) => op.signal));\n\t\t\t\t\tconst res = await jsonHttpRequester((0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, resolvedOpts), {}, {\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\tinputs,\n\t\t\t\t\t\ttype,\n\t\t\t\t\t\theaders() {\n\t\t\t\t\t\t\tif (!opts.headers) return {};\n\t\t\t\t\t\t\tif (typeof opts.headers === \"function\") return opts.headers({ opList: batchOps });\n\t\t\t\t\t\t\treturn opts.headers;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tsignal\n\t\t\t\t\t}));\n\t\t\t\t\tconst resJSON = Array.isArray(res.json) ? res.json : batchOps.map(() => res.json);\n\t\t\t\t\tconst result = resJSON.map((item) => ({\n\t\t\t\t\t\tmeta: res.meta,\n\t\t\t\t\t\tjson: item\n\t\t\t\t\t}));\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t\tconst query = dataLoader(batchLoader(\"query\"));\n\t\tconst mutation = dataLoader(batchLoader(\"mutation\"));\n\t\tconst loaders = {\n\t\t\tquery,\n\t\t\tmutation\n\t\t};\n\t\treturn ({ op }) => {\n\t\t\treturn observable((observer) => {\n\t\t\t\t/* istanbul ignore if -- @preserve */\n\t\t\t\tif (op.type === \"subscription\") throw new Error(\"Subscriptions are unsupported by `httpLink` - use `httpSubscriptionLink` or `wsLink`\");\n\t\t\t\tconst loader = loaders[op.type];\n\t\t\t\tconst promise = loader.load(op);\n\t\t\t\tlet _res = void 0;\n\t\t\t\tpromise.then((res) => {\n\t\t\t\t\t_res = res;\n\t\t\t\t\tconst transformed = transformResult(res.json, resolvedOpts.transformer.output);\n\t\t\t\t\tif (!transformed.ok) {\n\t\t\t\t\t\tobserver.error(TRPCClientError.from(transformed.error, { meta: res.meta }));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tobserver.next({\n\t\t\t\t\t\tcontext: res.meta,\n\t\t\t\t\t\tresult: transformed.result\n\t\t\t\t\t});\n\t\t\t\t\tobserver.complete();\n\t\t\t\t}).catch((err) => {\n\t\t\t\t\tobserver.error(TRPCClientError.from(err, { meta: _res === null || _res === void 0 ? void 0 : _res.meta }));\n\t\t\t\t});\n\t\t\t\treturn () => {};\n\t\t\t});\n\t\t};\n\t};\n}\n\n//#endregion\nexport { abortSignalToPromise, allAbortSignals, dataLoader, httpBatchLink, raceAbortSignals };\n//# sourceMappingURL=httpBatchLink-BOe5aCcR.mjs.map","import { __toESM, require_objectSpread2 } from \"./objectSpread2-BvkFp-_Y.mjs\";\nimport { observable, tap } from \"@trpc/server/observable\";\n\n//#region src/links/loggerLink.ts\nvar import_objectSpread2 = __toESM(require_objectSpread2(), 1);\nfunction isFormData(value) {\n\tif (typeof FormData === \"undefined\") return false;\n\treturn value instanceof FormData;\n}\nconst palettes = {\n\tcss: {\n\t\tquery: [\"72e3ff\", \"3fb0d8\"],\n\t\tmutation: [\"c5a3fc\", \"904dfc\"],\n\t\tsubscription: [\"ff49e1\", \"d83fbe\"]\n\t},\n\tansi: {\n\t\tregular: {\n\t\t\tquery: [\"\\x1B[30;46m\", \"\\x1B[97;46m\"],\n\t\t\tmutation: [\"\\x1B[30;45m\", \"\\x1B[97;45m\"],\n\t\t\tsubscription: [\"\\x1B[30;42m\", \"\\x1B[97;42m\"]\n\t\t},\n\t\tbold: {\n\t\t\tquery: [\"\\x1B[1;30;46m\", \"\\x1B[1;97;46m\"],\n\t\t\tmutation: [\"\\x1B[1;30;45m\", \"\\x1B[1;97;45m\"],\n\t\t\tsubscription: [\"\\x1B[1;30;42m\", \"\\x1B[1;97;42m\"]\n\t\t}\n\t}\n};\nfunction constructPartsAndArgs(opts) {\n\tconst { direction, type, withContext, path, id, input } = opts;\n\tconst parts = [];\n\tconst args = [];\n\tif (opts.colorMode === \"none\") parts.push(direction === \"up\" ? \">>\" : \"<<\", type, `#${id}`, path);\n\telse if (opts.colorMode === \"ansi\") {\n\t\tconst [lightRegular, darkRegular] = palettes.ansi.regular[type];\n\t\tconst [lightBold, darkBold] = palettes.ansi.bold[type];\n\t\tconst reset = \"\\x1B[0m\";\n\t\tparts.push(direction === \"up\" ? lightRegular : darkRegular, direction === \"up\" ? \">>\" : \"<<\", type, direction === \"up\" ? lightBold : darkBold, `#${id}`, path, reset);\n\t} else {\n\t\tconst [light, dark] = palettes.css[type];\n\t\tconst css = `\n    background-color: #${direction === \"up\" ? light : dark};\n    color: ${direction === \"up\" ? \"black\" : \"white\"};\n    padding: 2px;\n  `;\n\t\tparts.push(\"%c\", direction === \"up\" ? \">>\" : \"<<\", type, `#${id}`, `%c${path}%c`, \"%O\");\n\t\targs.push(css, `${css}; font-weight: bold;`, `${css}; font-weight: normal;`);\n\t}\n\tif (direction === \"up\") args.push(withContext ? {\n\t\tinput,\n\t\tcontext: opts.context\n\t} : { input });\n\telse args.push((0, import_objectSpread2.default)({\n\t\tinput,\n\t\tresult: opts.result,\n\t\telapsedMs: opts.elapsedMs\n\t}, withContext && { context: opts.context }));\n\treturn {\n\t\tparts,\n\t\targs\n\t};\n}\nconst defaultLogger = ({ c = console, colorMode = \"css\", withContext }) => (props) => {\n\tconst rawInput = props.input;\n\tconst input = isFormData(rawInput) ? Object.fromEntries(rawInput) : rawInput;\n\tconst { parts, args } = constructPartsAndArgs((0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, props), {}, {\n\t\tcolorMode,\n\t\tinput,\n\t\twithContext\n\t}));\n\tconst fn = props.direction === \"down\" && props.result && (props.result instanceof Error || \"error\" in props.result.result && props.result.result.error) ? \"error\" : \"log\";\n\tc[fn].apply(null, [parts.join(\" \")].concat(args));\n};\n/**\n* @see https://trpc.io/docs/v11/client/links/loggerLink\n*/\nfunction loggerLink(opts = {}) {\n\tvar _opts$colorMode, _opts$withContext;\n\tconst { enabled = () => true } = opts;\n\tconst colorMode = (_opts$colorMode = opts.colorMode) !== null && _opts$colorMode !== void 0 ? _opts$colorMode : typeof window === \"undefined\" ? \"ansi\" : \"css\";\n\tconst withContext = (_opts$withContext = opts.withContext) !== null && _opts$withContext !== void 0 ? _opts$withContext : colorMode === \"css\";\n\tconst { logger = defaultLogger({\n\t\tc: opts.console,\n\t\tcolorMode,\n\t\twithContext\n\t}) } = opts;\n\treturn () => {\n\t\treturn ({ op, next }) => {\n\t\t\treturn observable((observer) => {\n\t\t\t\tif (enabled((0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, op), {}, { direction: \"up\" }))) logger((0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, op), {}, { direction: \"up\" }));\n\t\t\t\tconst requestStartTime = Date.now();\n\t\t\t\tfunction logResult(result) {\n\t\t\t\t\tconst elapsedMs = Date.now() - requestStartTime;\n\t\t\t\t\tif (enabled((0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, op), {}, {\n\t\t\t\t\t\tdirection: \"down\",\n\t\t\t\t\t\tresult\n\t\t\t\t\t}))) logger((0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, op), {}, {\n\t\t\t\t\t\tdirection: \"down\",\n\t\t\t\t\t\telapsedMs,\n\t\t\t\t\t\tresult\n\t\t\t\t\t}));\n\t\t\t\t}\n\t\t\t\treturn next(op).pipe(tap({\n\t\t\t\t\tnext(result) {\n\t\t\t\t\t\tlogResult(result);\n\t\t\t\t\t},\n\t\t\t\t\terror(result) {\n\t\t\t\t\t\tlogResult(result);\n\t\t\t\t\t}\n\t\t\t\t})).subscribe(observer);\n\t\t\t});\n\t\t};\n\t};\n}\n\n//#endregion\nexport { loggerLink };\n//# sourceMappingURL=loggerLink-ineCN1PO.mjs.map","import { __toESM, require_defineProperty, require_objectSpread2 } from \"./objectSpread2-BvkFp-_Y.mjs\";\nimport { TRPCClientError } from \"./TRPCClientError-CjKyS10w.mjs\";\nimport { getTransformer } from \"./unstable-internals-Bg7n9BBj.mjs\";\nimport { behaviorSubject, observable } from \"@trpc/server/observable\";\nimport { run, sleep, transformResult } from \"@trpc/server/unstable-core-do-not-import\";\n\n//#region src/links/wsLink/wsClient/options.ts\nconst lazyDefaults = {\n\tenabled: false,\n\tcloseMs: 0\n};\nconst keepAliveDefaults = {\n\tenabled: false,\n\tpongTimeoutMs: 1e3,\n\tintervalMs: 5e3\n};\n/**\n* Calculates a delay for exponential backoff based on the retry attempt index.\n* The delay starts at 0 for the first attempt and doubles for each subsequent attempt,\n* capped at 30 seconds.\n*/\nconst exponentialBackoff = (attemptIndex) => {\n\treturn attemptIndex === 0 ? 0 : Math.min(1e3 * 2 ** attemptIndex, 3e4);\n};\n\n//#endregion\n//#region src/links/internals/urlWithConnectionParams.ts\n/**\n* Get the result of a value or function that returns a value\n* It also optionally accepts typesafe arguments for the function\n*/\nconst resultOf = (value, ...args) => {\n\treturn typeof value === \"function\" ? value(...args) : value;\n};\n\n//#endregion\n//#region src/links/wsLink/wsClient/utils.ts\nvar import_defineProperty$3 = __toESM(require_defineProperty(), 1);\nvar TRPCWebSocketClosedError = class TRPCWebSocketClosedError extends Error {\n\tconstructor(opts) {\n\t\tsuper(opts.message, { cause: opts.cause });\n\t\tthis.name = \"TRPCWebSocketClosedError\";\n\t\tObject.setPrototypeOf(this, TRPCWebSocketClosedError.prototype);\n\t}\n};\n/**\n* Utility class for managing a timeout that can be started, stopped, and reset.\n* Useful for scenarios where the timeout duration is reset dynamically based on events.\n*/\nvar ResettableTimeout = class {\n\tconstructor(onTimeout, timeoutMs) {\n\t\tthis.onTimeout = onTimeout;\n\t\tthis.timeoutMs = timeoutMs;\n\t\t(0, import_defineProperty$3.default)(this, \"timeout\", void 0);\n\t}\n\t/**\n\t* Resets the current timeout, restarting it with the same duration.\n\t* Does nothing if no timeout is active.\n\t*/\n\treset() {\n\t\tif (!this.timeout) return;\n\t\tclearTimeout(this.timeout);\n\t\tthis.timeout = setTimeout(this.onTimeout, this.timeoutMs);\n\t}\n\tstart() {\n\t\tclearTimeout(this.timeout);\n\t\tthis.timeout = setTimeout(this.onTimeout, this.timeoutMs);\n\t}\n\tstop() {\n\t\tclearTimeout(this.timeout);\n\t\tthis.timeout = void 0;\n\t}\n};\nfunction withResolvers() {\n\tlet resolve;\n\tlet reject;\n\tconst promise = new Promise((res, rej) => {\n\t\tresolve = res;\n\t\treject = rej;\n\t});\n\treturn {\n\t\tpromise,\n\t\tresolve,\n\t\treject\n\t};\n}\n/**\n* Resolves a WebSocket URL and optionally appends connection parameters.\n*\n* If connectionParams are provided, appends 'connectionParams=1' query parameter.\n*/\nasync function prepareUrl(urlOptions) {\n\tconst url = await resultOf(urlOptions.url);\n\tif (!urlOptions.connectionParams) return url;\n\tconst prefix = url.includes(\"?\") ? \"&\" : \"?\";\n\tconst connectionParams = `${prefix}connectionParams=1`;\n\treturn url + connectionParams;\n}\nasync function buildConnectionMessage(connectionParams) {\n\tconst message = {\n\t\tmethod: \"connectionParams\",\n\t\tdata: await resultOf(connectionParams)\n\t};\n\treturn JSON.stringify(message);\n}\n\n//#endregion\n//#region src/links/wsLink/wsClient/requestManager.ts\nvar import_defineProperty$2 = __toESM(require_defineProperty(), 1);\n/**\n* Manages WebSocket requests, tracking their lifecycle and providing utility methods\n* for handling outgoing and pending requests.\n*\n* - **Outgoing requests**: Requests that are queued and waiting to be sent.\n* - **Pending requests**: Requests that have been sent and are in flight awaiting a response.\n*   For subscriptions, multiple responses may be received until the subscription is closed.\n*/\nvar RequestManager = class {\n\tconstructor() {\n\t\t(0, import_defineProperty$2.default)(this, \"outgoingRequests\", new Array());\n\t\t(0, import_defineProperty$2.default)(this, \"pendingRequests\", {});\n\t}\n\t/**\n\t* Registers a new request by adding it to the outgoing queue and setting up\n\t* callbacks for lifecycle events such as completion or error.\n\t*\n\t* @param message - The outgoing message to be sent.\n\t* @param callbacks - Callback functions to observe the request's state.\n\t* @returns A cleanup function to manually remove the request.\n\t*/\n\tregister(message, callbacks) {\n\t\tconst { promise: end, resolve } = withResolvers();\n\t\tthis.outgoingRequests.push({\n\t\t\tid: String(message.id),\n\t\t\tmessage,\n\t\t\tend,\n\t\t\tcallbacks: {\n\t\t\t\tnext: callbacks.next,\n\t\t\t\tcomplete: () => {\n\t\t\t\t\tcallbacks.complete();\n\t\t\t\t\tresolve();\n\t\t\t\t},\n\t\t\t\terror: (e) => {\n\t\t\t\t\tcallbacks.error(e);\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn () => {\n\t\t\tthis.delete(message.id);\n\t\t\tcallbacks.complete();\n\t\t\tresolve();\n\t\t};\n\t}\n\t/**\n\t* Deletes a request from both the outgoing and pending collections, if it exists.\n\t*/\n\tdelete(messageId) {\n\t\tif (messageId === null) return;\n\t\tthis.outgoingRequests = this.outgoingRequests.filter(({ id }) => id !== String(messageId));\n\t\tdelete this.pendingRequests[String(messageId)];\n\t}\n\t/**\n\t* Moves all outgoing requests to the pending state and clears the outgoing queue.\n\t*\n\t* The caller is expected to handle the actual sending of the requests\n\t* (e.g., sending them over the network) after this method is called.\n\t*\n\t* @returns The list of requests that were transitioned to the pending state.\n\t*/\n\tflush() {\n\t\tconst requests = this.outgoingRequests;\n\t\tthis.outgoingRequests = [];\n\t\tfor (const request of requests) this.pendingRequests[request.id] = request;\n\t\treturn requests;\n\t}\n\t/**\n\t* Retrieves all currently pending requests, which are in flight awaiting responses\n\t* or handling ongoing subscriptions.\n\t*/\n\tgetPendingRequests() {\n\t\treturn Object.values(this.pendingRequests);\n\t}\n\t/**\n\t* Retrieves a specific pending request by its message ID.\n\t*/\n\tgetPendingRequest(messageId) {\n\t\tif (messageId === null) return null;\n\t\treturn this.pendingRequests[String(messageId)];\n\t}\n\t/**\n\t* Retrieves all outgoing requests, which are waiting to be sent.\n\t*/\n\tgetOutgoingRequests() {\n\t\treturn this.outgoingRequests;\n\t}\n\t/**\n\t* Retrieves all requests, both outgoing and pending, with their respective states.\n\t*\n\t* @returns An array of all requests with their state (\"outgoing\" or \"pending\").\n\t*/\n\tgetRequests() {\n\t\treturn [...this.getOutgoingRequests().map((request) => ({\n\t\t\tstate: \"outgoing\",\n\t\t\tmessage: request.message,\n\t\t\tend: request.end,\n\t\t\tcallbacks: request.callbacks\n\t\t})), ...this.getPendingRequests().map((request) => ({\n\t\t\tstate: \"pending\",\n\t\t\tmessage: request.message,\n\t\t\tend: request.end,\n\t\t\tcallbacks: request.callbacks\n\t\t}))];\n\t}\n\t/**\n\t* Checks if there are any pending requests, including ongoing subscriptions.\n\t*/\n\thasPendingRequests() {\n\t\treturn this.getPendingRequests().length > 0;\n\t}\n\t/**\n\t* Checks if there are any pending subscriptions\n\t*/\n\thasPendingSubscriptions() {\n\t\treturn this.getPendingRequests().some((request) => request.message.method === \"subscription\");\n\t}\n\t/**\n\t* Checks if there are any outgoing requests waiting to be sent.\n\t*/\n\thasOutgoingRequests() {\n\t\treturn this.outgoingRequests.length > 0;\n\t}\n};\n\n//#endregion\n//#region src/links/wsLink/wsClient/wsConnection.ts\nvar import_defineProperty$1 = __toESM(require_defineProperty(), 1);\n/**\n* Opens a WebSocket connection asynchronously and returns a promise\n* that resolves when the connection is successfully established.\n* The promise rejects if an error occurs during the connection attempt.\n*/\nfunction asyncWsOpen(ws) {\n\tconst { promise, resolve, reject } = withResolvers();\n\tws.addEventListener(\"open\", () => {\n\t\tws.removeEventListener(\"error\", reject);\n\t\tresolve();\n\t});\n\tws.addEventListener(\"error\", reject);\n\treturn promise;\n}\n/**\n* Sets up a periodic ping-pong mechanism to keep the WebSocket connection alive.\n*\n* - Sends \"PING\" messages at regular intervals defined by `intervalMs`.\n* - If a \"PONG\" response is not received within the `pongTimeoutMs`, the WebSocket is closed.\n* - The ping timer resets upon receiving any message to maintain activity.\n* - Automatically starts the ping process when the WebSocket connection is opened.\n* - Cleans up timers when the WebSocket is closed.\n*\n* @param ws - The WebSocket instance to manage.\n* @param options - Configuration options for ping-pong intervals and timeouts.\n*/\nfunction setupPingInterval(ws, { intervalMs, pongTimeoutMs }) {\n\tlet pingTimeout;\n\tlet pongTimeout;\n\tfunction start() {\n\t\tpingTimeout = setTimeout(() => {\n\t\t\tws.send(\"PING\");\n\t\t\tpongTimeout = setTimeout(() => {\n\t\t\t\tws.close();\n\t\t\t}, pongTimeoutMs);\n\t\t}, intervalMs);\n\t}\n\tfunction reset() {\n\t\tclearTimeout(pingTimeout);\n\t\tstart();\n\t}\n\tfunction pong() {\n\t\tclearTimeout(pongTimeout);\n\t\treset();\n\t}\n\tws.addEventListener(\"open\", start);\n\tws.addEventListener(\"message\", ({ data }) => {\n\t\tclearTimeout(pingTimeout);\n\t\tstart();\n\t\tif (data === \"PONG\") pong();\n\t});\n\tws.addEventListener(\"close\", () => {\n\t\tclearTimeout(pingTimeout);\n\t\tclearTimeout(pongTimeout);\n\t});\n}\n/**\n* Manages a WebSocket connection with support for reconnection, keep-alive mechanisms,\n* and observable state tracking.\n*/\nvar WsConnection = class WsConnection {\n\tconstructor(opts) {\n\t\tvar _opts$WebSocketPonyfi;\n\t\t(0, import_defineProperty$1.default)(this, \"id\", ++WsConnection.connectCount);\n\t\t(0, import_defineProperty$1.default)(this, \"WebSocketPonyfill\", void 0);\n\t\t(0, import_defineProperty$1.default)(this, \"urlOptions\", void 0);\n\t\t(0, import_defineProperty$1.default)(this, \"keepAliveOpts\", void 0);\n\t\t(0, import_defineProperty$1.default)(this, \"wsObservable\", behaviorSubject(null));\n\t\t(0, import_defineProperty$1.default)(this, \"openPromise\", null);\n\t\tthis.WebSocketPonyfill = (_opts$WebSocketPonyfi = opts.WebSocketPonyfill) !== null && _opts$WebSocketPonyfi !== void 0 ? _opts$WebSocketPonyfi : WebSocket;\n\t\tif (!this.WebSocketPonyfill) throw new Error(\"No WebSocket implementation found - you probably don't want to use this on the server, but if you do you need to pass a `WebSocket`-ponyfill\");\n\t\tthis.urlOptions = opts.urlOptions;\n\t\tthis.keepAliveOpts = opts.keepAlive;\n\t}\n\tget ws() {\n\t\treturn this.wsObservable.get();\n\t}\n\tset ws(ws) {\n\t\tthis.wsObservable.next(ws);\n\t}\n\t/**\n\t* Checks if the WebSocket connection is open and ready to communicate.\n\t*/\n\tisOpen() {\n\t\treturn !!this.ws && this.ws.readyState === this.WebSocketPonyfill.OPEN && !this.openPromise;\n\t}\n\t/**\n\t* Checks if the WebSocket connection is closed or in the process of closing.\n\t*/\n\tisClosed() {\n\t\treturn !!this.ws && (this.ws.readyState === this.WebSocketPonyfill.CLOSING || this.ws.readyState === this.WebSocketPonyfill.CLOSED);\n\t}\n\tasync open() {\n\t\tvar _this = this;\n\t\tif (_this.openPromise) return _this.openPromise;\n\t\t_this.id = ++WsConnection.connectCount;\n\t\tconst wsPromise = prepareUrl(_this.urlOptions).then((url) => new _this.WebSocketPonyfill(url));\n\t\t_this.openPromise = wsPromise.then(async (ws) => {\n\t\t\t_this.ws = ws;\n\t\t\tws.addEventListener(\"message\", function({ data }) {\n\t\t\t\tif (data === \"PING\") this.send(\"PONG\");\n\t\t\t});\n\t\t\tif (_this.keepAliveOpts.enabled) setupPingInterval(ws, _this.keepAliveOpts);\n\t\t\tws.addEventListener(\"close\", () => {\n\t\t\t\tif (_this.ws === ws) _this.ws = null;\n\t\t\t});\n\t\t\tawait asyncWsOpen(ws);\n\t\t\tif (_this.urlOptions.connectionParams) ws.send(await buildConnectionMessage(_this.urlOptions.connectionParams));\n\t\t});\n\t\ttry {\n\t\t\tawait _this.openPromise;\n\t\t} finally {\n\t\t\t_this.openPromise = null;\n\t\t}\n\t}\n\t/**\n\t* Closes the WebSocket connection gracefully.\n\t* Waits for any ongoing open operation to complete before closing.\n\t*/\n\tasync close() {\n\t\tvar _this2 = this;\n\t\ttry {\n\t\t\tawait _this2.openPromise;\n\t\t} finally {\n\t\t\tvar _this$ws;\n\t\t\t(_this$ws = _this2.ws) === null || _this$ws === void 0 || _this$ws.close();\n\t\t}\n\t}\n};\n(0, import_defineProperty$1.default)(WsConnection, \"connectCount\", 0);\n/**\n* Provides a backward-compatible representation of the connection state.\n*/\nfunction backwardCompatibility(connection) {\n\tif (connection.isOpen()) return {\n\t\tid: connection.id,\n\t\tstate: \"open\",\n\t\tws: connection.ws\n\t};\n\tif (connection.isClosed()) return {\n\t\tid: connection.id,\n\t\tstate: \"closed\",\n\t\tws: connection.ws\n\t};\n\tif (!connection.ws) return null;\n\treturn {\n\t\tid: connection.id,\n\t\tstate: \"connecting\",\n\t\tws: connection.ws\n\t};\n}\n\n//#endregion\n//#region src/links/wsLink/wsClient/wsClient.ts\nvar import_defineProperty = __toESM(require_defineProperty(), 1);\nvar import_objectSpread2 = __toESM(require_objectSpread2(), 1);\n/**\n* A WebSocket client for managing TRPC operations, supporting lazy initialization,\n* reconnection, keep-alive, and request management.\n*/\nvar WsClient = class {\n\tconstructor(opts) {\n\t\tvar _opts$retryDelayMs;\n\t\t(0, import_defineProperty.default)(this, \"connectionState\", void 0);\n\t\t(0, import_defineProperty.default)(this, \"allowReconnect\", false);\n\t\t(0, import_defineProperty.default)(this, \"requestManager\", new RequestManager());\n\t\t(0, import_defineProperty.default)(this, \"activeConnection\", void 0);\n\t\t(0, import_defineProperty.default)(this, \"reconnectRetryDelay\", void 0);\n\t\t(0, import_defineProperty.default)(this, \"inactivityTimeout\", void 0);\n\t\t(0, import_defineProperty.default)(this, \"callbacks\", void 0);\n\t\t(0, import_defineProperty.default)(this, \"lazyMode\", void 0);\n\t\t(0, import_defineProperty.default)(this, \"reconnecting\", null);\n\t\tthis.callbacks = {\n\t\t\tonOpen: opts.onOpen,\n\t\t\tonClose: opts.onClose,\n\t\t\tonError: opts.onError\n\t\t};\n\t\tconst lazyOptions = (0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, lazyDefaults), opts.lazy);\n\t\tthis.inactivityTimeout = new ResettableTimeout(() => {\n\t\t\tif (this.requestManager.hasOutgoingRequests() || this.requestManager.hasPendingRequests()) {\n\t\t\t\tthis.inactivityTimeout.reset();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.close().catch(() => null);\n\t\t}, lazyOptions.closeMs);\n\t\tthis.activeConnection = new WsConnection({\n\t\t\tWebSocketPonyfill: opts.WebSocket,\n\t\t\turlOptions: opts,\n\t\t\tkeepAlive: (0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, keepAliveDefaults), opts.keepAlive)\n\t\t});\n\t\tthis.activeConnection.wsObservable.subscribe({ next: (ws) => {\n\t\t\tif (!ws) return;\n\t\t\tthis.setupWebSocketListeners(ws);\n\t\t} });\n\t\tthis.reconnectRetryDelay = (_opts$retryDelayMs = opts.retryDelayMs) !== null && _opts$retryDelayMs !== void 0 ? _opts$retryDelayMs : exponentialBackoff;\n\t\tthis.lazyMode = lazyOptions.enabled;\n\t\tthis.connectionState = behaviorSubject({\n\t\t\ttype: \"state\",\n\t\t\tstate: lazyOptions.enabled ? \"idle\" : \"connecting\",\n\t\t\terror: null\n\t\t});\n\t\tif (!this.lazyMode) this.open().catch(() => null);\n\t}\n\t/**\n\t* Opens the WebSocket connection. Handles reconnection attempts and updates\n\t* the connection state accordingly.\n\t*/\n\tasync open() {\n\t\tvar _this = this;\n\t\t_this.allowReconnect = true;\n\t\tif (_this.connectionState.get().state === \"idle\") _this.connectionState.next({\n\t\t\ttype: \"state\",\n\t\t\tstate: \"connecting\",\n\t\t\terror: null\n\t\t});\n\t\ttry {\n\t\t\tawait _this.activeConnection.open();\n\t\t} catch (error) {\n\t\t\t_this.reconnect(new TRPCWebSocketClosedError({\n\t\t\t\tmessage: \"Initialization error\",\n\t\t\t\tcause: error\n\t\t\t}));\n\t\t\treturn _this.reconnecting;\n\t\t}\n\t}\n\t/**\n\t* Closes the WebSocket connection and stops managing requests.\n\t* Ensures all outgoing and pending requests are properly finalized.\n\t*/\n\tasync close() {\n\t\tvar _this2 = this;\n\t\t_this2.allowReconnect = false;\n\t\t_this2.inactivityTimeout.stop();\n\t\tconst requestsToAwait = [];\n\t\tfor (const request of _this2.requestManager.getRequests()) if (request.message.method === \"subscription\") request.callbacks.complete();\n\t\telse if (request.state === \"outgoing\") request.callbacks.error(TRPCClientError.from(new TRPCWebSocketClosedError({ message: \"Closed before connection was established\" })));\n\t\telse requestsToAwait.push(request.end);\n\t\tawait Promise.all(requestsToAwait).catch(() => null);\n\t\tawait _this2.activeConnection.close().catch(() => null);\n\t\t_this2.connectionState.next({\n\t\t\ttype: \"state\",\n\t\t\tstate: \"idle\",\n\t\t\terror: null\n\t\t});\n\t}\n\t/**\n\t* Method to request the server.\n\t* Handles data transformation, batching of requests, and subscription lifecycle.\n\t*\n\t* @param op - The operation details including id, type, path, input and signal\n\t* @param transformer - Data transformer for serializing requests and deserializing responses\n\t* @param lastEventId - Optional ID of the last received event for subscriptions\n\t*\n\t* @returns An observable that emits operation results and handles cleanup\n\t*/\n\trequest({ op: { id, type, path, input, signal }, transformer, lastEventId }) {\n\t\treturn observable((observer) => {\n\t\t\tconst abort = this.batchSend({\n\t\t\t\tid,\n\t\t\t\tmethod: type,\n\t\t\t\tparams: {\n\t\t\t\t\tinput: transformer.input.serialize(input),\n\t\t\t\t\tpath,\n\t\t\t\t\tlastEventId\n\t\t\t\t}\n\t\t\t}, (0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, observer), {}, { next(event) {\n\t\t\t\tconst transformed = transformResult(event, transformer.output);\n\t\t\t\tif (!transformed.ok) {\n\t\t\t\t\tobserver.error(TRPCClientError.from(transformed.error));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tobserver.next({ result: transformed.result });\n\t\t\t} }));\n\t\t\treturn () => {\n\t\t\t\tabort();\n\t\t\t\tif (type === \"subscription\" && this.activeConnection.isOpen()) this.send({\n\t\t\t\t\tid,\n\t\t\t\t\tmethod: \"subscription.stop\"\n\t\t\t\t});\n\t\t\t\tsignal === null || signal === void 0 || signal.removeEventListener(\"abort\", abort);\n\t\t\t};\n\t\t});\n\t}\n\tget connection() {\n\t\treturn backwardCompatibility(this.activeConnection);\n\t}\n\treconnect(closedError) {\n\t\tvar _this3 = this;\n\t\tthis.connectionState.next({\n\t\t\ttype: \"state\",\n\t\t\tstate: \"connecting\",\n\t\t\terror: TRPCClientError.from(closedError)\n\t\t});\n\t\tif (this.reconnecting) return;\n\t\tconst tryReconnect = async (attemptIndex) => {\n\t\t\ttry {\n\t\t\t\tawait sleep(_this3.reconnectRetryDelay(attemptIndex));\n\t\t\t\tif (_this3.allowReconnect) {\n\t\t\t\t\tawait _this3.activeConnection.close();\n\t\t\t\t\tawait _this3.activeConnection.open();\n\t\t\t\t\tif (_this3.requestManager.hasPendingRequests()) _this3.send(_this3.requestManager.getPendingRequests().map(({ message }) => message));\n\t\t\t\t}\n\t\t\t\t_this3.reconnecting = null;\n\t\t\t} catch (_unused) {\n\t\t\t\tawait tryReconnect(attemptIndex + 1);\n\t\t\t}\n\t\t};\n\t\tthis.reconnecting = tryReconnect(0);\n\t}\n\tsetupWebSocketListeners(ws) {\n\t\tvar _this4 = this;\n\t\tconst handleCloseOrError = (cause) => {\n\t\t\tconst reqs = this.requestManager.getPendingRequests();\n\t\t\tfor (const { message, callbacks } of reqs) {\n\t\t\t\tif (message.method === \"subscription\") continue;\n\t\t\t\tcallbacks.error(TRPCClientError.from(cause !== null && cause !== void 0 ? cause : new TRPCWebSocketClosedError({\n\t\t\t\t\tmessage: \"WebSocket closed\",\n\t\t\t\t\tcause\n\t\t\t\t})));\n\t\t\t\tthis.requestManager.delete(message.id);\n\t\t\t}\n\t\t};\n\t\tws.addEventListener(\"open\", () => {\n\t\t\trun(async () => {\n\t\t\t\tvar _this$callbacks$onOpe, _this$callbacks;\n\t\t\t\tif (_this4.lazyMode) _this4.inactivityTimeout.start();\n\t\t\t\t(_this$callbacks$onOpe = (_this$callbacks = _this4.callbacks).onOpen) === null || _this$callbacks$onOpe === void 0 || _this$callbacks$onOpe.call(_this$callbacks);\n\t\t\t\t_this4.connectionState.next({\n\t\t\t\t\ttype: \"state\",\n\t\t\t\t\tstate: \"pending\",\n\t\t\t\t\terror: null\n\t\t\t\t});\n\t\t\t}).catch((error) => {\n\t\t\t\tws.close(3e3);\n\t\t\t\thandleCloseOrError(error);\n\t\t\t});\n\t\t});\n\t\tws.addEventListener(\"message\", ({ data }) => {\n\t\t\tthis.inactivityTimeout.reset();\n\t\t\tif (typeof data !== \"string\" || [\"PING\", \"PONG\"].includes(data)) return;\n\t\t\tconst incomingMessage = JSON.parse(data);\n\t\t\tif (\"method\" in incomingMessage) {\n\t\t\t\tthis.handleIncomingRequest(incomingMessage);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.handleResponseMessage(incomingMessage);\n\t\t});\n\t\tws.addEventListener(\"close\", (event) => {\n\t\t\tvar _this$callbacks$onClo, _this$callbacks2;\n\t\t\thandleCloseOrError(event);\n\t\t\t(_this$callbacks$onClo = (_this$callbacks2 = this.callbacks).onClose) === null || _this$callbacks$onClo === void 0 || _this$callbacks$onClo.call(_this$callbacks2, event);\n\t\t\tif (!this.lazyMode || this.requestManager.hasPendingSubscriptions()) this.reconnect(new TRPCWebSocketClosedError({\n\t\t\t\tmessage: \"WebSocket closed\",\n\t\t\t\tcause: event\n\t\t\t}));\n\t\t});\n\t\tws.addEventListener(\"error\", (event) => {\n\t\t\tvar _this$callbacks$onErr, _this$callbacks3;\n\t\t\thandleCloseOrError(event);\n\t\t\t(_this$callbacks$onErr = (_this$callbacks3 = this.callbacks).onError) === null || _this$callbacks$onErr === void 0 || _this$callbacks$onErr.call(_this$callbacks3, event);\n\t\t\tthis.reconnect(new TRPCWebSocketClosedError({\n\t\t\t\tmessage: \"WebSocket closed\",\n\t\t\t\tcause: event\n\t\t\t}));\n\t\t});\n\t}\n\thandleResponseMessage(message) {\n\t\tconst request = this.requestManager.getPendingRequest(message.id);\n\t\tif (!request) return;\n\t\trequest.callbacks.next(message);\n\t\tlet completed = true;\n\t\tif (\"result\" in message && request.message.method === \"subscription\") {\n\t\t\tif (message.result.type === \"data\") request.message.params.lastEventId = message.result.id;\n\t\t\tif (message.result.type !== \"stopped\") completed = false;\n\t\t}\n\t\tif (completed) {\n\t\t\trequest.callbacks.complete();\n\t\t\tthis.requestManager.delete(message.id);\n\t\t}\n\t}\n\thandleIncomingRequest(message) {\n\t\tif (message.method === \"reconnect\") this.reconnect(new TRPCWebSocketClosedError({ message: \"Server requested reconnect\" }));\n\t}\n\t/**\n\t* Sends a message or batch of messages directly to the server.\n\t*/\n\tsend(messageOrMessages) {\n\t\tif (!this.activeConnection.isOpen()) throw new Error(\"Active connection is not open\");\n\t\tconst messages = messageOrMessages instanceof Array ? messageOrMessages : [messageOrMessages];\n\t\tthis.activeConnection.ws.send(JSON.stringify(messages.length === 1 ? messages[0] : messages));\n\t}\n\t/**\n\t* Groups requests for batch sending.\n\t*\n\t* @returns A function to abort the batched request.\n\t*/\n\tbatchSend(message, callbacks) {\n\t\tvar _this5 = this;\n\t\tthis.inactivityTimeout.reset();\n\t\trun(async () => {\n\t\t\tif (!_this5.activeConnection.isOpen()) await _this5.open();\n\t\t\tawait sleep(0);\n\t\t\tif (!_this5.requestManager.hasOutgoingRequests()) return;\n\t\t\t_this5.send(_this5.requestManager.flush().map(({ message: message$1 }) => message$1));\n\t\t}).catch((err) => {\n\t\t\tthis.requestManager.delete(message.id);\n\t\t\tcallbacks.error(TRPCClientError.from(err));\n\t\t});\n\t\treturn this.requestManager.register(message, callbacks);\n\t}\n};\n\n//#endregion\n//#region src/links/wsLink/createWsClient.ts\nfunction createWSClient(opts) {\n\treturn new WsClient(opts);\n}\n\n//#endregion\n//#region src/links/wsLink/wsLink.ts\nfunction wsLink(opts) {\n\tconst { client } = opts;\n\tconst transformer = getTransformer(opts.transformer);\n\treturn () => {\n\t\treturn ({ op }) => {\n\t\t\treturn observable((observer) => {\n\t\t\t\tconst connStateSubscription = op.type === \"subscription\" ? client.connectionState.subscribe({ next(result) {\n\t\t\t\t\tobserver.next({\n\t\t\t\t\t\tresult,\n\t\t\t\t\t\tcontext: op.context\n\t\t\t\t\t});\n\t\t\t\t} }) : null;\n\t\t\t\tconst requestSubscription = client.request({\n\t\t\t\t\top,\n\t\t\t\t\ttransformer\n\t\t\t\t}).subscribe(observer);\n\t\t\t\treturn () => {\n\t\t\t\t\trequestSubscription.unsubscribe();\n\t\t\t\t\tconnStateSubscription === null || connStateSubscription === void 0 || connStateSubscription.unsubscribe();\n\t\t\t\t};\n\t\t\t});\n\t\t};\n\t};\n}\n\n//#endregion\nexport { createWSClient, resultOf, wsLink };\n//# sourceMappingURL=wsLink-CatceK3c.mjs.map","import { __commonJS, __toESM, require_defineProperty, require_objectSpread2 } from \"./objectSpread2-BvkFp-_Y.mjs\";\nimport { createChain, splitLink } from \"./splitLink-B7Cuf2c_.mjs\";\nimport { TRPCClientError, isTRPCClientError } from \"./TRPCClientError-CjKyS10w.mjs\";\nimport { fetchHTTPResponse, getBody, getFetch, getUrl, resolveHTTPLinkOptions } from \"./httpUtils-Dv57hbOd.mjs\";\nimport { httpLink, isFormData, isNonJsonSerializable, isOctetType } from \"./httpLink-DCFpUmZF.mjs\";\nimport { abortSignalToPromise, allAbortSignals, dataLoader, httpBatchLink, raceAbortSignals } from \"./httpBatchLink-BOe5aCcR.mjs\";\nimport { getTransformer } from \"./unstable-internals-Bg7n9BBj.mjs\";\nimport { loggerLink } from \"./loggerLink-ineCN1PO.mjs\";\nimport { createWSClient, resultOf, wsLink } from \"./wsLink-CatceK3c.mjs\";\nimport { behaviorSubject, observable, observableToPromise, share } from \"@trpc/server/observable\";\nimport { callProcedure, createFlatProxy, createRecursiveProxy, isAbortError, isAsyncIterable, iteratorResource, jsonlStreamConsumer, makeResource, retryableRpcCodes, run, sseStreamConsumer } from \"@trpc/server/unstable-core-do-not-import\";\nimport { getTRPCErrorFromUnknown, getTRPCErrorShape, isTrackedEnvelope } from \"@trpc/server\";\nimport { TRPC_ERROR_CODES_BY_KEY } from \"@trpc/server/rpc\";\n\n//#region src/internals/TRPCUntypedClient.ts\nvar import_defineProperty = __toESM(require_defineProperty(), 1);\nvar import_objectSpread2$4 = __toESM(require_objectSpread2(), 1);\nvar TRPCUntypedClient = class {\n\tconstructor(opts) {\n\t\t(0, import_defineProperty.default)(this, \"links\", void 0);\n\t\t(0, import_defineProperty.default)(this, \"runtime\", void 0);\n\t\t(0, import_defineProperty.default)(this, \"requestId\", void 0);\n\t\tthis.requestId = 0;\n\t\tthis.runtime = {};\n\t\tthis.links = opts.links.map((link) => link(this.runtime));\n\t}\n\t$request(opts) {\n\t\tvar _opts$context;\n\t\tconst chain$ = createChain({\n\t\t\tlinks: this.links,\n\t\t\top: (0, import_objectSpread2$4.default)((0, import_objectSpread2$4.default)({}, opts), {}, {\n\t\t\t\tcontext: (_opts$context = opts.context) !== null && _opts$context !== void 0 ? _opts$context : {},\n\t\t\t\tid: ++this.requestId\n\t\t\t})\n\t\t});\n\t\treturn chain$.pipe(share());\n\t}\n\tasync requestAsPromise(opts) {\n\t\tvar _this = this;\n\t\ttry {\n\t\t\tconst req$ = _this.$request(opts);\n\t\t\tconst envelope = await observableToPromise(req$);\n\t\t\tconst data = envelope.result.data;\n\t\t\treturn data;\n\t\t} catch (err) {\n\t\t\tthrow TRPCClientError.from(err);\n\t\t}\n\t}\n\tquery(path, input, opts) {\n\t\treturn this.requestAsPromise({\n\t\t\ttype: \"query\",\n\t\t\tpath,\n\t\t\tinput,\n\t\t\tcontext: opts === null || opts === void 0 ? void 0 : opts.context,\n\t\t\tsignal: opts === null || opts === void 0 ? void 0 : opts.signal\n\t\t});\n\t}\n\tmutation(path, input, opts) {\n\t\treturn this.requestAsPromise({\n\t\t\ttype: \"mutation\",\n\t\t\tpath,\n\t\t\tinput,\n\t\t\tcontext: opts === null || opts === void 0 ? void 0 : opts.context,\n\t\t\tsignal: opts === null || opts === void 0 ? void 0 : opts.signal\n\t\t});\n\t}\n\tsubscription(path, input, opts) {\n\t\tconst observable$ = this.$request({\n\t\t\ttype: \"subscription\",\n\t\t\tpath,\n\t\t\tinput,\n\t\t\tcontext: opts.context,\n\t\t\tsignal: opts.signal\n\t\t});\n\t\treturn observable$.subscribe({\n\t\t\tnext(envelope) {\n\t\t\t\tswitch (envelope.result.type) {\n\t\t\t\t\tcase \"state\": {\n\t\t\t\t\t\tvar _opts$onConnectionSta;\n\t\t\t\t\t\t(_opts$onConnectionSta = opts.onConnectionStateChange) === null || _opts$onConnectionSta === void 0 || _opts$onConnectionSta.call(opts, envelope.result);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"started\": {\n\t\t\t\t\t\tvar _opts$onStarted;\n\t\t\t\t\t\t(_opts$onStarted = opts.onStarted) === null || _opts$onStarted === void 0 || _opts$onStarted.call(opts, { context: envelope.context });\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"stopped\": {\n\t\t\t\t\t\tvar _opts$onStopped;\n\t\t\t\t\t\t(_opts$onStopped = opts.onStopped) === null || _opts$onStopped === void 0 || _opts$onStopped.call(opts);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"data\":\n\t\t\t\t\tcase void 0: {\n\t\t\t\t\t\tvar _opts$onData;\n\t\t\t\t\t\t(_opts$onData = opts.onData) === null || _opts$onData === void 0 || _opts$onData.call(opts, envelope.result.data);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\terror(err) {\n\t\t\t\tvar _opts$onError;\n\t\t\t\t(_opts$onError = opts.onError) === null || _opts$onError === void 0 || _opts$onError.call(opts, err);\n\t\t\t},\n\t\t\tcomplete() {\n\t\t\t\tvar _opts$onComplete;\n\t\t\t\t(_opts$onComplete = opts.onComplete) === null || _opts$onComplete === void 0 || _opts$onComplete.call(opts);\n\t\t\t}\n\t\t});\n\t}\n};\n\n//#endregion\n//#region src/createTRPCUntypedClient.ts\nfunction createTRPCUntypedClient(opts) {\n\treturn new TRPCUntypedClient(opts);\n}\n\n//#endregion\n//#region src/createTRPCClient.ts\nconst untypedClientSymbol = Symbol.for(\"trpc_untypedClient\");\nconst clientCallTypeMap = {\n\tquery: \"query\",\n\tmutate: \"mutation\",\n\tsubscribe: \"subscription\"\n};\n/** @internal */\nconst clientCallTypeToProcedureType = (clientCallType) => {\n\treturn clientCallTypeMap[clientCallType];\n};\n/**\n* @internal\n*/\nfunction createTRPCClientProxy(client) {\n\tconst proxy = createRecursiveProxy(({ path, args }) => {\n\t\tconst pathCopy = [...path];\n\t\tconst procedureType = clientCallTypeToProcedureType(pathCopy.pop());\n\t\tconst fullPath = pathCopy.join(\".\");\n\t\treturn client[procedureType](fullPath, ...args);\n\t});\n\treturn createFlatProxy((key) => {\n\t\tif (key === untypedClientSymbol) return client;\n\t\treturn proxy[key];\n\t});\n}\nfunction createTRPCClient(opts) {\n\tconst client = new TRPCUntypedClient(opts);\n\tconst proxy = createTRPCClientProxy(client);\n\treturn proxy;\n}\n/**\n* Get an untyped client from a proxy client\n* @internal\n*/\nfunction getUntypedClient(client) {\n\treturn client[untypedClientSymbol];\n}\n\n//#endregion\n//#region src/links/httpBatchStreamLink.ts\nvar import_objectSpread2$3 = __toESM(require_objectSpread2(), 1);\n/**\n* @see https://trpc.io/docs/client/links/httpBatchStreamLink\n*/\nfunction httpBatchStreamLink(opts) {\n\tvar _opts$maxURLLength, _opts$maxItems;\n\tconst resolvedOpts = resolveHTTPLinkOptions(opts);\n\tconst maxURLLength = (_opts$maxURLLength = opts.maxURLLength) !== null && _opts$maxURLLength !== void 0 ? _opts$maxURLLength : Infinity;\n\tconst maxItems = (_opts$maxItems = opts.maxItems) !== null && _opts$maxItems !== void 0 ? _opts$maxItems : Infinity;\n\treturn () => {\n\t\tconst batchLoader = (type) => {\n\t\t\treturn {\n\t\t\t\tvalidate(batchOps) {\n\t\t\t\t\tif (maxURLLength === Infinity && maxItems === Infinity) return true;\n\t\t\t\t\tif (batchOps.length > maxItems) return false;\n\t\t\t\t\tconst path = batchOps.map((op) => op.path).join(\",\");\n\t\t\t\t\tconst inputs = batchOps.map((op) => op.input);\n\t\t\t\t\tconst url = getUrl((0, import_objectSpread2$3.default)((0, import_objectSpread2$3.default)({}, resolvedOpts), {}, {\n\t\t\t\t\t\ttype,\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\tinputs,\n\t\t\t\t\t\tsignal: null\n\t\t\t\t\t}));\n\t\t\t\t\treturn url.length <= maxURLLength;\n\t\t\t\t},\n\t\t\t\tasync fetch(batchOps) {\n\t\t\t\t\tconst path = batchOps.map((op) => op.path).join(\",\");\n\t\t\t\t\tconst inputs = batchOps.map((op) => op.input);\n\t\t\t\t\tconst batchSignals = allAbortSignals(...batchOps.map((op) => op.signal));\n\t\t\t\t\tconst abortController = new AbortController();\n\t\t\t\t\tconst responsePromise = fetchHTTPResponse((0, import_objectSpread2$3.default)((0, import_objectSpread2$3.default)({}, resolvedOpts), {}, {\n\t\t\t\t\t\tsignal: raceAbortSignals(batchSignals, abortController.signal),\n\t\t\t\t\t\ttype,\n\t\t\t\t\t\tcontentTypeHeader: \"application/json\",\n\t\t\t\t\t\ttrpcAcceptHeader: \"application/jsonl\",\n\t\t\t\t\t\tgetUrl,\n\t\t\t\t\t\tgetBody,\n\t\t\t\t\t\tinputs,\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\theaders() {\n\t\t\t\t\t\t\tif (!opts.headers) return {};\n\t\t\t\t\t\t\tif (typeof opts.headers === \"function\") return opts.headers({ opList: batchOps });\n\t\t\t\t\t\t\treturn opts.headers;\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t\t\t\tconst res = await responsePromise;\n\t\t\t\t\tconst [head] = await jsonlStreamConsumer({\n\t\t\t\t\t\tfrom: res.body,\n\t\t\t\t\t\tdeserialize: (data) => resolvedOpts.transformer.output.deserialize(data),\n\t\t\t\t\t\tformatError(opts$1) {\n\t\t\t\t\t\t\tconst error = opts$1.error;\n\t\t\t\t\t\t\treturn TRPCClientError.from({ error });\n\t\t\t\t\t\t},\n\t\t\t\t\t\tabortController\n\t\t\t\t\t});\n\t\t\t\t\tconst promises = Object.keys(batchOps).map(async (key) => {\n\t\t\t\t\t\tlet json = await Promise.resolve(head[key]);\n\t\t\t\t\t\tif (\"result\" in json) {\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t* Not very pretty, but we need to unwrap nested data as promises\n\t\t\t\t\t\t\t* Our stream producer will only resolve top-level async values or async values that are directly nested in another async value\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\tconst result = await Promise.resolve(json.result);\n\t\t\t\t\t\t\tjson = { result: { data: await Promise.resolve(result.data) } };\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tjson,\n\t\t\t\t\t\t\tmeta: { response: res }\n\t\t\t\t\t\t};\n\t\t\t\t\t});\n\t\t\t\t\treturn promises;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t\tconst query = dataLoader(batchLoader(\"query\"));\n\t\tconst mutation = dataLoader(batchLoader(\"mutation\"));\n\t\tconst loaders = {\n\t\t\tquery,\n\t\t\tmutation\n\t\t};\n\t\treturn ({ op }) => {\n\t\t\treturn observable((observer) => {\n\t\t\t\t/* istanbul ignore if -- @preserve */\n\t\t\t\tif (op.type === \"subscription\") throw new Error(\"Subscriptions are unsupported by `httpBatchStreamLink` - use `httpSubscriptionLink` or `wsLink`\");\n\t\t\t\tconst loader = loaders[op.type];\n\t\t\t\tconst promise = loader.load(op);\n\t\t\t\tlet _res = void 0;\n\t\t\t\tpromise.then((res) => {\n\t\t\t\t\t_res = res;\n\t\t\t\t\tif (\"error\" in res.json) {\n\t\t\t\t\t\tobserver.error(TRPCClientError.from(res.json, { meta: res.meta }));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else if (\"result\" in res.json) {\n\t\t\t\t\t\tobserver.next({\n\t\t\t\t\t\t\tcontext: res.meta,\n\t\t\t\t\t\t\tresult: res.json.result\n\t\t\t\t\t\t});\n\t\t\t\t\t\tobserver.complete();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tobserver.complete();\n\t\t\t\t}).catch((err) => {\n\t\t\t\t\tobserver.error(TRPCClientError.from(err, { meta: _res === null || _res === void 0 ? void 0 : _res.meta }));\n\t\t\t\t});\n\t\t\t\treturn () => {};\n\t\t\t});\n\t\t};\n\t};\n}\n/**\n* @deprecated use {@link httpBatchStreamLink} instead\n*/\nconst unstable_httpBatchStreamLink = httpBatchStreamLink;\n\n//#endregion\n//#region src/internals/inputWithTrackedEventId.ts\nvar import_objectSpread2$2 = __toESM(require_objectSpread2(), 1);\nfunction inputWithTrackedEventId(input, lastEventId) {\n\tif (!lastEventId) return input;\n\tif (input != null && typeof input !== \"object\") return input;\n\treturn (0, import_objectSpread2$2.default)((0, import_objectSpread2$2.default)({}, input !== null && input !== void 0 ? input : {}), {}, { lastEventId });\n}\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/asyncIterator.js\nvar require_asyncIterator = __commonJS({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/asyncIterator.js\"(exports, module) {\n\tfunction _asyncIterator$1(r) {\n\t\tvar n, t, o, e = 2;\n\t\tfor (\"undefined\" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) {\n\t\t\tif (t && null != (n = r[t])) return n.call(r);\n\t\t\tif (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r));\n\t\t\tt = \"@@asyncIterator\", o = \"@@iterator\";\n\t\t}\n\t\tthrow new TypeError(\"Object is not async iterable\");\n\t}\n\tfunction AsyncFromSyncIterator(r) {\n\t\tfunction AsyncFromSyncIteratorContinuation(r$1) {\n\t\t\tif (Object(r$1) !== r$1) return Promise.reject(new TypeError(r$1 + \" is not an object.\"));\n\t\t\tvar n = r$1.done;\n\t\t\treturn Promise.resolve(r$1.value).then(function(r$2) {\n\t\t\t\treturn {\n\t\t\t\t\tvalue: r$2,\n\t\t\t\t\tdone: n\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\t\treturn AsyncFromSyncIterator = function AsyncFromSyncIterator$1(r$1) {\n\t\t\tthis.s = r$1, this.n = r$1.next;\n\t\t}, AsyncFromSyncIterator.prototype = {\n\t\t\ts: null,\n\t\t\tn: null,\n\t\t\tnext: function next() {\n\t\t\t\treturn AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));\n\t\t\t},\n\t\t\t\"return\": function _return(r$1) {\n\t\t\t\tvar n = this.s[\"return\"];\n\t\t\t\treturn void 0 === n ? Promise.resolve({\n\t\t\t\t\tvalue: r$1,\n\t\t\t\t\tdone: !0\n\t\t\t\t}) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));\n\t\t\t},\n\t\t\t\"throw\": function _throw(r$1) {\n\t\t\t\tvar n = this.s[\"return\"];\n\t\t\t\treturn void 0 === n ? Promise.reject(r$1) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));\n\t\t\t}\n\t\t}, new AsyncFromSyncIterator(r);\n\t}\n\tmodule.exports = _asyncIterator$1, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n} });\n\n//#endregion\n//#region src/links/httpSubscriptionLink.ts\nvar import_asyncIterator = __toESM(require_asyncIterator(), 1);\nasync function urlWithConnectionParams(opts) {\n\tlet url = await resultOf(opts.url);\n\tif (opts.connectionParams) {\n\t\tconst params = await resultOf(opts.connectionParams);\n\t\tconst prefix = url.includes(\"?\") ? \"&\" : \"?\";\n\t\turl += prefix + \"connectionParams=\" + encodeURIComponent(JSON.stringify(params));\n\t}\n\treturn url;\n}\n/**\n* @see https://trpc.io/docs/client/links/httpSubscriptionLink\n*/\nfunction httpSubscriptionLink(opts) {\n\tconst transformer = getTransformer(opts.transformer);\n\treturn () => {\n\t\treturn ({ op }) => {\n\t\t\treturn observable((observer) => {\n\t\t\t\tvar _opts$EventSource;\n\t\t\t\tconst { type, path, input } = op;\n\t\t\t\t/* istanbul ignore if -- @preserve */\n\t\t\t\tif (type !== \"subscription\") throw new Error(\"httpSubscriptionLink only supports subscriptions\");\n\t\t\t\tlet lastEventId = void 0;\n\t\t\t\tconst ac = new AbortController();\n\t\t\t\tconst signal = raceAbortSignals(op.signal, ac.signal);\n\t\t\t\tconst eventSourceStream = sseStreamConsumer({\n\t\t\t\t\turl: async () => getUrl({\n\t\t\t\t\t\ttransformer,\n\t\t\t\t\t\turl: await urlWithConnectionParams(opts),\n\t\t\t\t\t\tinput: inputWithTrackedEventId(input, lastEventId),\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\ttype,\n\t\t\t\t\t\tsignal: null\n\t\t\t\t\t}),\n\t\t\t\t\tinit: () => resultOf(opts.eventSourceOptions, { op }),\n\t\t\t\t\tsignal,\n\t\t\t\t\tdeserialize: (data) => transformer.output.deserialize(data),\n\t\t\t\t\tEventSource: (_opts$EventSource = opts.EventSource) !== null && _opts$EventSource !== void 0 ? _opts$EventSource : globalThis.EventSource\n\t\t\t\t});\n\t\t\t\tconst connectionState = behaviorSubject({\n\t\t\t\t\ttype: \"state\",\n\t\t\t\t\tstate: \"connecting\",\n\t\t\t\t\terror: null\n\t\t\t\t});\n\t\t\t\tconst connectionSub = connectionState.subscribe({ next(state) {\n\t\t\t\t\tobserver.next({ result: state });\n\t\t\t\t} });\n\t\t\t\trun(async () => {\n\t\t\t\t\tvar _iteratorAbruptCompletion = false;\n\t\t\t\t\tvar _didIteratorError = false;\n\t\t\t\t\tvar _iteratorError;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfor (var _iterator = (0, import_asyncIterator.default)(eventSourceStream), _step; _iteratorAbruptCompletion = !(_step = await _iterator.next()).done; _iteratorAbruptCompletion = false) {\n\t\t\t\t\t\t\tconst chunk = _step.value;\n\t\t\t\t\t\t\tswitch (chunk.type) {\n\t\t\t\t\t\t\t\tcase \"ping\": break;\n\t\t\t\t\t\t\t\tcase \"data\":\n\t\t\t\t\t\t\t\t\tconst chunkData = chunk.data;\n\t\t\t\t\t\t\t\t\tlet result;\n\t\t\t\t\t\t\t\t\tif (chunkData.id) {\n\t\t\t\t\t\t\t\t\t\tlastEventId = chunkData.id;\n\t\t\t\t\t\t\t\t\t\tresult = {\n\t\t\t\t\t\t\t\t\t\t\tid: chunkData.id,\n\t\t\t\t\t\t\t\t\t\t\tdata: chunkData\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t} else result = { data: chunkData.data };\n\t\t\t\t\t\t\t\t\tobserver.next({\n\t\t\t\t\t\t\t\t\t\tresult,\n\t\t\t\t\t\t\t\t\t\tcontext: { eventSource: chunk.eventSource }\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"connected\": {\n\t\t\t\t\t\t\t\t\tobserver.next({\n\t\t\t\t\t\t\t\t\t\tresult: { type: \"started\" },\n\t\t\t\t\t\t\t\t\t\tcontext: { eventSource: chunk.eventSource }\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\tconnectionState.next({\n\t\t\t\t\t\t\t\t\t\ttype: \"state\",\n\t\t\t\t\t\t\t\t\t\tstate: \"pending\",\n\t\t\t\t\t\t\t\t\t\terror: null\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcase \"serialized-error\": {\n\t\t\t\t\t\t\t\t\tconst error = TRPCClientError.from({ error: chunk.error });\n\t\t\t\t\t\t\t\t\tif (retryableRpcCodes.includes(chunk.error.code)) {\n\t\t\t\t\t\t\t\t\t\tconnectionState.next({\n\t\t\t\t\t\t\t\t\t\t\ttype: \"state\",\n\t\t\t\t\t\t\t\t\t\t\tstate: \"connecting\",\n\t\t\t\t\t\t\t\t\t\t\terror\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tthrow error;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcase \"connecting\": {\n\t\t\t\t\t\t\t\t\tconst lastState = connectionState.get();\n\t\t\t\t\t\t\t\t\tconst error = chunk.event && TRPCClientError.from(chunk.event);\n\t\t\t\t\t\t\t\t\tif (!error && lastState.state === \"connecting\") break;\n\t\t\t\t\t\t\t\t\tconnectionState.next({\n\t\t\t\t\t\t\t\t\t\ttype: \"state\",\n\t\t\t\t\t\t\t\t\t\tstate: \"connecting\",\n\t\t\t\t\t\t\t\t\t\terror\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcase \"timeout\": connectionState.next({\n\t\t\t\t\t\t\t\t\ttype: \"state\",\n\t\t\t\t\t\t\t\t\tstate: \"connecting\",\n\t\t\t\t\t\t\t\t\terror: new TRPCClientError(`Timeout of ${chunk.ms}ms reached while waiting for a response`)\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t_didIteratorError = true;\n\t\t\t\t\t\t_iteratorError = err;\n\t\t\t\t\t} finally {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (_iteratorAbruptCompletion && _iterator.return != null) await _iterator.return();\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tif (_didIteratorError) throw _iteratorError;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tobserver.next({ result: { type: \"stopped\" } });\n\t\t\t\t\tconnectionState.next({\n\t\t\t\t\t\ttype: \"state\",\n\t\t\t\t\t\tstate: \"idle\",\n\t\t\t\t\t\terror: null\n\t\t\t\t\t});\n\t\t\t\t\tobserver.complete();\n\t\t\t\t}).catch((error) => {\n\t\t\t\t\tobserver.error(TRPCClientError.from(error));\n\t\t\t\t});\n\t\t\t\treturn () => {\n\t\t\t\t\tobserver.complete();\n\t\t\t\t\tac.abort();\n\t\t\t\t\tconnectionSub.unsubscribe();\n\t\t\t\t};\n\t\t\t});\n\t\t};\n\t};\n}\n/**\n* @deprecated use {@link httpSubscriptionLink} instead\n*/\nconst unstable_httpSubscriptionLink = httpSubscriptionLink;\n\n//#endregion\n//#region src/links/retryLink.ts\nvar import_objectSpread2$1 = __toESM(require_objectSpread2(), 1);\n/**\n* @see https://trpc.io/docs/v11/client/links/retryLink\n*/\nfunction retryLink(opts) {\n\treturn () => {\n\t\treturn (callOpts) => {\n\t\t\treturn observable((observer) => {\n\t\t\t\tlet next$;\n\t\t\t\tlet callNextTimeout = void 0;\n\t\t\t\tlet lastEventId = void 0;\n\t\t\t\tattempt(1);\n\t\t\t\tfunction opWithLastEventId() {\n\t\t\t\t\tconst op = callOpts.op;\n\t\t\t\t\tif (!lastEventId) return op;\n\t\t\t\t\treturn (0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, op), {}, { input: inputWithTrackedEventId(op.input, lastEventId) });\n\t\t\t\t}\n\t\t\t\tfunction attempt(attempts) {\n\t\t\t\t\tconst op = opWithLastEventId();\n\t\t\t\t\tnext$ = callOpts.next(op).subscribe({\n\t\t\t\t\t\terror(error) {\n\t\t\t\t\t\t\tvar _opts$retryDelayMs, _opts$retryDelayMs2;\n\t\t\t\t\t\t\tconst shouldRetry = opts.retry({\n\t\t\t\t\t\t\t\top,\n\t\t\t\t\t\t\t\tattempts,\n\t\t\t\t\t\t\t\terror\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tif (!shouldRetry) {\n\t\t\t\t\t\t\t\tobserver.error(error);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst delayMs = (_opts$retryDelayMs = (_opts$retryDelayMs2 = opts.retryDelayMs) === null || _opts$retryDelayMs2 === void 0 ? void 0 : _opts$retryDelayMs2.call(opts, attempts)) !== null && _opts$retryDelayMs !== void 0 ? _opts$retryDelayMs : 0;\n\t\t\t\t\t\t\tif (delayMs <= 0) {\n\t\t\t\t\t\t\t\tattempt(attempts + 1);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcallNextTimeout = setTimeout(() => attempt(attempts + 1), delayMs);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tnext(envelope) {\n\t\t\t\t\t\t\tif ((!envelope.result.type || envelope.result.type === \"data\") && envelope.result.id) lastEventId = envelope.result.id;\n\t\t\t\t\t\t\tobserver.next(envelope);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcomplete() {\n\t\t\t\t\t\t\tobserver.complete();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn () => {\n\t\t\t\t\tnext$.unsubscribe();\n\t\t\t\t\tclearTimeout(callNextTimeout);\n\t\t\t\t};\n\t\t\t});\n\t\t};\n\t};\n}\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/usingCtx.js\nvar require_usingCtx = __commonJS({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/usingCtx.js\"(exports, module) {\n\tfunction _usingCtx() {\n\t\tvar r = \"function\" == typeof SuppressedError ? SuppressedError : function(r$1, e$1) {\n\t\t\tvar n$1 = Error();\n\t\t\treturn n$1.name = \"SuppressedError\", n$1.error = r$1, n$1.suppressed = e$1, n$1;\n\t\t}, e = {}, n = [];\n\t\tfunction using(r$1, e$1) {\n\t\t\tif (null != e$1) {\n\t\t\t\tif (Object(e$1) !== e$1) throw new TypeError(\"using declarations can only be used with objects, functions, null, or undefined.\");\n\t\t\t\tif (r$1) var o = e$1[Symbol.asyncDispose || Symbol[\"for\"](\"Symbol.asyncDispose\")];\n\t\t\t\tif (void 0 === o && (o = e$1[Symbol.dispose || Symbol[\"for\"](\"Symbol.dispose\")], r$1)) var t = o;\n\t\t\t\tif (\"function\" != typeof o) throw new TypeError(\"Object is not disposable.\");\n\t\t\t\tt && (o = function o$1() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tt.call(e$1);\n\t\t\t\t\t} catch (r$2) {\n\t\t\t\t\t\treturn Promise.reject(r$2);\n\t\t\t\t\t}\n\t\t\t\t}), n.push({\n\t\t\t\t\tv: e$1,\n\t\t\t\t\td: o,\n\t\t\t\t\ta: r$1\n\t\t\t\t});\n\t\t\t} else r$1 && n.push({\n\t\t\t\td: e$1,\n\t\t\t\ta: r$1\n\t\t\t});\n\t\t\treturn e$1;\n\t\t}\n\t\treturn {\n\t\t\te,\n\t\t\tu: using.bind(null, !1),\n\t\t\ta: using.bind(null, !0),\n\t\t\td: function d() {\n\t\t\t\tvar o, t = this.e, s = 0;\n\t\t\t\tfunction next() {\n\t\t\t\t\tfor (; o = n.pop();) try {\n\t\t\t\t\t\tif (!o.a && 1 === s) return s = 0, n.push(o), Promise.resolve().then(next);\n\t\t\t\t\t\tif (o.d) {\n\t\t\t\t\t\t\tvar r$1 = o.d.call(o.v);\n\t\t\t\t\t\t\tif (o.a) return s |= 2, Promise.resolve(r$1).then(next, err);\n\t\t\t\t\t\t} else s |= 1;\n\t\t\t\t\t} catch (r$2) {\n\t\t\t\t\t\treturn err(r$2);\n\t\t\t\t\t}\n\t\t\t\t\tif (1 === s) return t !== e ? Promise.reject(t) : Promise.resolve();\n\t\t\t\t\tif (t !== e) throw t;\n\t\t\t\t}\n\t\t\t\tfunction err(n$1) {\n\t\t\t\t\treturn t = t !== e ? new r(n$1, t) : n$1, next();\n\t\t\t\t}\n\t\t\t\treturn next();\n\t\t\t}\n\t\t};\n\t}\n\tmodule.exports = _usingCtx, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n} });\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/OverloadYield.js\nvar require_OverloadYield = __commonJS({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/OverloadYield.js\"(exports, module) {\n\tfunction _OverloadYield(e, d) {\n\t\tthis.v = e, this.k = d;\n\t}\n\tmodule.exports = _OverloadYield, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n} });\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/awaitAsyncGenerator.js\nvar require_awaitAsyncGenerator = __commonJS({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/awaitAsyncGenerator.js\"(exports, module) {\n\tvar OverloadYield$1 = require_OverloadYield();\n\tfunction _awaitAsyncGenerator$1(e) {\n\t\treturn new OverloadYield$1(e, 0);\n\t}\n\tmodule.exports = _awaitAsyncGenerator$1, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n} });\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/wrapAsyncGenerator.js\nvar require_wrapAsyncGenerator = __commonJS({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/wrapAsyncGenerator.js\"(exports, module) {\n\tvar OverloadYield = require_OverloadYield();\n\tfunction _wrapAsyncGenerator$1(e) {\n\t\treturn function() {\n\t\t\treturn new AsyncGenerator(e.apply(this, arguments));\n\t\t};\n\t}\n\tfunction AsyncGenerator(e) {\n\t\tvar r, t;\n\t\tfunction resume(r$1, t$1) {\n\t\t\ttry {\n\t\t\t\tvar n = e[r$1](t$1), o = n.value, u = o instanceof OverloadYield;\n\t\t\t\tPromise.resolve(u ? o.v : o).then(function(t$2) {\n\t\t\t\t\tif (u) {\n\t\t\t\t\t\tvar i = \"return\" === r$1 ? \"return\" : \"next\";\n\t\t\t\t\t\tif (!o.k || t$2.done) return resume(i, t$2);\n\t\t\t\t\t\tt$2 = e[i](t$2).value;\n\t\t\t\t\t}\n\t\t\t\t\tsettle(n.done ? \"return\" : \"normal\", t$2);\n\t\t\t\t}, function(e$1) {\n\t\t\t\t\tresume(\"throw\", e$1);\n\t\t\t\t});\n\t\t\t} catch (e$1) {\n\t\t\t\tsettle(\"throw\", e$1);\n\t\t\t}\n\t\t}\n\t\tfunction settle(e$1, n) {\n\t\t\tswitch (e$1) {\n\t\t\t\tcase \"return\":\n\t\t\t\t\tr.resolve({\n\t\t\t\t\t\tvalue: n,\n\t\t\t\t\t\tdone: !0\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"throw\":\n\t\t\t\t\tr.reject(n);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault: r.resolve({\n\t\t\t\t\tvalue: n,\n\t\t\t\t\tdone: !1\n\t\t\t\t});\n\t\t\t}\n\t\t\t(r = r.next) ? resume(r.key, r.arg) : t = null;\n\t\t}\n\t\tthis._invoke = function(e$1, n) {\n\t\t\treturn new Promise(function(o, u) {\n\t\t\t\tvar i = {\n\t\t\t\t\tkey: e$1,\n\t\t\t\t\targ: n,\n\t\t\t\t\tresolve: o,\n\t\t\t\t\treject: u,\n\t\t\t\t\tnext: null\n\t\t\t\t};\n\t\t\t\tt ? t = t.next = i : (r = t = i, resume(e$1, n));\n\t\t\t});\n\t\t}, \"function\" != typeof e[\"return\"] && (this[\"return\"] = void 0);\n\t}\n\tAsyncGenerator.prototype[\"function\" == typeof Symbol && Symbol.asyncIterator || \"@@asyncIterator\"] = function() {\n\t\treturn this;\n\t}, AsyncGenerator.prototype.next = function(e) {\n\t\treturn this._invoke(\"next\", e);\n\t}, AsyncGenerator.prototype[\"throw\"] = function(e) {\n\t\treturn this._invoke(\"throw\", e);\n\t}, AsyncGenerator.prototype[\"return\"] = function(e) {\n\t\treturn this._invoke(\"return\", e);\n\t};\n\tmodule.exports = _wrapAsyncGenerator$1, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n} });\n\n//#endregion\n//#region src/links/localLink.ts\nvar import_usingCtx = __toESM(require_usingCtx(), 1);\nvar import_awaitAsyncGenerator = __toESM(require_awaitAsyncGenerator(), 1);\nvar import_wrapAsyncGenerator = __toESM(require_wrapAsyncGenerator(), 1);\nvar import_objectSpread2 = __toESM(require_objectSpread2(), 1);\n/**\n* localLink is a terminating link that allows you to make tRPC procedure calls directly in your application without going through HTTP.\n*\n* @see https://trpc.io/docs/links/localLink\n*/\nfunction unstable_localLink(opts) {\n\tconst transformer = getTransformer(opts.transformer);\n\tconst transformChunk = (chunk) => {\n\t\tif (opts.transformer) return chunk;\n\t\tif (chunk === void 0) return chunk;\n\t\tconst serialized = JSON.stringify(transformer.input.serialize(chunk));\n\t\tconst deserialized = JSON.parse(transformer.output.deserialize(serialized));\n\t\treturn deserialized;\n\t};\n\treturn () => ({ op }) => observable((observer) => {\n\t\tlet ctx = void 0;\n\t\tconst ac = new AbortController();\n\t\tconst signal = raceAbortSignals(op.signal, ac.signal);\n\t\tconst signalPromise = abortSignalToPromise(signal);\n\t\tsignalPromise.catch(() => {});\n\t\tlet input = op.input;\n\t\tasync function runProcedure(newInput) {\n\t\t\tinput = newInput;\n\t\t\tctx = await opts.createContext();\n\t\t\treturn callProcedure({\n\t\t\t\trouter: opts.router,\n\t\t\t\tpath: op.path,\n\t\t\t\tgetRawInput: async () => newInput,\n\t\t\t\tctx,\n\t\t\t\ttype: op.type,\n\t\t\t\tsignal\n\t\t\t});\n\t\t}\n\t\tfunction onErrorCallback(cause) {\n\t\t\tvar _opts$onError;\n\t\t\tif (isAbortError(cause)) return;\n\t\t\t(_opts$onError = opts.onError) === null || _opts$onError === void 0 || _opts$onError.call(opts, {\n\t\t\t\terror: getTRPCErrorFromUnknown(cause),\n\t\t\t\ttype: op.type,\n\t\t\t\tpath: op.path,\n\t\t\t\tinput,\n\t\t\t\tctx\n\t\t\t});\n\t\t}\n\t\tfunction coerceToTRPCClientError(cause) {\n\t\t\tif (isTRPCClientError(cause)) return cause;\n\t\t\tconst error = getTRPCErrorFromUnknown(cause);\n\t\t\tconst shape = getTRPCErrorShape({\n\t\t\t\tconfig: opts.router._def._config,\n\t\t\t\tctx,\n\t\t\t\terror,\n\t\t\t\tinput,\n\t\t\t\tpath: op.path,\n\t\t\t\ttype: op.type\n\t\t\t});\n\t\t\treturn TRPCClientError.from({ error: transformChunk(shape) });\n\t\t}\n\t\trun(async () => {\n\t\t\tswitch (op.type) {\n\t\t\t\tcase \"query\":\n\t\t\t\tcase \"mutation\": {\n\t\t\t\t\tconst result = await runProcedure(op.input);\n\t\t\t\t\tif (!isAsyncIterable(result)) {\n\t\t\t\t\t\tobserver.next({ result: { data: transformChunk(result) } });\n\t\t\t\t\t\tobserver.complete();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tobserver.next({ result: { data: (0, import_wrapAsyncGenerator.default)(function* () {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tvar _usingCtx$1 = (0, import_usingCtx.default)();\n\t\t\t\t\t\t\tconst iterator = _usingCtx$1.a(iteratorResource(result));\n\t\t\t\t\t\t\tconst _finally = _usingCtx$1.u(makeResource({}, () => {\n\t\t\t\t\t\t\t\tobserver.complete();\n\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\t\tconst res = yield (0, import_awaitAsyncGenerator.default)(Promise.race([iterator.next(), signalPromise]));\n\t\t\t\t\t\t\t\t\tif (res.done) return transformChunk(res.value);\n\t\t\t\t\t\t\t\t\tyield transformChunk(res.value);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (cause) {\n\t\t\t\t\t\t\t\tonErrorCallback(cause);\n\t\t\t\t\t\t\t\tthrow coerceToTRPCClientError(cause);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (_) {\n\t\t\t\t\t\t\t_usingCtx$1.e = _;\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tyield (0, import_awaitAsyncGenerator.default)(_usingCtx$1.d());\n\t\t\t\t\t\t}\n\t\t\t\t\t})() } });\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase \"subscription\": try {\n\t\t\t\t\tvar _usingCtx3 = (0, import_usingCtx.default)();\n\t\t\t\t\tconst connectionState = behaviorSubject({\n\t\t\t\t\t\ttype: \"state\",\n\t\t\t\t\t\tstate: \"connecting\",\n\t\t\t\t\t\terror: null\n\t\t\t\t\t});\n\t\t\t\t\tconst connectionSub = connectionState.subscribe({ next(state) {\n\t\t\t\t\t\tobserver.next({ result: state });\n\t\t\t\t\t} });\n\t\t\t\t\tlet lastEventId = void 0;\n\t\t\t\t\tconst _finally = _usingCtx3.u(makeResource({}, async () => {\n\t\t\t\t\t\tobserver.complete();\n\t\t\t\t\t\tconnectionState.next({\n\t\t\t\t\t\t\ttype: \"state\",\n\t\t\t\t\t\t\tstate: \"idle\",\n\t\t\t\t\t\t\terror: null\n\t\t\t\t\t\t});\n\t\t\t\t\t\tconnectionSub.unsubscribe();\n\t\t\t\t\t}));\n\t\t\t\t\twhile (true) try {\n\t\t\t\t\t\tvar _usingCtx4 = (0, import_usingCtx.default)();\n\t\t\t\t\t\tconst result = await runProcedure(inputWithTrackedEventId(op.input, lastEventId));\n\t\t\t\t\t\tif (!isAsyncIterable(result)) throw new Error(\"Expected an async iterable\");\n\t\t\t\t\t\tconst iterator = _usingCtx4.a(iteratorResource(result));\n\t\t\t\t\t\tobserver.next({ result: { type: \"started\" } });\n\t\t\t\t\t\tconnectionState.next({\n\t\t\t\t\t\t\ttype: \"state\",\n\t\t\t\t\t\t\tstate: \"pending\",\n\t\t\t\t\t\t\terror: null\n\t\t\t\t\t\t});\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tlet res;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tres = await Promise.race([iterator.next(), signalPromise]);\n\t\t\t\t\t\t\t} catch (cause) {\n\t\t\t\t\t\t\t\tif (isAbortError(cause)) return;\n\t\t\t\t\t\t\t\tconst error = getTRPCErrorFromUnknown(cause);\n\t\t\t\t\t\t\t\tif (!retryableRpcCodes.includes(TRPC_ERROR_CODES_BY_KEY[error.code])) throw coerceToTRPCClientError(error);\n\t\t\t\t\t\t\t\tonErrorCallback(error);\n\t\t\t\t\t\t\t\tconnectionState.next({\n\t\t\t\t\t\t\t\t\ttype: \"state\",\n\t\t\t\t\t\t\t\t\tstate: \"connecting\",\n\t\t\t\t\t\t\t\t\terror: coerceToTRPCClientError(error)\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (res.done) return;\n\t\t\t\t\t\t\tlet chunk;\n\t\t\t\t\t\t\tif (isTrackedEnvelope(res.value)) {\n\t\t\t\t\t\t\t\tlastEventId = res.value[0];\n\t\t\t\t\t\t\t\tchunk = {\n\t\t\t\t\t\t\t\t\tid: res.value[0],\n\t\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\t\tid: res.value[0],\n\t\t\t\t\t\t\t\t\t\tdata: res.value[1]\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t} else chunk = { data: res.value };\n\t\t\t\t\t\t\tobserver.next({ result: (0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, chunk), {}, { data: transformChunk(chunk.data) }) });\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (_) {\n\t\t\t\t\t\t_usingCtx4.e = _;\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tawait _usingCtx4.d();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t} catch (_) {\n\t\t\t\t\t_usingCtx3.e = _;\n\t\t\t\t} finally {\n\t\t\t\t\t_usingCtx3.d();\n\t\t\t\t}\n\t\t\t}\n\t\t}).catch((cause) => {\n\t\t\tonErrorCallback(cause);\n\t\t\tobserver.error(coerceToTRPCClientError(cause));\n\t\t});\n\t\treturn () => {\n\t\t\tac.abort();\n\t\t};\n\t});\n}\n/**\n* @deprecated Renamed to `unstable_localLink`. This alias will be removed in a future major release.\n*/\nconst experimental_localLink = unstable_localLink;\n\n//#endregion\nexport { TRPCClientError, TRPCUntypedClient, clientCallTypeToProcedureType, createTRPCClient, createTRPCClientProxy, createTRPCClient as createTRPCProxyClient, createTRPCUntypedClient, createWSClient, experimental_localLink, getFetch, getUntypedClient, httpBatchLink, httpBatchStreamLink, httpLink, httpSubscriptionLink, isFormData, isNonJsonSerializable, isOctetType, isTRPCClientError, loggerLink, retryLink, splitLink, unstable_httpBatchStreamLink, unstable_httpSubscriptionLink, unstable_localLink, wsLink };\n//# sourceMappingURL=index.mjs.map","export class DoubleIndexedKV {\n    constructor() {\n        this.keyToValue = new Map();\n        this.valueToKey = new Map();\n    }\n    set(key, value) {\n        this.keyToValue.set(key, value);\n        this.valueToKey.set(value, key);\n    }\n    getByKey(key) {\n        return this.keyToValue.get(key);\n    }\n    getByValue(value) {\n        return this.valueToKey.get(value);\n    }\n    clear() {\n        this.keyToValue.clear();\n        this.valueToKey.clear();\n    }\n}\n//# sourceMappingURL=double-indexed-kv.js.map","import { DoubleIndexedKV } from './double-indexed-kv.js';\nexport class Registry {\n    constructor(generateIdentifier) {\n        this.generateIdentifier = generateIdentifier;\n        this.kv = new DoubleIndexedKV();\n    }\n    register(value, identifier) {\n        if (this.kv.getByValue(value)) {\n            return;\n        }\n        if (!identifier) {\n            identifier = this.generateIdentifier(value);\n        }\n        this.kv.set(identifier, value);\n    }\n    clear() {\n        this.kv.clear();\n    }\n    getIdentifier(value) {\n        return this.kv.getByValue(value);\n    }\n    getValue(identifier) {\n        return this.kv.getByKey(identifier);\n    }\n}\n//# sourceMappingURL=registry.js.map","import { Registry } from './registry.js';\nexport class ClassRegistry extends Registry {\n    constructor() {\n        super(c => c.name);\n        this.classToAllowedProps = new Map();\n    }\n    register(value, options) {\n        if (typeof options === 'object') {\n            if (options.allowProps) {\n                this.classToAllowedProps.set(value, options.allowProps);\n            }\n            super.register(value, options.identifier);\n        }\n        else {\n            super.register(value, options);\n        }\n    }\n    getAllowedProps(value) {\n        return this.classToAllowedProps.get(value);\n    }\n}\n//# sourceMappingURL=class-registry.js.map","function valuesOfObj(record) {\n    if ('values' in Object) {\n        // eslint-disable-next-line es5/no-es6-methods\n        return Object.values(record);\n    }\n    const values = [];\n    // eslint-disable-next-line no-restricted-syntax\n    for (const key in record) {\n        if (record.hasOwnProperty(key)) {\n            values.push(record[key]);\n        }\n    }\n    return values;\n}\nexport function find(record, predicate) {\n    const values = valuesOfObj(record);\n    if ('find' in values) {\n        // eslint-disable-next-line es5/no-es6-methods\n        return values.find(predicate);\n    }\n    const valuesNotNever = values;\n    for (let i = 0; i < valuesNotNever.length; i++) {\n        const value = valuesNotNever[i];\n        if (predicate(value)) {\n            return value;\n        }\n    }\n    return undefined;\n}\nexport function forEach(record, run) {\n    Object.entries(record).forEach(([key, value]) => run(value, key));\n}\nexport function includes(arr, value) {\n    return arr.indexOf(value) !== -1;\n}\nexport function findArr(record, predicate) {\n    for (let i = 0; i < record.length; i++) {\n        const value = record[i];\n        if (predicate(value)) {\n            return value;\n        }\n    }\n    return undefined;\n}\n//# sourceMappingURL=util.js.map","import { find } from './util.js';\nexport class CustomTransformerRegistry {\n    constructor() {\n        this.transfomers = {};\n    }\n    register(transformer) {\n        this.transfomers[transformer.name] = transformer;\n    }\n    findApplicable(v) {\n        return find(this.transfomers, transformer => transformer.isApplicable(v));\n    }\n    findByName(name) {\n        return this.transfomers[name];\n    }\n}\n//# sourceMappingURL=custom-transformer-registry.js.map","const getType = (payload) => Object.prototype.toString.call(payload).slice(8, -1);\nexport const isUndefined = (payload) => typeof payload === 'undefined';\nexport const isNull = (payload) => payload === null;\nexport const isPlainObject = (payload) => {\n    if (typeof payload !== 'object' || payload === null)\n        return false;\n    if (payload === Object.prototype)\n        return false;\n    if (Object.getPrototypeOf(payload) === null)\n        return true;\n    return Object.getPrototypeOf(payload) === Object.prototype;\n};\nexport const isEmptyObject = (payload) => isPlainObject(payload) && Object.keys(payload).length === 0;\nexport const isArray = (payload) => Array.isArray(payload);\nexport const isString = (payload) => typeof payload === 'string';\nexport const isNumber = (payload) => typeof payload === 'number' && !isNaN(payload);\nexport const isBoolean = (payload) => typeof payload === 'boolean';\nexport const isRegExp = (payload) => payload instanceof RegExp;\nexport const isMap = (payload) => payload instanceof Map;\nexport const isSet = (payload) => payload instanceof Set;\nexport const isSymbol = (payload) => getType(payload) === 'Symbol';\nexport const isDate = (payload) => payload instanceof Date && !isNaN(payload.valueOf());\nexport const isError = (payload) => payload instanceof Error;\nexport const isNaNValue = (payload) => typeof payload === 'number' && isNaN(payload);\nexport const isPrimitive = (payload) => isBoolean(payload) ||\n    isNull(payload) ||\n    isUndefined(payload) ||\n    isNumber(payload) ||\n    isString(payload) ||\n    isSymbol(payload);\nexport const isBigint = (payload) => typeof payload === 'bigint';\nexport const isInfinite = (payload) => payload === Infinity || payload === -Infinity;\nexport const isTypedArray = (payload) => ArrayBuffer.isView(payload) && !(payload instanceof DataView);\nexport const isURL = (payload) => payload instanceof URL;\n//# sourceMappingURL=is.js.map","export const escapeKey = (key) => key.replace(/\\\\/g, '\\\\\\\\').replace(/\\./g, '\\\\.');\nexport const stringifyPath = (path) => path\n    .map(String)\n    .map(escapeKey)\n    .join('.');\nexport const parsePath = (string, legacyPaths) => {\n    const result = [];\n    let segment = '';\n    for (let i = 0; i < string.length; i++) {\n        let char = string.charAt(i);\n        if (!legacyPaths && char === '\\\\') {\n            const escaped = string.charAt(i + 1);\n            if (escaped === '\\\\') {\n                segment += '\\\\';\n                i++;\n                continue;\n            }\n            else if (escaped !== '.') {\n                throw Error('invalid path');\n            }\n        }\n        const isEscapedDot = char === '\\\\' && string.charAt(i + 1) === '.';\n        if (isEscapedDot) {\n            segment += '.';\n            i++;\n            continue;\n        }\n        const isEndOfSegment = char === '.';\n        if (isEndOfSegment) {\n            result.push(segment);\n            segment = '';\n            continue;\n        }\n        segment += char;\n    }\n    const lastSegment = segment;\n    result.push(lastSegment);\n    return result;\n};\n//# sourceMappingURL=pathstringifier.js.map","import { isBigint, isDate, isInfinite, isMap, isNaNValue, isRegExp, isSet, isUndefined, isSymbol, isArray, isError, isTypedArray, isURL, } from './is.js';\nimport { findArr } from './util.js';\nfunction simpleTransformation(isApplicable, annotation, transform, untransform) {\n    return {\n        isApplicable,\n        annotation,\n        transform,\n        untransform,\n    };\n}\nconst simpleRules = [\n    simpleTransformation(isUndefined, 'undefined', () => null, () => undefined),\n    simpleTransformation(isBigint, 'bigint', v => v.toString(), v => {\n        if (typeof BigInt !== 'undefined') {\n            return BigInt(v);\n        }\n        console.error('Please add a BigInt polyfill.');\n        return v;\n    }),\n    simpleTransformation(isDate, 'Date', v => v.toISOString(), v => new Date(v)),\n    simpleTransformation(isError, 'Error', (v, superJson) => {\n        const baseError = {\n            name: v.name,\n            message: v.message,\n        };\n        if ('cause' in v) {\n            baseError.cause = v.cause;\n        }\n        superJson.allowedErrorProps.forEach(prop => {\n            baseError[prop] = v[prop];\n        });\n        return baseError;\n    }, (v, superJson) => {\n        const e = new Error(v.message, { cause: v.cause });\n        e.name = v.name;\n        e.stack = v.stack;\n        superJson.allowedErrorProps.forEach(prop => {\n            e[prop] = v[prop];\n        });\n        return e;\n    }),\n    simpleTransformation(isRegExp, 'regexp', v => '' + v, regex => {\n        const body = regex.slice(1, regex.lastIndexOf('/'));\n        const flags = regex.slice(regex.lastIndexOf('/') + 1);\n        return new RegExp(body, flags);\n    }),\n    simpleTransformation(isSet, 'set', \n    // (sets only exist in es6+)\n    // eslint-disable-next-line es5/no-es6-methods\n    v => [...v.values()], v => new Set(v)),\n    simpleTransformation(isMap, 'map', v => [...v.entries()], v => new Map(v)),\n    simpleTransformation((v) => isNaNValue(v) || isInfinite(v), 'number', v => {\n        if (isNaNValue(v)) {\n            return 'NaN';\n        }\n        if (v > 0) {\n            return 'Infinity';\n        }\n        else {\n            return '-Infinity';\n        }\n    }, Number),\n    simpleTransformation((v) => v === 0 && 1 / v === -Infinity, 'number', () => {\n        return '-0';\n    }, Number),\n    simpleTransformation(isURL, 'URL', v => v.toString(), v => new URL(v)),\n];\nfunction compositeTransformation(isApplicable, annotation, transform, untransform) {\n    return {\n        isApplicable,\n        annotation,\n        transform,\n        untransform,\n    };\n}\nconst symbolRule = compositeTransformation((s, superJson) => {\n    if (isSymbol(s)) {\n        const isRegistered = !!superJson.symbolRegistry.getIdentifier(s);\n        return isRegistered;\n    }\n    return false;\n}, (s, superJson) => {\n    const identifier = superJson.symbolRegistry.getIdentifier(s);\n    return ['symbol', identifier];\n}, v => v.description, (_, a, superJson) => {\n    const value = superJson.symbolRegistry.getValue(a[1]);\n    if (!value) {\n        throw new Error('Trying to deserialize unknown symbol');\n    }\n    return value;\n});\nconst constructorToName = [\n    Int8Array,\n    Uint8Array,\n    Int16Array,\n    Uint16Array,\n    Int32Array,\n    Uint32Array,\n    Float32Array,\n    Float64Array,\n    Uint8ClampedArray,\n].reduce((obj, ctor) => {\n    obj[ctor.name] = ctor;\n    return obj;\n}, {});\nconst typedArrayRule = compositeTransformation(isTypedArray, v => ['typed-array', v.constructor.name], v => [...v], (v, a) => {\n    const ctor = constructorToName[a[1]];\n    if (!ctor) {\n        throw new Error('Trying to deserialize unknown typed array');\n    }\n    return new ctor(v);\n});\nexport function isInstanceOfRegisteredClass(potentialClass, superJson) {\n    if (potentialClass?.constructor) {\n        const isRegistered = !!superJson.classRegistry.getIdentifier(potentialClass.constructor);\n        return isRegistered;\n    }\n    return false;\n}\nconst classRule = compositeTransformation(isInstanceOfRegisteredClass, (clazz, superJson) => {\n    const identifier = superJson.classRegistry.getIdentifier(clazz.constructor);\n    return ['class', identifier];\n}, (clazz, superJson) => {\n    const allowedProps = superJson.classRegistry.getAllowedProps(clazz.constructor);\n    if (!allowedProps) {\n        return { ...clazz };\n    }\n    const result = {};\n    allowedProps.forEach(prop => {\n        result[prop] = clazz[prop];\n    });\n    return result;\n}, (v, a, superJson) => {\n    const clazz = superJson.classRegistry.getValue(a[1]);\n    if (!clazz) {\n        throw new Error(`Trying to deserialize unknown class '${a[1]}' - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564`);\n    }\n    return Object.assign(Object.create(clazz.prototype), v);\n});\nconst customRule = compositeTransformation((value, superJson) => {\n    return !!superJson.customTransformerRegistry.findApplicable(value);\n}, (value, superJson) => {\n    const transformer = superJson.customTransformerRegistry.findApplicable(value);\n    return ['custom', transformer.name];\n}, (value, superJson) => {\n    const transformer = superJson.customTransformerRegistry.findApplicable(value);\n    return transformer.serialize(value);\n}, (v, a, superJson) => {\n    const transformer = superJson.customTransformerRegistry.findByName(a[1]);\n    if (!transformer) {\n        throw new Error('Trying to deserialize unknown custom value');\n    }\n    return transformer.deserialize(v);\n});\nconst compositeRules = [classRule, symbolRule, customRule, typedArrayRule];\nexport const transformValue = (value, superJson) => {\n    const applicableCompositeRule = findArr(compositeRules, rule => rule.isApplicable(value, superJson));\n    if (applicableCompositeRule) {\n        return {\n            value: applicableCompositeRule.transform(value, superJson),\n            type: applicableCompositeRule.annotation(value, superJson),\n        };\n    }\n    const applicableSimpleRule = findArr(simpleRules, rule => rule.isApplicable(value, superJson));\n    if (applicableSimpleRule) {\n        return {\n            value: applicableSimpleRule.transform(value, superJson),\n            type: applicableSimpleRule.annotation,\n        };\n    }\n    return undefined;\n};\nconst simpleRulesByAnnotation = {};\nsimpleRules.forEach(rule => {\n    simpleRulesByAnnotation[rule.annotation] = rule;\n});\nexport const untransformValue = (json, type, superJson) => {\n    if (isArray(type)) {\n        switch (type[0]) {\n            case 'symbol':\n                return symbolRule.untransform(json, type, superJson);\n            case 'class':\n                return classRule.untransform(json, type, superJson);\n            case 'custom':\n                return customRule.untransform(json, type, superJson);\n            case 'typed-array':\n                return typedArrayRule.untransform(json, type, superJson);\n            default:\n                throw new Error('Unknown transformation: ' + type);\n        }\n    }\n    else {\n        const transformation = simpleRulesByAnnotation[type];\n        if (!transformation) {\n            throw new Error('Unknown transformation: ' + type);\n        }\n        return transformation.untransform(json, superJson);\n    }\n};\n//# sourceMappingURL=transformer.js.map","import { isMap, isArray, isPlainObject, isSet } from './is.js';\nimport { includes } from './util.js';\nconst getNthKey = (value, n) => {\n    if (n > value.size)\n        throw new Error('index out of bounds');\n    const keys = value.keys();\n    while (n > 0) {\n        keys.next();\n        n--;\n    }\n    return keys.next().value;\n};\nfunction validatePath(path) {\n    if (includes(path, '__proto__')) {\n        throw new Error('__proto__ is not allowed as a property');\n    }\n    if (includes(path, 'prototype')) {\n        throw new Error('prototype is not allowed as a property');\n    }\n    if (includes(path, 'constructor')) {\n        throw new Error('constructor is not allowed as a property');\n    }\n}\nexport const getDeep = (object, path) => {\n    validatePath(path);\n    for (let i = 0; i < path.length; i++) {\n        const key = path[i];\n        if (isSet(object)) {\n            object = getNthKey(object, +key);\n        }\n        else if (isMap(object)) {\n            const row = +key;\n            const type = +path[++i] === 0 ? 'key' : 'value';\n            const keyOfRow = getNthKey(object, row);\n            switch (type) {\n                case 'key':\n                    object = keyOfRow;\n                    break;\n                case 'value':\n                    object = object.get(keyOfRow);\n                    break;\n            }\n        }\n        else {\n            object = object[key];\n        }\n    }\n    return object;\n};\nexport const setDeep = (object, path, mapper) => {\n    validatePath(path);\n    if (path.length === 0) {\n        return mapper(object);\n    }\n    let parent = object;\n    for (let i = 0; i < path.length - 1; i++) {\n        const key = path[i];\n        if (isArray(parent)) {\n            const index = +key;\n            parent = parent[index];\n        }\n        else if (isPlainObject(parent)) {\n            parent = parent[key];\n        }\n        else if (isSet(parent)) {\n            const row = +key;\n            parent = getNthKey(parent, row);\n        }\n        else if (isMap(parent)) {\n            const isEnd = i === path.length - 2;\n            if (isEnd) {\n                break;\n            }\n            const row = +key;\n            const type = +path[++i] === 0 ? 'key' : 'value';\n            const keyOfRow = getNthKey(parent, row);\n            switch (type) {\n                case 'key':\n                    parent = keyOfRow;\n                    break;\n                case 'value':\n                    parent = parent.get(keyOfRow);\n                    break;\n            }\n        }\n    }\n    const lastKey = path[path.length - 1];\n    if (isArray(parent)) {\n        parent[+lastKey] = mapper(parent[+lastKey]);\n    }\n    else if (isPlainObject(parent)) {\n        parent[lastKey] = mapper(parent[lastKey]);\n    }\n    if (isSet(parent)) {\n        const oldValue = getNthKey(parent, +lastKey);\n        const newValue = mapper(oldValue);\n        if (oldValue !== newValue) {\n            parent.delete(oldValue);\n            parent.add(newValue);\n        }\n    }\n    if (isMap(parent)) {\n        const row = +path[path.length - 2];\n        const keyToRow = getNthKey(parent, row);\n        const type = +lastKey === 0 ? 'key' : 'value';\n        switch (type) {\n            case 'key': {\n                const newKey = mapper(keyToRow);\n                parent.set(newKey, parent.get(keyToRow));\n                if (newKey !== keyToRow) {\n                    parent.delete(keyToRow);\n                }\n                break;\n            }\n            case 'value': {\n                parent.set(keyToRow, mapper(parent.get(keyToRow)));\n                break;\n            }\n        }\n    }\n    return object;\n};\n//# sourceMappingURL=accessDeep.js.map","import { isArray, isEmptyObject, isError, isMap, isPlainObject, isPrimitive, isSet, } from './is.js';\nimport { escapeKey, stringifyPath } from './pathstringifier.js';\nimport { isInstanceOfRegisteredClass, transformValue, untransformValue, } from './transformer.js';\nimport { includes, forEach } from './util.js';\nimport { parsePath } from './pathstringifier.js';\nimport { getDeep, setDeep } from './accessDeep.js';\nconst enableLegacyPaths = (version) => version < 1;\nfunction traverse(tree, walker, version, origin = []) {\n    if (!tree) {\n        return;\n    }\n    const legacyPaths = enableLegacyPaths(version);\n    if (!isArray(tree)) {\n        forEach(tree, (subtree, key) => traverse(subtree, walker, version, [\n            ...origin,\n            ...parsePath(key, legacyPaths),\n        ]));\n        return;\n    }\n    const [nodeValue, children] = tree;\n    if (children) {\n        forEach(children, (child, key) => {\n            traverse(child, walker, version, [\n                ...origin,\n                ...parsePath(key, legacyPaths),\n            ]);\n        });\n    }\n    walker(nodeValue, origin);\n}\nexport function applyValueAnnotations(plain, annotations, version, superJson) {\n    traverse(annotations, (type, path) => {\n        plain = setDeep(plain, path, v => untransformValue(v, type, superJson));\n    }, version);\n    return plain;\n}\nexport function applyReferentialEqualityAnnotations(plain, annotations, version) {\n    const legacyPaths = enableLegacyPaths(version);\n    function apply(identicalPaths, path) {\n        const object = getDeep(plain, parsePath(path, legacyPaths));\n        identicalPaths\n            .map(path => parsePath(path, legacyPaths))\n            .forEach(identicalObjectPath => {\n            plain = setDeep(plain, identicalObjectPath, () => object);\n        });\n    }\n    if (isArray(annotations)) {\n        const [root, other] = annotations;\n        root.forEach(identicalPath => {\n            plain = setDeep(plain, parsePath(identicalPath, legacyPaths), () => plain);\n        });\n        if (other) {\n            forEach(other, apply);\n        }\n    }\n    else {\n        forEach(annotations, apply);\n    }\n    return plain;\n}\nconst isDeep = (object, superJson) => isPlainObject(object) ||\n    isArray(object) ||\n    isMap(object) ||\n    isSet(object) ||\n    isError(object) ||\n    isInstanceOfRegisteredClass(object, superJson);\nfunction addIdentity(object, path, identities) {\n    const existingSet = identities.get(object);\n    if (existingSet) {\n        existingSet.push(path);\n    }\n    else {\n        identities.set(object, [path]);\n    }\n}\nexport function generateReferentialEqualityAnnotations(identitites, dedupe) {\n    const result = {};\n    let rootEqualityPaths = undefined;\n    identitites.forEach(paths => {\n        if (paths.length <= 1) {\n            return;\n        }\n        // if we're not deduping, all of these objects continue existing.\n        // putting the shortest path first makes it easier to parse for humans\n        // if we're deduping though, only the first entry will still exist, so we can't do this optimisation.\n        if (!dedupe) {\n            paths = paths\n                .map(path => path.map(String))\n                .sort((a, b) => a.length - b.length);\n        }\n        const [representativePath, ...identicalPaths] = paths;\n        if (representativePath.length === 0) {\n            rootEqualityPaths = identicalPaths.map(stringifyPath);\n        }\n        else {\n            result[stringifyPath(representativePath)] = identicalPaths.map(stringifyPath);\n        }\n    });\n    if (rootEqualityPaths) {\n        if (isEmptyObject(result)) {\n            return [rootEqualityPaths];\n        }\n        else {\n            return [rootEqualityPaths, result];\n        }\n    }\n    else {\n        return isEmptyObject(result) ? undefined : result;\n    }\n}\nexport const walker = (object, identities, superJson, dedupe, path = [], objectsInThisPath = [], seenObjects = new Map()) => {\n    const primitive = isPrimitive(object);\n    if (!primitive) {\n        addIdentity(object, path, identities);\n        const seen = seenObjects.get(object);\n        if (seen) {\n            // short-circuit result if we've seen this object before\n            return dedupe\n                ? {\n                    transformedValue: null,\n                }\n                : seen;\n        }\n    }\n    if (!isDeep(object, superJson)) {\n        const transformed = transformValue(object, superJson);\n        const result = transformed\n            ? {\n                transformedValue: transformed.value,\n                annotations: [transformed.type],\n            }\n            : {\n                transformedValue: object,\n            };\n        if (!primitive) {\n            seenObjects.set(object, result);\n        }\n        return result;\n    }\n    if (includes(objectsInThisPath, object)) {\n        // prevent circular references\n        return {\n            transformedValue: null,\n        };\n    }\n    const transformationResult = transformValue(object, superJson);\n    const transformed = transformationResult?.value ?? object;\n    const transformedValue = isArray(transformed) ? [] : {};\n    const innerAnnotations = {};\n    forEach(transformed, (value, index) => {\n        if (index === '__proto__' ||\n            index === 'constructor' ||\n            index === 'prototype') {\n            throw new Error(`Detected property ${index}. This is a prototype pollution risk, please remove it from your object.`);\n        }\n        const recursiveResult = walker(value, identities, superJson, dedupe, [...path, index], [...objectsInThisPath, object], seenObjects);\n        transformedValue[index] = recursiveResult.transformedValue;\n        if (isArray(recursiveResult.annotations)) {\n            innerAnnotations[escapeKey(index)] = recursiveResult.annotations;\n        }\n        else if (isPlainObject(recursiveResult.annotations)) {\n            forEach(recursiveResult.annotations, (tree, key) => {\n                innerAnnotations[escapeKey(index) + '.' + key] = tree;\n            });\n        }\n    });\n    const result = isEmptyObject(innerAnnotations)\n        ? {\n            transformedValue,\n            annotations: !!transformationResult\n                ? [transformationResult.type]\n                : undefined,\n        }\n        : {\n            transformedValue,\n            annotations: !!transformationResult\n                ? [transformationResult.type, innerAnnotations]\n                : innerAnnotations,\n        };\n    if (!primitive) {\n        seenObjects.set(object, result);\n    }\n    return result;\n};\n//# sourceMappingURL=plainer.js.map","/** Returns the object type of the given payload */\nexport function getType(payload) {\n    return Object.prototype.toString.call(payload).slice(8, -1);\n}\n","import { getType } from './getType.js';\n/** Returns whether the payload is an array */\nexport function isArray(payload) {\n    return getType(payload) === 'Array';\n}\n","import { getType } from './getType.js';\n/**\n * Returns whether the payload is a plain JavaScript object (excluding special classes or objects\n * with other prototypes)\n */\nexport function isPlainObject(payload) {\n    if (getType(payload) !== 'Object')\n        return false;\n    const prototype = Object.getPrototypeOf(payload);\n    return !!prototype && prototype.constructor === Object && prototype === Object.prototype;\n}\n","import { isArray, isPlainObject } from 'is-what';\nfunction assignProp(carry, key, newVal, originalObject, includeNonenumerable) {\n    const propType = {}.propertyIsEnumerable.call(originalObject, key)\n        ? 'enumerable'\n        : 'nonenumerable';\n    if (propType === 'enumerable')\n        carry[key] = newVal;\n    if (includeNonenumerable && propType === 'nonenumerable') {\n        Object.defineProperty(carry, key, {\n            value: newVal,\n            enumerable: false,\n            writable: true,\n            configurable: true,\n        });\n    }\n}\n/**\n * Copy (clone) an object and all its props recursively to get rid of any prop referenced of the\n * original object. Arrays are also cloned, however objects inside arrays are still linked.\n *\n * @param target Target can be anything\n * @param [options={}] See type {@link Options} for more details.\n *\n *   - `{ props: ['key1'] }` will only copy the `key1` property. When using this you will need to cast\n *       the return type manually (in order to keep the TS implementation in here simple I didn't\n *       built a complex auto resolved type for those few cases people want to use this option)\n *   - `{ nonenumerable: true }` will copy all non-enumerable properties. Default is `{}`\n *\n * @returns The target with replaced values\n */\nexport function copy(target, options = {}) {\n    if (isArray(target)) {\n        return target.map((item) => copy(item, options));\n    }\n    if (!isPlainObject(target)) {\n        return target;\n    }\n    const props = Object.getOwnPropertyNames(target);\n    const symbols = Object.getOwnPropertySymbols(target);\n    return [...props, ...symbols].reduce((carry, key) => {\n        // Skip __proto__ properties to prevent prototype pollution\n        if (key === '__proto__')\n            return carry;\n        if (isArray(options.props) && !options.props.includes(key)) {\n            return carry;\n        }\n        const val = target[key];\n        const newVal = copy(val, options);\n        assignProp(carry, key, newVal, target, options.nonenumerable);\n        return carry;\n    }, {});\n}\n","import { ClassRegistry } from './class-registry.js';\nimport { Registry } from './registry.js';\nimport { CustomTransformerRegistry, } from './custom-transformer-registry.js';\nimport { applyReferentialEqualityAnnotations, applyValueAnnotations, generateReferentialEqualityAnnotations, walker, } from './plainer.js';\nimport { copy } from 'copy-anything';\nclass SuperJSON {\n    /**\n     * @param dedupeReferentialEqualities  If true, SuperJSON will make sure only one instance of referentially equal objects are serialized and the rest are replaced with `null`.\n     */\n    constructor({ dedupe = false, } = {}) {\n        this.classRegistry = new ClassRegistry();\n        this.symbolRegistry = new Registry(s => s.description ?? '');\n        this.customTransformerRegistry = new CustomTransformerRegistry();\n        this.allowedErrorProps = [];\n        this.dedupe = dedupe;\n    }\n    serialize(object) {\n        const identities = new Map();\n        const output = walker(object, identities, this, this.dedupe);\n        const res = {\n            json: output.transformedValue,\n        };\n        if (output.annotations) {\n            res.meta = {\n                ...res.meta,\n                values: output.annotations,\n            };\n        }\n        const equalityAnnotations = generateReferentialEqualityAnnotations(identities, this.dedupe);\n        if (equalityAnnotations) {\n            res.meta = {\n                ...res.meta,\n                referentialEqualities: equalityAnnotations,\n            };\n        }\n        if (res.meta)\n            res.meta.v = 1;\n        return res;\n    }\n    deserialize(payload, options) {\n        const { json, meta } = payload;\n        let result = options?.inPlace ? json : copy(json);\n        if (meta?.values) {\n            result = applyValueAnnotations(result, meta.values, meta.v ?? 0, this);\n        }\n        if (meta?.referentialEqualities) {\n            result = applyReferentialEqualityAnnotations(result, meta.referentialEqualities, meta.v ?? 0);\n        }\n        return result;\n    }\n    stringify(object) {\n        return JSON.stringify(this.serialize(object));\n    }\n    parse(string) {\n        return this.deserialize(JSON.parse(string), { inPlace: true });\n    }\n    registerClass(v, options) {\n        this.classRegistry.register(v, options);\n    }\n    registerSymbol(v, identifier) {\n        this.symbolRegistry.register(v, identifier);\n    }\n    registerCustom(transformer, name) {\n        this.customTransformerRegistry.register({\n            name,\n            ...transformer,\n        });\n    }\n    allowErrorProps(...props) {\n        this.allowedErrorProps.push(...props);\n    }\n}\nSuperJSON.defaultInstance = new SuperJSON();\nSuperJSON.serialize = SuperJSON.defaultInstance.serialize.bind(SuperJSON.defaultInstance);\nSuperJSON.deserialize = SuperJSON.defaultInstance.deserialize.bind(SuperJSON.defaultInstance);\nSuperJSON.stringify = SuperJSON.defaultInstance.stringify.bind(SuperJSON.defaultInstance);\nSuperJSON.parse = SuperJSON.defaultInstance.parse.bind(SuperJSON.defaultInstance);\nSuperJSON.registerClass = SuperJSON.defaultInstance.registerClass.bind(SuperJSON.defaultInstance);\nSuperJSON.registerSymbol = SuperJSON.defaultInstance.registerSymbol.bind(SuperJSON.defaultInstance);\nSuperJSON.registerCustom = SuperJSON.defaultInstance.registerCustom.bind(SuperJSON.defaultInstance);\nSuperJSON.allowErrorProps = SuperJSON.defaultInstance.allowErrorProps.bind(SuperJSON.defaultInstance);\nexport default SuperJSON;\nexport { SuperJSON };\nexport const serialize = SuperJSON.serialize;\nexport const deserialize = SuperJSON.deserialize;\nexport const stringify = SuperJSON.stringify;\nexport const parse = SuperJSON.parse;\nexport const registerClass = SuperJSON.registerClass;\nexport const registerCustom = SuperJSON.registerCustom;\nexport const registerSymbol = SuperJSON.registerSymbol;\nexport const allowErrorProps = SuperJSON.allowErrorProps;\n//# sourceMappingURL=index.js.map","/**\n * If you need to add transformers for special data types like `Temporal.Instant` or `Temporal.Date`, `Decimal.js`, etc you can do so here.\n * Make sure to import this file rather than `superjson` directly.\n * @see https://github.com/blitz-js/superjson#recipes\n */\nimport superjson from 'superjson';\n\nexport const transformer = superjson;\n","import { createTRPCClient, httpBatchStreamLink } from '@trpc/client';\nimport type { AppRouter } from '../server/trpc';\nimport { transformer } from '../shared/transformer';\n\nexport const trpc = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchStreamLink({\n      url: '/api/trpc',\n      transformer,\n    }),\n  ],\n});\n","import './index.css';\n\nimport { StrictMode, useEffect, useState } from 'react';\nimport { createRoot } from 'react-dom/client';\nimport { navigateTo } from '@devvit/web/client';\nimport { trpc } from './trpc';\nimport type { inferRouterOutputs } from '@trpc/server';\nimport type { AppRouter } from '../server/trpc';\n\ntype RouterOutputs = inferRouterOutputs<AppRouter>;\n\nexport const App = () => {\n  const [init, setInit] = useState<RouterOutputs['init']['get'] | null>(null);\n\n  const fetchInit = async () => {\n    const data = await trpc.init.get.query();\n    setInit(data);\n  };\n\n  useEffect(() => {\n    // eslint-disable-next-line react-hooks/set-state-in-effect\n    void fetchInit();\n  }, []);\n\n  const [loading, setLoading] = useState(false);\n  const { username, count } = init ?? { count: 0 };\n\n  const increment = async () => {\n    setLoading(true);\n    const result = await trpc.counter.increment.mutate();\n    setInit((prev) => (prev ? { ...prev, count: result.count } : null));\n    setLoading(false);\n  };\n\n  const decrement = async () => {\n    setLoading(true);\n    const result = await trpc.counter.decrement.mutate();\n    setInit((prev) => (prev ? { ...prev, count: result.count } : null));\n    setLoading(false);\n  };\n\n  return (\n    <div className=\"relative flex min-h-screen flex-col items-center justify-center gap-4\">\n      <img\n        className=\"mx-auto w-1/2 max-w-[250px] object-contain\"\n        src=\"/snoo.png\"\n        alt=\"Snoo\"\n      />\n      <div className=\"flex flex-col items-center gap-2\">\n        <h1 className=\"text-center text-2xl font-bold text-gray-900\">\n          {username ? `Hey ${username} ` : ''}\n        </h1>\n        <p className=\"text-center text-base text-gray-600\">\n          Edit{' '}\n          <span className=\"rounded bg-[#e5ebee] px-1 py-0.5\">\n            src/client/game.tsx\n          </span>{' '}\n          to get started.\n        </p>\n      </div>\n      <div className=\"mt-5 flex items-center justify-center\">\n        <button\n          className=\"flex h-14 w-14 cursor-pointer items-center justify-center rounded-full bg-[#d93900] font-mono text-[2.5em] leading-none text-white transition-colors\"\n          onClick={decrement}\n          disabled={loading}\n        >\n          -\n        </button>\n        <span className=\"mx-5 min-w-[50px] text-center text-[1.8em] leading-none font-medium text-gray-900\">\n          {loading ? '...' : count}\n        </span>\n        <button\n          className=\"flex h-14 w-14 cursor-pointer items-center justify-center rounded-full bg-[#d93900] font-mono text-[2.5em] leading-none text-white transition-colors\"\n          onClick={increment}\n          disabled={loading}\n        >\n          +\n        </button>\n      </div>\n      <footer className=\"absolute bottom-4 left-1/2 flex -translate-x-1/2 gap-3 text-[0.8em] text-gray-600\">\n        <button\n          className=\"cursor-pointer\"\n          onClick={() => navigateTo('https://developers.reddit.com/docs')}\n        >\n          Docs\n        </button>\n        <span className=\"text-gray-300\">|</span>\n        <button\n          className=\"cursor-pointer\"\n          onClick={() => navigateTo('https://www.reddit.com/r/Devvit')}\n        >\n          r/Devvit\n        </button>\n        <span className=\"text-gray-300\">|</span>\n        <button\n          className=\"cursor-pointer\"\n          onClick={() => navigateTo('https://discord.com/invite/R7yu2wh9Qz')}\n        >\n          Discord\n        </button>\n      </footer>\n    </div>\n  );\n};\n\ncreateRoot(document.getElementById('root')!).render(\n  <StrictMode>\n    <App />\n  </StrictMode>\n);\n"],"names":["__create","__defProp","__getOwnPropDesc","__getOwnPropNames","__getProtoOf","__hasOwnProp","__commonJS","cb","mod","__copyProps","to","from","except","desc","keys","i","n","key","k","__toESM","isNodeMode","target","require_typeof","exports","module","_typeof$2","o","o$1","require_toPrimitive","_typeof$1","toPrimitive$1","t","r","e","require_toPropertyKey","_typeof","toPrimitive","toPropertyKey$1","require_defineProperty","toPropertyKey","_defineProperty","require_objectSpread2","defineProperty","ownKeys","r$1","_objectSpread2","observable","subscribe","self","observer","teardownRef","isDone","unsubscribed","teardownImmediately","unsubscribe","value","_observer$next","err","_observer$error","_observer$complete","operations","pipeReducer","prev","fn","observableToPromise","observable$1","ac","resolve","reject","onDone","obs$","data","share","_opts","source","refCount","subscription","observers","startIfNeeded","error","resetIfNeeded","_sub","subscriber","index","v","behaviorSubject","initialValue","observerList","addObserver","removeObserver","obs","nextValue","createChain","opts","execute","op","next","nextOp","isObject","emptyObject","run","noop","freezeIfAvailable","obj","createInnerProxy","callback","path","memo","_memo$cacheKey","cacheKey","_obj","_1","_2","args","lastOfPath","createRecursiveProxy","createFlatProxy","name","_Symbol","_Symbol$dispose","_Symbol2","_Symbol2$asyncDispose","makeResource","thing","dispose","it","existing","require_usingCtx","_usingCtx","e$1","n$1","using","r$2","s","require_OverloadYield","_OverloadYield","d","require_awaitAsyncGenerator","OverloadYield$2","_awaitAsyncGenerator$5","require_wrapAsyncGenerator","OverloadYield$1","_wrapAsyncGenerator$6","AsyncGenerator","resume","t$1","u","t$2","settle","createDeferred","res","rej","require_asyncIterator","_asyncIterator$2","AsyncFromSyncIterator","AsyncFromSyncIteratorContinuation","import_awaitAsyncGenerator$1","import_wrapAsyncGenerator$2","import_usingCtx$1","CHUNK_VALUE_TYPE_PROMISE","CHUNK_VALUE_TYPE_ASYNC_ITERABLE","PROMISE_STATUS_FULFILLED","PROMISE_STATUS_REJECTED","ASYNC_ITERABLE_STATUS_RETURN","ASYNC_ITERABLE_STATUS_YIELD","ASYNC_ITERABLE_STATUS_ERROR","AsyncError","nodeJsStreamToReaderEsque","controller","chunk","createLineAccumulator","reader","lineAggregate","done","_parts$pop","parts","part","createConsumerStream","stream","sentHead","line","head","createStreamsManager","abortController","controllerMap","isEmpty","c","createStreamController","originalController","streamController","clear","reason","getOrCreate","chunkId","cancelAll","jsonlStreamConsumer","deserialize","headDeferred","streamManager","decodeChunkDefinition","_path","type","_usingCtx3","value$1","_chunkId","status","decode","_opts$formatError3","_opts$formatError4","_","_usingCtx4","_opts$formatError5","_opts$formatError6","asyncProps","decoded","closeOrAbort","chunkOrHead","parsed","idx","_opts$onError4","require_asyncGeneratorDelegate","OverloadYield","_asyncGeneratorDelegate$1","pump","import_defineProperty","import_objectSpread2","isTRPCClientError","cause","TRPCClientError","isTRPCErrorResponse","getMessageFromUnknownError","fallback","message","_opts$result","_opts$result2","_cause","getTransformer","transformer","_transformer","isFunction","getFetch","customFetchImpl","resolveHTTPLinkOptions","arrayToDict","array","dict","element","METHOD","getInput","_input","getUrl","url","queryParts","input","getBody","AbortError","throwIfAborted","signal","_signal$throwIfAborte","fetchHTTPResponse","_opts$methodOverride","body","method","resolvedHeaders","heads","headers","throwFatalError","dataLoader","batchLoader","pendingItems","dispatchTimer","destroyTimerAndPendingItems","groupItems","items","groupedItems","item","lastGroup","_item$reject","_item$reject2","dispatch","batch","_item","result","valueOrPromise","_item$resolve","_item$reject3","_item$reject4","_item$reject5","load","_dispatchTimer","promise","_pendingItems","allAbortSignals","signals","count","abortedCount","onAbort","raceAbortSignals","resultOf","withResolvers","prepareUrl","urlOptions","connectionParams","buildConnectionMessage","import_defineProperty$1","asyncWsOpen","ws","setupPingInterval","intervalMs","pongTimeoutMs","pingTimeout","pongTimeout","start","reset","pong","WsConnection","_opts$WebSocketPonyfi","_this","wsPromise","_this2","_this$ws","import_objectSpread2$4","TRPCUntypedClient","link","_opts$context","req$","envelope","_opts$onConnectionSta","_opts$onStarted","_opts$onStopped","_opts$onData","_opts$onError","_opts$onComplete","untypedClientSymbol","clientCallTypeMap","clientCallTypeToProcedureType","clientCallType","createTRPCClientProxy","client","proxy","pathCopy","procedureType","fullPath","createTRPCClient","import_objectSpread2$3","httpBatchStreamLink","_opts$maxURLLength","_opts$maxItems","resolvedOpts","maxURLLength","maxItems","batchOps","inputs","batchSignals","opts$1","json","query","mutation","loaders","_res","_asyncIterator$1","_awaitAsyncGenerator$1","_wrapAsyncGenerator$1","DoubleIndexedKV","Registry","generateIdentifier","identifier","ClassRegistry","options","valuesOfObj","record","values","find","predicate","valuesNotNever","forEach","includes","arr","findArr","CustomTransformerRegistry","getType","payload","isUndefined","isNull","isPlainObject","isEmptyObject","isArray","isString","isNumber","isBoolean","isRegExp","isMap","isSet","isSymbol","isDate","isError","isNaNValue","isPrimitive","isBigint","isInfinite","isTypedArray","isURL","escapeKey","stringifyPath","parsePath","string","legacyPaths","segment","char","escaped","lastSegment","simpleTransformation","isApplicable","annotation","transform","untransform","simpleRules","superJson","baseError","prop","regex","flags","compositeTransformation","symbolRule","a","constructorToName","ctor","typedArrayRule","isInstanceOfRegisteredClass","potentialClass","classRule","clazz","allowedProps","customRule","compositeRules","transformValue","applicableCompositeRule","rule","applicableSimpleRule","simpleRulesByAnnotation","untransformValue","transformation","getNthKey","validatePath","getDeep","object","row","keyOfRow","setDeep","mapper","parent","lastKey","oldValue","newValue","keyToRow","newKey","enableLegacyPaths","version","traverse","tree","walker","origin","subtree","nodeValue","children","child","applyValueAnnotations","plain","annotations","applyReferentialEqualityAnnotations","apply","identicalPaths","identicalObjectPath","root","other","identicalPath","isDeep","addIdentity","identities","existingSet","generateReferentialEqualityAnnotations","identitites","dedupe","rootEqualityPaths","paths","b","representativePath","objectsInThisPath","seenObjects","primitive","seen","transformed","transformationResult","transformedValue","innerAnnotations","recursiveResult","prototype","assignProp","carry","newVal","originalObject","includeNonenumerable","propType","copy","props","symbols","val","SuperJSON","output","equalityAnnotations","meta","superjson","trpc","App","init","setInit","useState","fetchInit","useEffect","loading","setLoading","username","increment","decrement","jsxs","jsx","navigateTo","createRoot","StrictMode"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29]}
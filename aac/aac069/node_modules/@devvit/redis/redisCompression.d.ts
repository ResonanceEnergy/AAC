import { type HScanResponse, type ZMember, type ZScanResponse } from '@devvit/protos/json/devvit/plugin/redis/redisapi.js';
import { RedisClient as RedisClientImpl } from './RedisClient.js';
import type { BitfieldCommand, RedisClient, SetOptions, TxClientLike, ZRangeOptions } from './types/redis.js';
export declare const REDIS_COMPRESSION_PREFIX: "__gz:b64__:";
export declare class RedisCompressionProxy implements RedisClient {
    #private;
    readonly global: Omit<RedisClient, 'global'>;
    constructor(client: RedisClientImpl);
    get(key: string): Promise<string | undefined>;
    set(key: string, value: string, options?: SetOptions): Promise<string>;
    hGet(key: string, field: string): Promise<string | undefined>;
    hSet(key: string, fieldValues: {
        [field: string]: string;
    }): Promise<number>;
    hSetNX(key: string, field: string, value: string): Promise<number>;
    hGetAll(key: string): Promise<Record<string, string>>;
    hMGet(key: string, fields: string[]): Promise<(string | null)[]>;
    mGet(keys: string[]): Promise<(string | null)[]>;
    mSet(keyValues: {
        [key: string]: string;
    }): Promise<void>;
    watch(...keys: string[]): Promise<TxClientLike>;
    getBuffer(key: string): Promise<Buffer | undefined>;
    exists(...keys: string[]): Promise<number>;
    del(...keys: string[]): Promise<void>;
    type(key: string): Promise<string>;
    rename(key: string, newKey: string): Promise<string>;
    getRange(key: string, start: number, end: number): Promise<string>;
    setRange(key: string, offset: number, value: string): Promise<number>;
    strLen(key: string): Promise<number>;
    incrBy(key: string, value: number): Promise<number>;
    expire(key: string, seconds: number): Promise<void>;
    expireTime(key: string): Promise<number>;
    zAdd(key: string, ...members: ZMember[]): Promise<number>;
    zCard(key: string): Promise<number>;
    zScore(key: string, member: string): Promise<number | undefined>;
    zRank(key: string, member: string): Promise<number | undefined>;
    zIncrBy(key: string, member: string, value: number): Promise<number>;
    zRange(key: string, start: number | string, stop: number | string, options?: ZRangeOptions): Promise<{
        member: string;
        score: number;
    }[]>;
    zRem(key: string, members: string[]): Promise<number>;
    zRemRangeByLex(key: string, min: string, max: string): Promise<number>;
    zRemRangeByRank(key: string, start: number, stop: number): Promise<number>;
    zRemRangeByScore(key: string, min: number, max: number): Promise<number>;
    zScan(key: string, cursor: number, pattern?: string | undefined, count?: number | undefined): Promise<ZScanResponse>;
    hDel(key: string, fields: string[]): Promise<number>;
    hScan(key: string, cursor: number, pattern?: string | undefined, count?: number | undefined): Promise<HScanResponse>;
    hKeys(key: string): Promise<string[]>;
    hIncrBy(key: string, field: string, value: number): Promise<number>;
    hLen(key: string): Promise<number>;
    bitfield(key: string, ...cmds: [] | BitfieldCommand | [...BitfieldCommand, ...BitfieldCommand] | [...BitfieldCommand, ...BitfieldCommand, ...BitfieldCommand, ...(number | string)[]]): Promise<number[]>;
}
//# sourceMappingURL=redisCompression.d.ts.map
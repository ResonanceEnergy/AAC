import { type BitfieldRequest, type BitfieldResponse, type ExistsResponse, type ExpireRequest, type HDelRequest, type HGetRequest, type HIncrByRequest, type HMGetRequest, type HScanRequest, type HScanResponse, type HSetNXRequest, type HSetRequest, type IncrByRequest, type KeyRangeRequest, type KeyRequest, type KeysRequest, type KeysResponse, type KeyValuesRequest, type RedisFieldValues, type RedisValues, type RenameRequest, type RenameResponse, type SetRangeRequest, type SetRequest, type TransactionId, type TransactionResponse, type TransactionResponses, type WatchRequest, type ZAddRequest, type ZIncrByRequest, type ZMembers, type ZRangeRequest, type ZRankRequest, type ZRemRangeByLexRequest, type ZRemRangeByRankRequest, type ZRemRangeByScoreRequest, type ZRemRequest, type ZScanRequest, type ZScanResponse, type ZScoreRequest } from '@devvit/protos/json/devvit/plugin/redis/redisapi.js';
import type { Empty } from '@devvit/protos/json/google/protobuf/empty.js';
import type { DoubleValue, Int64Value, StringValue } from '@devvit/protos/json/google/protobuf/wrappers.js';
import type { Metadata } from '@devvit/protos/lib/Types.js';
import type { RedisAPI } from '@devvit/protos/types/devvit/plugin/redis/redisapi.js';
import type { BytesValue } from '@devvit/protos/types/google/protobuf/wrappers.js';
import type { PluginMock } from '@devvit/shared-types/test/index.js';
import { Redis } from 'ioredis';
type QueuedCommand = () => Promise<TransactionResponse>;
type TransactionState = {
    id: string;
    commands: QueuedCommand[];
    multiStarted: boolean;
    watchedKeys: string[];
    closed: boolean;
};
type RedisStore = {
    transactions: Map<string, TransactionState>;
    conn: Redis;
    /**
     * Prefix to use for all keys.
     * If provided, it will be used to scope all keys (including global ones).
     * A colon delimiter (:) will be automatically appended if not present.
     */
    keyPrefix?: string;
};
/**
 * Mock implementation of the Redis API for testing purposes.
 * Uses an in-memory Redis server to simulate actual Redis behavior.
 */
export declare class RedisPluginMock implements RedisAPI {
    private readonly _store;
    constructor(store: RedisStore);
    private _makeKey;
    Get(request: KeyRequest, metadata?: Metadata): Promise<StringValue>;
    GetBytes(request: KeyRequest, metadata?: Metadata): Promise<BytesValue>;
    Set(request: SetRequest): Promise<StringValue>;
    Exists(request: KeysRequest): Promise<ExistsResponse>;
    Del(request: KeysRequest): Promise<Int64Value>;
    Type(request: KeyRequest): Promise<StringValue>;
    Rename(request: RenameRequest): Promise<RenameResponse>;
    IncrBy(request: IncrByRequest): Promise<Int64Value>;
    HSet(request: HSetRequest): Promise<Int64Value>;
    HGet(request: HGetRequest, metadata?: Metadata): Promise<StringValue>;
    HMGet(request: HMGetRequest): Promise<RedisValues>;
    HGetAll(request: KeyRequest): Promise<RedisFieldValues>;
    HDel(request: HDelRequest): Promise<Int64Value>;
    HScan(request: HScanRequest): Promise<HScanResponse>;
    HKeys(request: KeyRequest): Promise<KeysResponse>;
    HIncrBy(request: HIncrByRequest): Promise<Int64Value>;
    HLen(request: KeyRequest): Promise<Int64Value>;
    HSetNX(request: HSetNXRequest): Promise<{
        success: number;
    }>;
    Watch(request: WatchRequest): Promise<TransactionId>;
    Multi(request: TransactionId): Promise<Empty>;
    Exec(request: TransactionId): Promise<TransactionResponses>;
    Discard(request: TransactionId): Promise<Empty>;
    Unwatch(request: TransactionId): Promise<Empty>;
    GetRange(request: KeyRangeRequest): Promise<StringValue>;
    SetRange(request: SetRangeRequest): Promise<Int64Value>;
    Strlen(request: KeyRequest): Promise<Int64Value>;
    MGet(request: KeysRequest): Promise<RedisValues>;
    MSet(request: KeyValuesRequest): Promise<Empty>;
    Expire(request: ExpireRequest): Promise<Empty>;
    ExpireTime(request: KeyRequest): Promise<Int64Value>;
    ZAdd(request: ZAddRequest): Promise<Int64Value>;
    ZCard(request: KeyRequest): Promise<Int64Value>;
    ZRange(request: ZRangeRequest): Promise<ZMembers>;
    ZRem(request: ZRemRequest): Promise<Int64Value>;
    ZRemRangeByLex(request: ZRemRangeByLexRequest): Promise<Int64Value>;
    ZRemRangeByRank(request: ZRemRangeByRankRequest): Promise<Int64Value>;
    ZRemRangeByScore(request: ZRemRangeByScoreRequest): Promise<Int64Value>;
    ZScan(request: ZScanRequest): Promise<ZScanResponse>;
    ZScore(request: ZScoreRequest, metadata?: Metadata): Promise<DoubleValue>;
    ZRank(request: ZRankRequest, metadata?: Metadata): Promise<Int64Value>;
    ZIncrBy(request: ZIncrByRequest): Promise<DoubleValue>;
    Bitfield(request: BitfieldRequest): Promise<BitfieldResponse>;
    private _createTransaction;
    private _getTransaction;
    private _extractTransactionId;
    private _queueOrRun;
    private _closeTransaction;
}
export declare class RedisMock implements PluginMock<RedisAPI> {
    readonly plugin: RedisPluginMock;
    private readonly _store;
    /**
     * @param conn - The Redis connection to use.
     * @param keyPrefix - Optional prefix to scope all keys. If provided, `clear()` will only delete
     * keys starting with this prefix. This allows multiple test instances to share a single
     * Redis connection without interference.
     */
    constructor(conn: Redis, keyPrefix?: string);
    /**
     * Clears the mock Redis state.
     */
    clear(): Promise<void>;
}
export {};
//# sourceMappingURL=RedisMock.d.ts.map
import { randomUUID } from 'node:crypto';
import { RedisKeyScope, } from '@devvit/protos/json/devvit/plugin/redis/redisapi.js';
import { Redis } from 'ioredis';
// Minimal helper to check the special header toggle used by RedisClient
const shouldThrowNil = (metadata) => {
    return metadata?.['throw-redis-nil']?.values?.[0]?.toLowerCase() === 'true';
};
const normalizeOffset = (offset) => {
    if (offset == null)
        return undefined;
    if (offset === 0)
        return undefined;
    return offset;
};
const normalizeCount = (count) => {
    if (count == null)
        return undefined;
    if (count <= 0)
        return undefined;
    return count;
};
const paginateMembers = (members, offset, count) => {
    if ((offset == null || offset === 0) && count == null) {
        return members;
    }
    const startIndex = Math.max(0, offset ?? 0);
    if (startIndex >= members.length)
        return [];
    if (count == null) {
        return members.slice(startIndex);
    }
    if (count <= 0)
        return [];
    return members.slice(startIndex, startIndex + count);
};
const pairsToMembers = (vals) => {
    const entries = [];
    for (let i = 0; i < vals.length; i += 2) {
        const member = vals[i];
        if (member == null)
            continue;
        const score = vals[i + 1] != null ? Number(vals[i + 1]) : 0;
        entries.push({ member, score });
    }
    return entries;
};
const lexValsToMembers = (vals) => vals.map((member) => ({ member, score: 0 }));
/**
 * Mock implementation of the Redis API for testing purposes.
 * Uses an in-memory Redis server to simulate actual Redis behavior.
 */
export class RedisPluginMock {
    constructor(store) {
        this._store = store;
    }
    _makeKey(key, scope) {
        const scopedKey = scope === RedisKeyScope.GLOBAL ? `global:${key}` : key;
        if (!this._store.keyPrefix)
            return scopedKey;
        const prefix = this._store.keyPrefix.endsWith(':')
            ? this._store.keyPrefix
            : `${this._store.keyPrefix}:`;
        return `${prefix}${scopedKey}`;
    }
    // Simple Key-Value operations
    async Get(request, metadata) {
        const operation = async () => {
            const v = await this._store.conn.get(this._makeKey(request.key, request.scope));
            if (v == null) {
                if (shouldThrowNil(metadata))
                    throw new Error('redis: nil');
                return { value: '' };
            }
            return { value: v };
        };
        return this._queueOrRun(request.transactionId, operation, (result) => ({ str: result.value }));
    }
    async GetBytes(request, metadata) {
        const v = await this._store.conn.getBuffer(this._makeKey(request.key, request.scope));
        if (v == null) {
            if (shouldThrowNil(metadata))
                throw new Error('redis: nil');
            return { value: new Uint8Array() };
        }
        return { value: v };
    }
    async Set(request) {
        const operation = async () => {
            const k = this._makeKey(request.key, request.scope);
            if (request.nx && request.xx)
                throw new Error('invalid Set: nx and xx cannot both be true');
            const args = [k, request.value];
            if (request.expiration && request.expiration > 0) {
                args.push('EX', request.expiration);
            }
            if (request.nx) {
                args.push('NX');
            }
            else if (request.xx) {
                args.push('XX');
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const res = await this._store.conn.set(...args);
            return { value: res ?? '' };
        };
        return this._queueOrRun(request.transactionId, operation, (result) => ({ str: result.value }));
    }
    async Exists(request) {
        const count = await this._store.conn.exists(...request.keys.map((k) => this._makeKey(k, request.scope)));
        return { existingKeys: count };
    }
    async Del(request) {
        const operation = async () => {
            const n = await this._store.conn.del(...request.keys.map((k) => this._makeKey(k, request.scope)));
            return { value: n };
        };
        return this._queueOrRun(request.transactionId, operation, (result) => ({ num: result.value }));
    }
    async Type(request) {
        const operation = async () => {
            const t = await this._store.conn.type(this._makeKey(request.key, request.scope));
            return { value: t };
        };
        return this._queueOrRun(request.transactionId, operation, (result) => ({ str: result.value }));
    }
    async Rename(request) {
        const res = await this._store.conn.rename(this._makeKey(request.key, request.scope), this._makeKey(request.newKey, request.scope));
        return { result: res };
    }
    // Number operations
    async IncrBy(request) {
        const operation = async () => {
            const { key, value, scope } = request;
            const v = await this._store.conn.incrby(this._makeKey(key, scope), value);
            return { value: Number(v) };
        };
        return this._queueOrRun(request.transactionId, operation, (result) => ({ num: result.value }));
    }
    // Redis Hash operations
    async HSet(request) {
        const operation = async () => {
            // Redis 3.x only supports `HSET key field value` (single pair).
            // Redis 4+ supports variadic `HSET key f1 v1 f2 v2 ...`, which ioredis uses when given an object.
            // To be compatible across versions (and OSes in redis-memory-server), issue one HSET per field and sum.
            const map = new Map();
            for (const { field, value } of request.fv)
                map.set(field, value);
            const key = this._makeKey(request.key, request.scope);
            let addedFields = 0;
            for (const [field, value] of map.entries()) {
                const res = await this._store.conn.hset(key, field, value);
                addedFields += Number(res);
            }
            return { value: addedFields };
        };
        return this._queueOrRun(request.transactionId, operation, (result) => ({ num: result.value }));
    }
    async HGet(request, metadata) {
        const operation = async () => {
            const v = await this._store.conn.hget(this._makeKey(request.key, request.scope), request.field);
            if (v == null) {
                if (shouldThrowNil(metadata))
                    throw new Error('redis: nil');
                return { value: '' };
            }
            return { value: v };
        };
        return this._queueOrRun(request.transactionId, operation, (result) => ({ str: result.value }));
    }
    async HMGet(request) {
        const operation = async () => {
            const vals = await this._store.conn.hmget(this._makeKey(request.key, request.scope), ...request.fields);
            return {
                values: vals.map((v) => (v === null ? '' : v)),
            };
        };
        return this._queueOrRun(request.transactionId, operation, (result) => ({ values: result }));
    }
    async HGetAll(request) {
        const operation = async () => {
            const v = await this._store.conn.hgetall(this._makeKey(request.key, request.scope));
            return { fieldValues: v };
        };
        return this._queueOrRun(request.transactionId, operation, (result) => {
            const flattened = [];
            for (const [field, value] of Object.entries(result.fieldValues)) {
                flattened.push(field, value);
            }
            return { values: { values: flattened } };
        });
    }
    async HDel(request) {
        const operation = async () => {
            const n = await this._store.conn.hdel(this._makeKey(request.key, request.scope), ...request.fields);
            return { value: Number(n) };
        };
        return this._queueOrRun(request.transactionId, operation, (result) => ({ num: result.value }));
    }
    async HScan(request) {
        const operation = async () => {
            const args = [];
            if (request.pattern)
                args.push('MATCH', request.pattern);
            if (request.count)
                args.push('COUNT', String(request.count));
            // ioredis types don't support spread arguments well, so we cast the function to any
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const [cursor, elements] = await this._store.conn.hscan(this._makeKey(request.key, request.scope), request.cursor, ...args);
            const fieldValues = [];
            for (let i = 0; i < elements.length; i += 2) {
                fieldValues.push({ field: elements[i], value: elements[i + 1] });
            }
            return { cursor: Number(cursor), fieldValues };
        };
        return this._queueOrRun(request.transactionId, operation, (result) => {
            const payload = [result.cursor.toString()];
            for (const entry of result.fieldValues) {
                payload.push(entry.field, entry.value);
            }
            return { values: { values: payload } };
        });
    }
    async HKeys(request) {
        const operation = async () => {
            const keys = await this._store.conn.hkeys(this._makeKey(request.key, request.scope));
            return { keys };
        };
        return this._queueOrRun(request.transactionId, operation, (result) => ({
            values: { values: result.keys },
        }));
    }
    async HIncrBy(request) {
        const operation = async () => {
            const v = await this._store.conn.hincrby(this._makeKey(request.key, request.scope), request.field, request.value);
            return { value: Number(v) };
        };
        return this._queueOrRun(request.transactionId, operation, (result) => ({ num: result.value }));
    }
    async HLen(request) {
        const operation = async () => {
            const v = await this._store.conn.hlen(this._makeKey(request.key, request.scope));
            return { value: Number(v) };
        };
        return this._queueOrRun(request.transactionId, operation, (result) => ({ num: result.value }));
    }
    async HSetNX(request) {
        const operation = async () => {
            const v = await this._store.conn.hsetnx(this._makeKey(request.key, request.scope), request.field, request.value);
            return { success: Number(v) };
        };
        return this._queueOrRun(request.transactionId, operation, (result) => ({ num: result.success }), { success: 0 });
    }
    // Transactions
    async Watch(request) {
        if (request.transactionId) {
            const tx = this._getTransaction(request.transactionId);
            tx.watchedKeys.push(...request.keys.map((key) => this._makeKey(key)));
            return request.transactionId;
        }
        const tx = this._createTransaction(request.keys.map((key) => this._makeKey(key)));
        return { id: tx.id };
    }
    async Multi(request) {
        const tx = this._getTransaction(request);
        if (tx.multiStarted) {
            throw new Error(`Transaction ${request.id} already started`);
        }
        tx.multiStarted = true;
        return {};
    }
    async Exec(request) {
        const tx = this._getTransaction(request);
        if (!tx.multiStarted) {
            throw new Error(`Transaction ${request.id} must call multi() before exec()`);
        }
        const response = [];
        for (const command of tx.commands) {
            response.push(await command());
        }
        this._closeTransaction(request);
        return { response };
    }
    async Discard(request) {
        this._closeTransaction(request);
        return {};
    }
    async Unwatch(request) {
        const tx = this._getTransaction(request);
        tx.watchedKeys = [];
        return {};
    }
    // String operations
    async GetRange(request) {
        const operation = async () => {
            const v = await this._store.conn.getrange(this._makeKey(request.key, request.scope), request.start, request.end);
            return { value: v };
        };
        return this._queueOrRun(request.transactionId, operation, (result) => ({ str: result.value }));
    }
    async SetRange(request) {
        const operation = async () => {
            const v = await this._store.conn.setrange(this._makeKey(request.key, request.scope), request.offset, request.value);
            return { value: Number(v) };
        };
        return this._queueOrRun(request.transactionId, operation, (result) => ({ num: result.value }));
    }
    async Strlen(request) {
        const operation = async () => {
            const v = await this._store.conn.strlen(this._makeKey(request.key, request.scope));
            return { value: Number(v) };
        };
        return this._queueOrRun(request.transactionId, operation, (result) => ({ num: result.value }));
    }
    // Batch Key-Value operations
    async MGet(request) {
        const operation = async () => {
            const keys = request.keys.map((k) => this._makeKey(k, request.scope));
            const vals = await this._store.conn.mget(...keys);
            return {
                values: vals.map((v) => (v === null ? '' : v)),
            };
        };
        return this._queueOrRun(request.transactionId, operation, (result) => ({ values: result }));
    }
    async MSet(request) {
        const operation = async () => {
            const flat = [];
            for (const { key, value } of request.kv) {
                flat.push(this._makeKey(key, request.scope), value);
            }
            await this._store.conn.mset(...flat);
            return {};
        };
        return this._queueOrRun(request.transactionId, operation, () => ({ str: 'OK' }), {});
    }
    // Key expiration
    async Expire(request) {
        const operation = async () => {
            await this._store.conn.expire(this._makeKey(request.key, request.scope), request.seconds);
            return {};
        };
        return this._queueOrRun(request.transactionId, operation, () => ({ str: 'OK' }), {});
    }
    async ExpireTime(request) {
        const operation = async () => {
            const v = await this._store.conn.expiretime(this._makeKey(request.key, request.scope));
            return { value: Number(v) };
        };
        return this._queueOrRun(request.transactionId, operation, (result) => ({ num: result.value }));
    }
    // Sorted sets
    async ZAdd(request) {
        const operation = async () => {
            const args = request.members.flatMap((m) => [m.score, m.member]);
            const v = await this._store.conn.zadd(this._makeKey(request.key, request.scope), ...args);
            return { value: Number(v) };
        };
        return this._queueOrRun(request.transactionId, operation, (result) => ({ num: result.value }));
    }
    async ZCard(request) {
        const operation = async () => {
            const v = await this._store.conn.zcard(this._makeKey(request.key, request.scope));
            return { value: Number(v) };
        };
        return this._queueOrRun(request.transactionId, operation, (result) => ({ num: result.value }));
    }
    async ZRange(request) {
        const operation = async () => {
            const k = this._makeKey(request.key?.key ?? '', request.scope ?? request.key?.scope);
            const offsetVal = normalizeOffset(request.offset);
            const countVal = normalizeCount(request.count);
            if (request.byScore) {
                const vals = request.rev
                    ? await this._store.conn.zrevrangebyscore(k, request.stop, request.start, 'WITHSCORES')
                    : await this._store.conn.zrangebyscore(k, request.start, request.stop, 'WITHSCORES');
                const members = paginateMembers(pairsToMembers(vals), offsetVal, countVal);
                return { members };
            }
            if (request.byLex) {
                const vals = request.rev
                    ? await this._store.conn.zrevrangebylex(k, request.start, request.stop)
                    : await this._store.conn.zrangebylex(k, request.start, request.stop);
                const members = paginateMembers(lexValsToMembers(vals), offsetVal, countVal);
                return { members };
            }
            const startIndex = Number(request.start);
            const stopIndex = Number(request.stop);
            const vals = request.rev
                ? await this._store.conn.zrevrange(k, startIndex, stopIndex, 'WITHSCORES')
                : await this._store.conn.zrange(k, startIndex, stopIndex, 'WITHSCORES');
            const members = paginateMembers(pairsToMembers(vals), offsetVal, countVal);
            return { members };
        };
        const txId = this._extractTransactionId(request.key);
        return this._queueOrRun(txId, operation, (result) => ({ members: result }));
    }
    async ZRem(request) {
        const operation = async () => {
            const v = await this._store.conn.zrem(this._makeKey(request.key?.key ?? '', request.scope ?? request.key?.scope), ...request.members);
            return { value: Number(v) };
        };
        return this._queueOrRun(this._extractTransactionId(request, request.key), operation, (result) => ({
            num: result.value,
        }));
    }
    async ZRemRangeByLex(request) {
        const operation = async () => {
            const v = await this._store.conn.zremrangebylex(this._makeKey(request.key?.key ?? '', request.scope ?? request.key?.scope), request.min, request.max);
            return { value: Number(v) };
        };
        return this._queueOrRun(this._extractTransactionId(request, request.key), operation, (result) => ({
            num: result.value,
        }));
    }
    async ZRemRangeByRank(request) {
        const operation = async () => {
            const v = await this._store.conn.zremrangebyrank(this._makeKey(request.key?.key ?? '', request.scope ?? request.key?.scope), request.start, request.stop);
            return { value: Number(v) };
        };
        return this._queueOrRun(this._extractTransactionId(request, request.key), operation, (result) => ({
            num: result.value,
        }));
    }
    async ZRemRangeByScore(request) {
        const operation = async () => {
            const v = await this._store.conn.zremrangebyscore(this._makeKey(request.key?.key ?? '', request.scope ?? request.key?.scope), request.min, request.max);
            return { value: Number(v) };
        };
        return this._queueOrRun(this._extractTransactionId(request, request.key), operation, (result) => ({
            num: result.value,
        }));
    }
    async ZScan(request) {
        const operation = async () => {
            const args = [];
            if (request.pattern)
                args.push('MATCH', request.pattern);
            if (request.count)
                args.push('COUNT', String(request.count));
            // ioredis types don't support spread arguments well, so we cast the function to any
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const [cursor, elements] = await this._store.conn.zscan(this._makeKey(request.key, request.scope), request.cursor, ...args);
            const members = [];
            for (let i = 0; i < elements.length; i += 2) {
                // ioredis returns [member, score] pairs from zscan with WITHSCORES-like structure
                const member = elements[i];
                const score = Number(elements[i + 1]);
                members.push({ member, score });
            }
            return { cursor: Number(cursor), members };
        };
        return this._queueOrRun(request.transactionId, operation, (result) => {
            const payload = [result.cursor.toString()];
            for (const member of result.members) {
                payload.push(member.member, member.score.toString());
            }
            return { values: { values: payload } };
        });
    }
    async ZScore(request, metadata) {
        const operation = async () => {
            const v = await this._store.conn.zscore(this._makeKey(request.key?.key ?? '', request.scope ?? request.key?.scope), request.member);
            if (v == null) {
                if (shouldThrowNil(metadata))
                    throw new Error('redis: nil');
                return { value: 0 };
            }
            return { value: Number(v) };
        };
        return this._queueOrRun(this._extractTransactionId(request, request.key), operation, (result) => ({ dbl: result.value }));
    }
    async ZRank(request, metadata) {
        const operation = async () => {
            const v = await this._store.conn.zrank(this._makeKey(request.key?.key ?? '', request.scope ?? request.key?.scope), request.member);
            if (v == null) {
                if (shouldThrowNil(metadata))
                    throw new Error('redis: nil');
                return { value: -1 };
            }
            return { value: Number(v) };
        };
        return this._queueOrRun(this._extractTransactionId(request, request.key), operation, (result) => ({ num: result.value }));
    }
    async ZIncrBy(request) {
        const operation = async () => {
            const v = await this._store.conn.zincrby(this._makeKey(request.key, request.scope), request.value, request.member);
            return { value: Number(v) };
        };
        return this._queueOrRun(request.transactionId, operation, (result) => ({ dbl: result.value }));
    }
    // Bitfield
    async Bitfield(request) {
        const flat = [];
        for (const cmd of request.commands ?? []) {
            if (cmd.set) {
                flat.push('SET', cmd.set.encoding, String(cmd.set.offset), String(cmd.set.value));
            }
            else if (cmd.get) {
                flat.push('GET', cmd.get.encoding, String(cmd.get.offset));
            }
            else if (cmd.incrBy) {
                flat.push('INCRBY', cmd.incrBy.encoding, String(cmd.incrBy.offset), String(cmd.incrBy.increment));
            }
            else if (cmd.overflow) {
                const behavior = cmd.overflow.behavior;
                const mode = behavior === 1 ? 'WRAP' : behavior === 2 ? 'SAT' : 'FAIL';
                flat.push('OVERFLOW', mode);
            }
        }
        // TODO: Fix this once BitfieldRequest supports scope. Looks like a bug that it doesn't?
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const res = await this._store.conn.bitfield(this._makeKey(request.key, undefined), ...flat);
        return { results: res };
    }
    _createTransaction(keys = []) {
        const tx = {
            id: randomUUID(),
            commands: [],
            multiStarted: false,
            watchedKeys: [...keys],
            closed: false,
        };
        this._store.transactions.set(tx.id, tx);
        return tx;
    }
    _getTransaction(transactionId) {
        const tx = this._store.transactions.get(transactionId.id);
        if (!tx || tx.closed) {
            throw new Error(`Unknown or closed transaction ${transactionId.id}`);
        }
        return tx;
    }
    _extractTransactionId(...candidates) {
        for (const candidate of candidates) {
            if (candidate &&
                typeof candidate === 'object' &&
                'transactionId' in candidate &&
                candidate.transactionId) {
                return candidate.transactionId;
            }
        }
        return undefined;
    }
    async _queueOrRun(transactionId, operation, mapper, queuedValue) {
        if (!transactionId) {
            return operation();
        }
        const tx = this._getTransaction(transactionId);
        if (!tx.multiStarted) {
            throw new Error(`Transaction ${transactionId.id} must call multi() before executing commands`);
        }
        tx.commands.push(async () => mapper(await operation()));
        if (queuedValue !== undefined) {
            return queuedValue;
        }
        return {};
    }
    _closeTransaction(transactionId) {
        const tx = this._store.transactions.get(transactionId.id);
        if (tx) {
            tx.closed = true;
            this._store.transactions.delete(transactionId.id);
        }
    }
}
export class RedisMock {
    /**
     * @param conn - The Redis connection to use.
     * @param keyPrefix - Optional prefix to scope all keys. If provided, `clear()` will only delete
     * keys starting with this prefix. This allows multiple test instances to share a single
     * Redis connection without interference.
     */
    constructor(conn, keyPrefix = '') {
        this._store = {
            transactions: new Map(),
            conn: conn,
            keyPrefix,
        };
        this.plugin = new RedisPluginMock(this._store);
    }
    /**
     * Clears the mock Redis state.
     */
    async clear() {
        this._store.transactions.clear();
        if (this._store.keyPrefix) {
            const prefix = this._store.keyPrefix.endsWith(':')
                ? this._store.keyPrefix
                : `${this._store.keyPrefix}:`;
            const pattern = `${prefix}*`;
            let cursor = '0';
            do {
                const result = await this._store.conn.scan(cursor, 'MATCH', pattern, 'COUNT', 100);
                cursor = result[0];
                const keys = result[1];
                if (keys.length > 0) {
                    await this._store.conn.del(...keys);
                }
            } while (cursor !== '0');
        }
        else {
            await this._store.conn.flushall();
        }
    }
}

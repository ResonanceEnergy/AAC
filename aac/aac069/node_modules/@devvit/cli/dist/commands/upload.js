var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Upload_instances, _a, _Upload_appClient, _Upload_installationsClient, _Upload_event, _Upload_eventSent, _Upload_runBuildScriptIfConfigured, _Upload_checkDependencies, _Upload_canImport, _Upload_getNextVersionNumber, _Upload_bundleActors, _Upload_sendEventIfNotSent, _Upload_installOnDefaultPlaytestSubreddit, _Upload_initApp;
import { exec } from 'node:child_process';
import fs from 'node:fs';
import path from 'node:path';
import { AppVersionInfo, FullAppInfo, FullInstallationInfo, VersionVisibility, } from '@devvit/protos/community.js';
import { ACTOR_SRC_PRIMARY_NAME, MAX_ALLOWED_SUBSCRIBER_COUNT, } from '@devvit/shared-types/constants.js';
import { StringUtil } from '@devvit/shared-types/StringUtil.js';
import { DevvitVersion, VersionBumpType } from '@devvit/shared-types/Version.js';
import { Flags, ux } from '@oclif/core';
import chalk from 'chalk';
import { execaCommand } from 'execa';
import { REDDIT_DESKTOP } from '../lib/config.js';
import { isCurrentUserEmployee } from '../lib/http/gql.js';
import { AppVersionUploader } from '../util/AppVersionUploader.js';
import { getAccessTokenAndLoginIfNeeded } from '../util/auth.js';
import { Bundler } from '../util/Bundler.js';
import { createAppClient, createAppVersionClient, createInstallationsClient, } from '../util/clientGenerators.js';
import { DevvitCommand } from '../util/commands/DevvitCommand.js';
import { installOnSubreddit } from '../util/common-actions/installOnSubreddit.js';
import { DEVVIT_PORTAL_URL } from '../util/config.js';
import { getAppBySlug } from '../util/getAppBySlug.js';
import { sendEvent } from '../util/metrics.js';
import { getCodeFromWizard, gitInitIfNeeded, installAppDependencies, unpackCode, updatePackageJSON, } from './init.js';
class Upload extends DevvitCommand {
    constructor() {
        super(...arguments);
        _Upload_instances.add(this);
        _Upload_appClient.set(this, createAppClient());
        _Upload_installationsClient.set(this, createInstallationsClient());
        _Upload_event.set(this, {
            source: 'devplatform_cli',
            action: 'ran',
            noun: 'upload',
            devplatform: {
                cli_raw_command_line: 'devvit ' + process.argv.slice(2).join(' '),
                cli_is_valid_command: true,
                cli_command: 'upload',
            },
        });
        _Upload_eventSent.set(this, false);
    }
    async init() {
        // Dynamic mode allows configs that reference build outputs that don't exist
        // yet; upload will run scripts.build (if configured) before bundling.
        await super.init('Dynamic');
    }
    async run() {
        const { flags } = await this.parse(_a);
        await __classPrivateFieldGet(this, _Upload_instances, "m", _Upload_checkDependencies).call(this, flags['just-do-it']);
        await __classPrivateFieldGet(this, _Upload_instances, "m", _Upload_runBuildScriptIfConfigured).call(this, Boolean(flags.verbose));
        const token = await getAccessTokenAndLoginIfNeeded(flags['copy-paste'] ? 'CopyPaste' : 'LocalSocket');
        const username = await this.getUserDisplayName(token);
        await this.checkDeveloperAccount();
        let appInfo;
        try {
            appInfo = await getAppBySlug(__classPrivateFieldGet(this, _Upload_appClient, "f"), {
                slug: this.project.name,
                hidePrereleaseVersions: true,
                limit: 1, // fetched version limit; we only need the latest one
            });
        }
        catch (e) {
            this.error(StringUtil.caughtToString(e, 'message'));
        }
        let shouldCreateNewApp = false;
        let shouldCreatePlaytestSubreddit = !this.project.getSubreddit('Dev');
        const isOwner = appInfo?.app?.owner?.displayName === username;
        if (!isOwner) {
            shouldCreateNewApp = true;
            // Unless...
            if (flags['employee-update'] || flags['just-do-it']) {
                const isEmployee = await isCurrentUserEmployee(token);
                if (!isEmployee) {
                    this.error(`You're not an employee, so you can't playtest someone else's app.`);
                }
                // Else, we're an employee, so we can update someone else's app
                this.warn(`Overriding ownership check because you're an employee and told me to!`);
                shouldCreateNewApp = false;
            }
        }
        if (flags.verbose) {
            ux.action.start('Verifying app builds');
        }
        // Version is unknown until upload. Use a fake one for build verification.
        await __classPrivateFieldGet(this, _Upload_instances, "m", _Upload_bundleActors).call(this, username, '0.0.0');
        ux.action.stop();
        if (shouldCreateNewApp || !appInfo) {
            const appName = await __classPrivateFieldGet(this, _Upload_instances, "m", _Upload_initApp).call(this);
            try {
                // Reload the project since the name updated
                appInfo = await getAppBySlug(__classPrivateFieldGet(this, _Upload_appClient, "f"), {
                    slug: appName,
                    hidePrereleaseVersions: true,
                    limit: 1, // fetched version limit; we only need the latest one
                });
            }
            catch (e) {
                this.error(StringUtil.caughtToString(e, 'message'));
            }
            shouldCreatePlaytestSubreddit = true; // If we need to create a new app, we always need to create a playtest subreddit.
            __classPrivateFieldGet(this, _Upload_event, "f").devplatform.cli_upload_is_initial = true;
            __classPrivateFieldGet(this, _Upload_event, "f").devplatform.cli_upload_is_nsfw = appInfo?.app?.isNsfw;
            __classPrivateFieldGet(this, _Upload_event, "f").devplatform.app_name = appInfo?.app?.slug;
        }
        else {
            __classPrivateFieldGet(this, _Upload_event, "f").devplatform.cli_upload_is_initial = false;
            __classPrivateFieldGet(this, _Upload_event, "f").devplatform.cli_upload_is_nsfw = appInfo.app?.isNsfw;
            __classPrivateFieldGet(this, _Upload_event, "f").devplatform.app_name = appInfo.app?.name;
        }
        if (!appInfo?.app) {
            this.error(`We couldn't find the app ${this.project.name}. Please run \`npx devvit init\` first.`);
        }
        let appVersionNumber = flags.version;
        if (!appVersionNumber) {
            appVersionNumber = await __classPrivateFieldGet(this, _Upload_instances, "m", _Upload_getNextVersionNumber).call(this, appInfo, flags.bump);
        }
        __classPrivateFieldGet(this, _Upload_event, "f").devplatform.app_version_number = appVersionNumber.toString();
        ux.action.start('Building');
        const bundles = await __classPrivateFieldGet(this, _Upload_instances, "m", _Upload_bundleActors).call(this, username, appVersionNumber.toString());
        ux.action.stop();
        try {
            const appVersionUploader = new AppVersionUploader(this, {
                verbose: flags.verbose,
                experimentalDirectUpload: !flags['disable-direct-upload'],
            });
            if (shouldCreatePlaytestSubreddit) {
                this.log(chalk.green(`We'll create a default playtest subreddit for your app!`));
            }
            const shouldShowUploadingAction = !flags.verbose;
            if (shouldShowUploadingAction) {
                ux.action.start('Uploading');
            }
            const latestVersion = await appVersionUploader.createVersion({
                appId: appInfo.app.id,
                appSlug: appInfo.app.slug,
                appSemver: appVersionNumber,
                visibility: VersionVisibility.PRIVATE,
            }, bundles, !shouldCreatePlaytestSubreddit);
            if (shouldShowUploadingAction) {
                ux.action.stop();
            }
            // Install the app to the default playtest subreddit, if it was created.
            if (shouldCreatePlaytestSubreddit) {
                const installationInfo = await __classPrivateFieldGet(this, _Upload_instances, "m", _Upload_installOnDefaultPlaytestSubreddit).call(this, token, latestVersion, flags.verbose);
                if (installationInfo) {
                    const devSubredditName = installationInfo.installation?.location?.name;
                    if (devSubredditName) {
                        const playtestUrl = chalk.bold.green(`${REDDIT_DESKTOP}/r/${devSubredditName}`);
                        this.log(`We have created a playtest subreddit for you at ${playtestUrl}`);
                        this.project.setSubreddit(devSubredditName, 'Dev');
                        ux.action.stop();
                    }
                }
                else {
                    this.warn(`We couldn't install your app to the new playtest subreddit, but you can still do so manually.`);
                }
            }
        }
        catch (err) {
            const errMessage = StringUtil.caughtToString(err, 'message');
            if (err instanceof Error) {
                this.error(errMessage);
            }
            else {
                this.error(`An unknown error occurred when creating the app version.\n${errMessage}`);
            }
        }
        this.log(`\nâœ¨ Visit ${chalk.cyan.bold(`${DEVVIT_PORTAL_URL}/apps/${appInfo.app?.slug}`)} to view your app!`);
        await __classPrivateFieldGet(this, _Upload_instances, "m", _Upload_sendEventIfNotSent).call(this);
        process.exit(0);
    }
    async catch(err) {
        __classPrivateFieldGet(this, _Upload_event, "f").devplatform.cli_upload_is_successful = false;
        __classPrivateFieldGet(this, _Upload_event, "f").devplatform.cli_upload_failure_reason = err.message;
        await __classPrivateFieldGet(this, _Upload_instances, "m", _Upload_sendEventIfNotSent).call(this);
        return super.catch(err);
    }
}
_a = Upload, _Upload_appClient = new WeakMap(), _Upload_installationsClient = new WeakMap(), _Upload_event = new WeakMap(), _Upload_eventSent = new WeakMap(), _Upload_instances = new WeakSet(), _Upload_runBuildScriptIfConfigured = async function _Upload_runBuildScriptIfConfigured(streamOutput) {
    const buildCommand = this.project.appConfig?.scripts?.build;
    if (!buildCommand)
        return;
    const truncatedCommand = buildCommand.length > 60 ? buildCommand.substr(0, 60) + 'â€¦' : buildCommand;
    ux.action.start(`Running build command: "${truncatedCommand}"`);
    try {
        const stdout = streamOutput ? ['pipe', 'inherit'] : 'pipe';
        const stderr = streamOutput ? ['pipe', 'inherit'] : 'pipe';
        await execaCommand(buildCommand, {
            cwd: this.project.root,
            preferLocal: true,
            shell: true,
            stdout,
            stderr,
        });
    }
    catch (err) {
        ux.action.stop('Error');
        this.error(`scripts.build failed: ${StringUtil.caughtToString(err, 'message')}`);
    }
    ux.action.stop();
}, _Upload_checkDependencies = 
/**
 * If we're not just doing it, check and make sure there's a chance our build will succeed.
 */
async function _Upload_checkDependencies(justDoIt) {
    if (justDoIt) {
        return;
    }
    if (!fs.existsSync(path.join(this.project.root, '.pnp.cjs')) &&
        !(await __classPrivateFieldGet(this, _Upload_instances, "m", _Upload_canImport).call(this, 'devvit')) &&
        !(await __classPrivateFieldGet(this, _Upload_instances, "m", _Upload_canImport).call(this, '@devvit/client')) &&
        !(await __classPrivateFieldGet(this, _Upload_instances, "m", _Upload_canImport).call(this, '@devvit/server')) &&
        !(await __classPrivateFieldGet(this, _Upload_instances, "m", _Upload_canImport).call(this, '@devvit/public-api'))) {
        this.error(`It looks like you don't have dependencies installed. Please run 'npm install' (or yarn, if you're using yarn) and try again.`);
    }
}, _Upload_canImport = function _Upload_canImport(module) {
    // Run a node command in the project directory to check if we can import public-api
    return new Promise((resolve, reject) => {
        const checkImportCommand = `node --input-type=module -e "await import('${module}')"`;
        // Run this as a child process
        // eslint-disable-next-line security/detect-child-process
        const process = exec(checkImportCommand, { cwd: this.project.root }, (error) => {
            // If there was an error creating the child process, reject the promise
            if (error) {
                reject(error);
            }
        });
        process.on('exit', (code) => {
            resolve(code === 0);
        });
    });
}, _Upload_getNextVersionNumber = async function _Upload_getNextVersionNumber(appInfo, bump) {
    const appVersion = findLatestVersion(appInfo.versions) ?? new DevvitVersion(0, 0, 0);
    if (bump) {
        appVersion.bumpVersion(bump);
    }
    else {
        appVersion.bumpVersion(VersionBumpType.Patch);
        this.log('Automatically bumped app version to:', appVersion.toString());
    }
    return appVersion;
}, _Upload_bundleActors = async function _Upload_bundleActors(username, version) {
    const bundler = new Bundler();
    const actorSpec = {
        name: ACTOR_SRC_PRIMARY_NAME,
        owner: username,
        version: version,
    };
    try {
        return await bundler.bundle(this.project, actorSpec);
    }
    catch (err) {
        this.error(StringUtil.caughtToString(err, 'message'));
    }
}, _Upload_sendEventIfNotSent = async function _Upload_sendEventIfNotSent() {
    if (!__classPrivateFieldGet(this, _Upload_eventSent, "f")) {
        __classPrivateFieldSet(this, _Upload_eventSent, true, "f");
        await sendEvent(__classPrivateFieldGet(this, _Upload_event, "f"));
    }
}, _Upload_installOnDefaultPlaytestSubreddit = 
// Install the app to the default playtest subreddit, if it was created.
// For convenience, returns the name of the subreddit if the app is successfully installed.
async function _Upload_installOnDefaultPlaytestSubreddit(token, appVersion, verbose) {
    const appInfo = await getAppBySlug(__classPrivateFieldGet(this, _Upload_appClient, "f"), {
        slug: this.project.name,
        hidePrereleaseVersions: true,
        limit: 1, // fetched version limit; we only need the latest one
    });
    if (!appInfo?.app) {
        this.error(`Something went wrong: couldn't find the app ${this.project.name} after creating a playtest subreddit.`);
    }
    else if (!appInfo.app.defaultPlaytestSubredditId) {
        this.warn(`We couldn't find the default playtest subreddit for ${this.project.name}, but one will be created during your next ${'`devvit upload`'} or ${'`devvit playtest`'}.`);
        return undefined;
    }
    try {
        ux.action.start('Installing app to default playtest subreddit');
        const userT2Id = await this.getUserT2Id(token);
        const installationInfo = await installOnSubreddit(this, createAppVersionClient(), __classPrivateFieldGet(this, _Upload_installationsClient, "f"), userT2Id, appVersion, appInfo.app.defaultPlaytestSubredditId, verbose);
        ux.action.stop();
        return installationInfo;
    }
    catch (err) {
        ux.action.stop('Warning');
        this.warn(`We couldn't install your app to the new playtest subreddit at ${appInfo.app.defaultPlaytestSubredditId}, but you can still do so manually. ${StringUtil.caughtToString(err, 'message')}`);
    }
    return undefined;
}, _Upload_initApp = async function _Upload_initApp() {
    const code = await getCodeFromWizard(undefined, undefined, this);
    const initAppParams = unpackCode(code);
    if (!initAppParams?.appName) {
        this.error(`Your code was missing an app name. Please run 'npx devvit init' to get a new code.`);
    }
    // Update app name and ignore provided template, if any
    this.project.name = initAppParams.appName;
    this.log(`We've updated the app name to "${this.project.name}" in your ${this.project.filename}.`);
    await gitInitIfNeeded(this.project.root);
    await updatePackageJSON(this.project.root, this.project.name);
    await installAppDependencies(this.project.root, this);
    return initAppParams.appName;
};
Upload.description = `Upload the app to the App Directory. Uploaded apps are only visible to you (the app owner) and can only be installed to a small test subreddit with less than ${MAX_ALLOWED_SUBSCRIBER_COUNT} subscribers`;
Upload.flags = {
    bump: Flags.custom({
        description: 'Type of version bump (major|minor|patch|prerelease)',
        required: false,
        options: [
            VersionBumpType.Major,
            VersionBumpType.Minor,
            VersionBumpType.Patch,
            VersionBumpType.Prerelease,
        ],
    })(),
    version: Flags.custom({
        description: 'Explicit version number (e.g: 1.0.1)',
        required: false,
        multiple: false,
        parse: async (version) => DevvitVersion.fromString(version),
        exclusive: ['bump'],
    })(),
    'employee-update': Flags.boolean({
        aliases: ['employeeUpdate'],
        description: "I'm an employee and I want to update someone else's app. (This will only work if you're an employee.)",
        required: false,
        hidden: true,
    }),
    'just-do-it': Flags.boolean({
        aliases: ['justDoIt'],
        description: "Don't ask any questions, just use defaults & continue. (Useful for testing.)",
        required: false,
        hidden: true,
    }),
    'copy-paste': Flags.boolean({
        aliases: ['copyPaste'],
        description: 'Copy-paste the auth code instead of opening a browser',
        default: false,
    }),
    verbose: Flags.boolean({
        char: 'v',
        description: 'Enable verbose logging',
        default: false,
    }),
    // TODO: Remove completely next release cycle; see DR-231
    'disable-direct-upload': Flags.boolean({
        description: 'Disable direct web view asset uploading',
        default: false,
    }),
};
export default Upload;
function findLatestVersion(versions) {
    return versions
        .map((v) => new DevvitVersion(v.majorVersion, v.minorVersion, v.patchVersion, v.prereleaseVersion))
        .sort((lhs, rhs) => lhs.compare(rhs))
        .at(-1);
}

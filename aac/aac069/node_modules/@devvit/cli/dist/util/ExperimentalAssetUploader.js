var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ExperimentalAssetUploader_instances, _ExperimentalAssetUploader_cmd, _ExperimentalAssetUploader_verbose, _ExperimentalAssetUploader_appClient, _ExperimentalAssetUploader_appSlug, _ExperimentalAssetUploader_skipWebViewScriptInjection, _ExperimentalAssetUploader_processRegularAssets, _ExperimentalAssetUploader_processWebViewAssets, _ExperimentalAssetUploader_uploadNewMediaAssets, _ExperimentalAssetUploader_uploadNewWebViewAssets, _ExperimentalAssetUploader_mapAssets;
import fsp from 'node:fs/promises';
import path from 'node:path';
import { requireFromDir } from '@devvit/build-pack/esbuild/BuildInfoUtil.js';
import { ALLOWED_ASSET_EXTENSIONS, MAX_ASSET_FOLDER_SIZE_BYTES, MAX_ASSET_GIF_SIZE, MAX_ASSET_NON_GIF_SIZE, prettyPrintSize, } from '@devvit/shared-types/Assets.js';
import { ASSET_HASHING_ALGO, ASSET_UPLOAD_BATCH_SIZE, ICON_FILE_PATH, } from '@devvit/shared-types/constants.js';
import { mapAsyncWithMaxConcurrency } from '@devvit/shared-types/mapAsyncWithMaxConcurrency.js';
import { clientVersionQueryParam } from '@devvit/shared-types/web-view-scripts-constants.js';
import { ux } from '@oclif/core';
import { createHash } from 'crypto';
import { fileTypeFromBuffer } from 'file-type';
import { imageSize } from 'image-size';
import { JSDOM } from 'jsdom';
import { lookup } from 'mime-types';
import { default as tinyglob } from 'tiny-glob';
import { createAppClient } from './clientGenerators.js';
import { dirExists } from './files.js';
import { retryAsync } from './retryAsync.js';
export const DEVVIT_JS_URL = 'https://webview.devvit.net/scripts/devvit.v1.min.js';
const DEFAULT_PARALLEL_UPLOADS = 7;
let PARALLEL_UPLOADS = parseInt(process.env['DEVVIT_PARALLEL_UPLOADS'] || '0');
if (isNaN(PARALLEL_UPLOADS) || PARALLEL_UPLOADS < 1) {
    PARALLEL_UPLOADS = DEFAULT_PARALLEL_UPLOADS;
}
export class ExperimentalAssetUploader {
    constructor(cmd, appSlug, { verbose }) {
        _ExperimentalAssetUploader_instances.add(this);
        _ExperimentalAssetUploader_cmd.set(this, void 0);
        _ExperimentalAssetUploader_verbose.set(this, void 0);
        _ExperimentalAssetUploader_appClient.set(this, createAppClient());
        _ExperimentalAssetUploader_appSlug.set(this, void 0);
        _ExperimentalAssetUploader_skipWebViewScriptInjection.set(this, !!process.env.DEVVIT_SKIP_WEB_VIEW_SCRIPT_INJECTION);
        __classPrivateFieldSet(this, _ExperimentalAssetUploader_cmd, cmd, "f");
        __classPrivateFieldSet(this, _ExperimentalAssetUploader_verbose, verbose, "f");
        __classPrivateFieldSet(this, _ExperimentalAssetUploader_appSlug, appSlug, "f");
        if (__classPrivateFieldGet(this, _ExperimentalAssetUploader_skipWebViewScriptInjection, "f")) {
            __classPrivateFieldGet(this, _ExperimentalAssetUploader_cmd, "f").log('Skipping web view script injection.');
        }
    }
    /**
     * Checks if there are any new assets to upload, and if there are, uploads them.
     * Returns a map of asset names to their asset IDs.
     * Can throw an exception if the app's assets exceed our limits.
     *
     * If present, WebView assets will also be synced but will not be included in
     * the asset map.
     */
    async syncAssets() {
        const clientVersion = readClientVersion(__classPrivateFieldGet(this, _ExperimentalAssetUploader_cmd, "f").project.root);
        const [regularAssets, webViewAssets] = await Promise.all([
            __classPrivateFieldGet(this, _ExperimentalAssetUploader_cmd, "f").project.mediaDir
                ? queryAssets(path.join(__classPrivateFieldGet(this, _ExperimentalAssetUploader_cmd, "f").project.root, __classPrivateFieldGet(this, _ExperimentalAssetUploader_cmd, "f").project.mediaDir), ALLOWED_ASSET_EXTENSIONS, 'Media', clientVersion, __classPrivateFieldGet(this, _ExperimentalAssetUploader_skipWebViewScriptInjection, "f"))
                : [],
            __classPrivateFieldGet(this, _ExperimentalAssetUploader_cmd, "f").project.clientDir
                ? queryAssets(path.join(__classPrivateFieldGet(this, _ExperimentalAssetUploader_cmd, "f").project.root, __classPrivateFieldGet(this, _ExperimentalAssetUploader_cmd, "f").project.clientDir), [], 'Client', clientVersion, __classPrivateFieldGet(this, _ExperimentalAssetUploader_skipWebViewScriptInjection, "f"))
                : [],
        ]);
        const iconAssetPath = __classPrivateFieldGet(this, _ExperimentalAssetUploader_cmd, "f").project.appConfig?.marketingAssets?.icon;
        let iconAssetDetails;
        if (iconAssetPath) {
            const iconAssetFullPath = path.join(__classPrivateFieldGet(this, _ExperimentalAssetUploader_cmd, "f").project.root, iconAssetPath);
            if (await dirExists(iconAssetFullPath)) {
                __classPrivateFieldGet(this, _ExperimentalAssetUploader_cmd, "f").error(`Icon asset path ${iconAssetPath} is a directory, not a file.`);
            }
            if (!(await fsp.stat(iconAssetFullPath)).isFile()) {
                __classPrivateFieldGet(this, _ExperimentalAssetUploader_cmd, "f").error(`Icon asset path ${iconAssetPath} does not point to a file.`);
            }
            const iconAssetContents = await fsp.readFile(iconAssetFullPath);
            const iconAssetSize = Buffer.byteLength(iconAssetContents);
            const iconAssetHash = createHash(ASSET_HASHING_ALGO)
                .update(new Uint8Array(iconAssetContents))
                .digest('hex');
            this.assertAssetCanBeAnIcon(iconAssetContents);
            iconAssetDetails = {
                filePath: ICON_FILE_PATH, // Use a placeholder path for the icon asset
                size: iconAssetSize,
                hash: iconAssetHash,
                contents: new Uint8Array(iconAssetContents),
                isWebviewAsset: false,
            };
            regularAssets.push(iconAssetDetails);
            webViewAssets.push(iconAssetDetails);
        }
        // Return early if no assets
        if (regularAssets.length + webViewAssets.length === 0) {
            return {
                assetMap: undefined,
                webViewAssetMap: undefined,
                iconAsset: undefined,
            };
        }
        // Do some rough client-side asset verification - it'll be more robust on
        // the server side of things, but let's help "honest" users out early
        const totalSize = regularAssets.reduce((sum, a) => sum + a.size, 0) +
            webViewAssets.reduce((sum, a) => sum + a.size, 0);
        if (totalSize > MAX_ASSET_FOLDER_SIZE_BYTES) {
            __classPrivateFieldGet(this, _ExperimentalAssetUploader_cmd, "f").error(`Your assets folder is too big - you've got ${prettyPrintSize(totalSize)} of assets, which is more than the ${prettyPrintSize(MAX_ASSET_FOLDER_SIZE_BYTES)} total allowed.`);
        }
        // We can parallelize this now, since regular vs webview assets go to different places
        const [assetMap, webViewAssetMap] = await Promise.all([
            // regular assets go to Media Service
            __classPrivateFieldGet(this, _ExperimentalAssetUploader_instances, "m", _ExperimentalAssetUploader_processRegularAssets).call(this, regularAssets),
            // webroot assets go to WebView storage
            __classPrivateFieldGet(this, _ExperimentalAssetUploader_instances, "m", _ExperimentalAssetUploader_processWebViewAssets).call(this, webViewAssets),
        ]);
        const retval = { assetMap, webViewAssetMap, iconAsset: undefined };
        if (iconAssetDetails) {
            retval.iconAsset = assetMap[ICON_FILE_PATH];
        }
        return retval;
    }
    async assertAssetCanBeAnIcon(data) {
        // Verify the icon. It *must*:
        // - NOT be a GIF
        // - be square in shape
        // - be at least 256x256 pixels
        // - be at most 1024x1024 pixels
        // If it doesn't meet these requirements, we throw an error.
        // Also, we should warn the user in any of these cases:
        // - if the icon isn't a PNG
        // - if the icon is smaller than 1024x1024 pixels
        const fileTypeResult = await fileTypeFromBuffer(new Uint8Array(data));
        if (!fileTypeResult) {
            __classPrivateFieldGet(this, _ExperimentalAssetUploader_cmd, "f").error(`Icon asset is not a valid image.`);
        }
        if (fileTypeResult.mime === 'image/gif') {
            __classPrivateFieldGet(this, _ExperimentalAssetUploader_cmd, "f").error(`Icon asset cannot be a GIF.`);
        }
        const sizeResult = imageSize(new Uint8Array(data));
        if (!sizeResult) {
            __classPrivateFieldGet(this, _ExperimentalAssetUploader_cmd, "f").error(`Icon asset is not a valid image.`);
        }
        if (sizeResult.width !== sizeResult.height) {
            __classPrivateFieldGet(this, _ExperimentalAssetUploader_cmd, "f").error(`Icon asset must be square, but it is ${sizeResult.width}x${sizeResult.height}.`);
        }
        if (sizeResult.width < 256) {
            __classPrivateFieldGet(this, _ExperimentalAssetUploader_cmd, "f").error(`Icon asset must be at least 256x256 pixels, but it is ${sizeResult.width}x${sizeResult.height}.`);
        }
        if (sizeResult.width > 1024) {
            __classPrivateFieldGet(this, _ExperimentalAssetUploader_cmd, "f").error(`Icon asset can be at most 1024x1024 pixels, but it is ${sizeResult.width}x${sizeResult.height}.`);
        }
        // It's acceptable, but check if there's any warnings we should give the user
        if (fileTypeResult.mime !== 'image/png') {
            __classPrivateFieldGet(this, _ExperimentalAssetUploader_cmd, "f").warn(`Icon asset is not a PNG, but it will still be uploaded.`);
        }
        if (sizeResult.width < 1024) {
            __classPrivateFieldGet(this, _ExperimentalAssetUploader_cmd, "f").warn(`Icon asset is smaller than 1024x1024 pixels. Consider using a larger icon for better quality.`);
        }
        if (![1024, 512, 256].includes(sizeResult.width)) {
            __classPrivateFieldGet(this, _ExperimentalAssetUploader_cmd, "f").warn(`Icon asset is ${sizeResult.width}x${sizeResult.height}. Consider using a standard size (preferably 1024x1024) for better compatibility.`);
        }
    }
}
_ExperimentalAssetUploader_cmd = new WeakMap(), _ExperimentalAssetUploader_verbose = new WeakMap(), _ExperimentalAssetUploader_appClient = new WeakMap(), _ExperimentalAssetUploader_appSlug = new WeakMap(), _ExperimentalAssetUploader_skipWebViewScriptInjection = new WeakMap(), _ExperimentalAssetUploader_instances = new WeakSet(), _ExperimentalAssetUploader_processRegularAssets = async function _ExperimentalAssetUploader_processRegularAssets(assets) {
    // early out to avoid logging if empty
    if (assets.length === 0) {
        return {};
    }
    // Verify asset file sizes are within limits
    for (const asset of assets) {
        if (asset.filePath.endsWith('.gif') && asset.size > MAX_ASSET_GIF_SIZE) {
            __classPrivateFieldGet(this, _ExperimentalAssetUploader_cmd, "f").error(`Asset ${asset.filePath} is too large - gifs can't be more than ${prettyPrintSize(MAX_ASSET_GIF_SIZE)}.`);
        }
        if (asset.size > MAX_ASSET_NON_GIF_SIZE) {
            __classPrivateFieldGet(this, _ExperimentalAssetUploader_cmd, "f").error(`Asset ${asset.filePath} is too large - images can't be more than ${prettyPrintSize(MAX_ASSET_NON_GIF_SIZE)}.`);
        }
    }
    if (__classPrivateFieldGet(this, _ExperimentalAssetUploader_verbose, "f")) {
        ux.action.start(`Checking for new assets to upload`);
    }
    const assetMap = await __classPrivateFieldGet(this, _ExperimentalAssetUploader_instances, "m", _ExperimentalAssetUploader_uploadNewMediaAssets).call(this, assets);
    if (__classPrivateFieldGet(this, _ExperimentalAssetUploader_verbose, "f")) {
        ux.action.stop(`Found ${assets.length} new asset${assets.length === 1 ? '' : 's'}.`);
    }
    return assetMap;
}, _ExperimentalAssetUploader_processWebViewAssets = async function _ExperimentalAssetUploader_processWebViewAssets(assets) {
    // early out to avoid logging if empty
    if (assets.length === 0) {
        return {};
    }
    if (__classPrivateFieldGet(this, _ExperimentalAssetUploader_verbose, "f")) {
        ux.action.start(`Checking for new WebView assets to upload`);
    }
    const assetMap = await __classPrivateFieldGet(this, _ExperimentalAssetUploader_instances, "m", _ExperimentalAssetUploader_uploadNewWebViewAssets).call(this, assets);
    if (__classPrivateFieldGet(this, _ExperimentalAssetUploader_verbose, "f")) {
        ux.action.stop(`Found ${assets.length} new WebView asset${assets.length === 1 ? '' : 's'}.`);
    }
    return assetMap;
}, _ExperimentalAssetUploader_uploadNewMediaAssets = async function _ExperimentalAssetUploader_uploadNewMediaAssets(assets) {
    const { statuses } = await __classPrivateFieldGet(this, _ExperimentalAssetUploader_appClient, "f").CheckIfMediaExists({
        id: undefined,
        slug: __classPrivateFieldGet(this, _ExperimentalAssetUploader_appSlug, "f"),
        signatures: assets.map((a) => ({
            size: a.size,
            hash: a.hash,
            filePath: a.filePath,
            isWebviewAsset: false,
        })),
    });
    const { newAssets, duplicateAssets, existingAssets } = await __classPrivateFieldGet(this, _ExperimentalAssetUploader_instances, "m", _ExperimentalAssetUploader_mapAssets).call(this, assets, statuses);
    if (__classPrivateFieldGet(this, _ExperimentalAssetUploader_verbose, "f")) {
        ux.action.start(`Checking for new assets`);
        ux.info(`Found ${assets.length} assets (${newAssets.length} unique new assets)`);
        ux.info('New assets:');
        newAssets.forEach((asset) => {
            ux.info(` · ${asset.filePath}`);
        });
        ux.info('Duplicates of another asset already listed as new:');
        duplicateAssets.forEach((asset) => {
            ux.info(` · ${asset.filePath}`);
        });
        ux.info('Existing assets:');
        Object.entries(existingAssets).forEach(([path, id]) => {
            ux.info(` · ${path} (id: ${id})`);
        });
    }
    const assetMap = existingAssets;
    if (newAssets.length === 0) {
        if (__classPrivateFieldGet(this, _ExperimentalAssetUploader_verbose, "f")) {
            ux.action.stop(`None found!`);
        }
        return assetMap;
    }
    if (__classPrivateFieldGet(this, _ExperimentalAssetUploader_verbose, "f")) {
        ux.action.stop();
    }
    // Upload everything, giving back pairs of the assets & their upload response
    if (__classPrivateFieldGet(this, _ExperimentalAssetUploader_verbose, "f")) {
        ux.action.start(`Uploading new assets, ${newAssets.length} remaining`);
    }
    let uploadResults = [];
    try {
        // Do this in batches - we don't want to upload everything at once and
        // overwhelm the server
        while (newAssets.length > 0) {
            const batch = newAssets.splice(0, ASSET_UPLOAD_BATCH_SIZE);
            uploadResults = [
                ...uploadResults,
                ...(await Promise.all(batch.map(async (f) => {
                    return [
                        f,
                        await __classPrivateFieldGet(this, _ExperimentalAssetUploader_appClient, "f").UploadNewMedia({
                            slug: __classPrivateFieldGet(this, _ExperimentalAssetUploader_appSlug, "f"),
                            size: f.size,
                            hash: f.hash,
                            contents: f.contents,
                            webviewAsset: false,
                            filePath: f.filePath,
                        }),
                    ];
                }))),
            ];
            if (__classPrivateFieldGet(this, _ExperimentalAssetUploader_verbose, "f")) {
                ux.action.start(`Uploading new assets, ${newAssets.length} remaining`);
            }
        }
    }
    catch (err) {
        const error = err;
        const msg = `Failed to upload assets. (${error.message})`;
        if (__classPrivateFieldGet(this, _ExperimentalAssetUploader_verbose, "f")) {
            ux.action.stop(msg);
        }
        __classPrivateFieldGet(this, _ExperimentalAssetUploader_cmd, "f").log(msg);
        ux.error(msg, { exit: 1 });
    }
    if (__classPrivateFieldGet(this, _ExperimentalAssetUploader_verbose, "f")) {
        ux.action.stop(`New assets uploaded.`);
    }
    return assets.reduce((map, asset) => {
        const assetId = statuses.find((status) => status.filePath === asset.filePath)?.existingMediaId ??
            uploadResults.find(([result]) => result.hash === asset.hash && result.size === asset.size)?.[1].assetId;
        if (assetId) {
            map[asset.filePath] = assetId;
        }
        return map;
    }, assetMap);
}, _ExperimentalAssetUploader_uploadNewWebViewAssets = async function _ExperimentalAssetUploader_uploadNewWebViewAssets(assets) {
    const { statuses } = await __classPrivateFieldGet(this, _ExperimentalAssetUploader_appClient, "f").CheckIfMediaExists({
        id: undefined,
        slug: __classPrivateFieldGet(this, _ExperimentalAssetUploader_appSlug, "f"),
        signatures: await Promise.all(assets.map(retryAsync(async (a) => {
            const fileType = await fileTypeFromBuffer(a.contents);
            return {
                size: a.size,
                hash: a.hash,
                filePath: a.filePath,
                isWebviewAsset: true,
                mimeType: fileType?.mime ?? (lookup(a.filePath) || 'application/octet-stream'),
            };
        }))),
    });
    const { newAssets, duplicateAssets, existingAssets } = await __classPrivateFieldGet(this, _ExperimentalAssetUploader_instances, "m", _ExperimentalAssetUploader_mapAssets).call(this, assets, statuses, true);
    if (__classPrivateFieldGet(this, _ExperimentalAssetUploader_verbose, "f")) {
        ux.action.start(`Checking for new WebView assets`);
        ux.info(`Found ${assets.length} WebView assets (${newAssets.length} unique new assets)`);
        ux.info('New assets:');
        newAssets.forEach((asset) => {
            ux.info(` · ${asset.filePath}`);
        });
        ux.info('Duplicates of another asset already listed as new:');
        duplicateAssets.forEach((asset) => {
            ux.info(` · ${asset.filePath}`);
        });
        ux.info('Existing assets:');
        Object.entries(existingAssets).forEach(([path, id]) => {
            ux.info(` · ${path} (id: ${id})`);
        });
    }
    const assetMap = existingAssets;
    if (newAssets.length === 0) {
        if (__classPrivateFieldGet(this, _ExperimentalAssetUploader_verbose, "f")) {
            ux.action.stop(`None found!`);
        }
        return assetMap;
    }
    if (__classPrivateFieldGet(this, _ExperimentalAssetUploader_verbose, "f")) {
        ux.action.stop();
    }
    // Upload everything, giving back pairs of the assets & their upload response
    let assetsRemaining = newAssets.length;
    let sizeRemaining = newAssets.reduce((sum, a) => sum + a.size, 0);
    const updateUploadMsg = (sizeUploaded) => {
        sizeRemaining -= sizeUploaded;
        assetsRemaining -= 1;
        ux.action.start(`Uploading new WebView assets, ${assetsRemaining} remaining (${prettyPrintSize(sizeRemaining)})`);
    };
    ux.action.start(`Uploading new WebView assets, ${assetsRemaining} remaining (${prettyPrintSize(sizeRemaining)})`);
    await mapAsyncWithMaxConcurrency(newAssets, async (newAsset) => {
        try {
            const resp = await fetch(newAsset.uploadUrl, {
                method: 'PUT',
                body: newAsset.contents,
                headers: newAsset.uploadHeaders,
            });
            if (!resp.ok) {
                const body = await resp.text();
                const msg = `Failed to upload WebView asset ${newAsset.filePath} - HTTP ${resp.status}:\n${body}`;
                ux.action.stop(msg);
                __classPrivateFieldGet(this, _ExperimentalAssetUploader_cmd, "f").error(msg);
            }
        }
        catch (e) {
            const error = e;
            let errorMessage = error?.message;
            if (errorMessage === 'fetch failed') {
                // This is the most common, and least helpful error message. And it usually has a useful
                // cause, so go get that instead.
                errorMessage = error.cause?.message || error.message;
            }
            const msg = `Failed to upload WebView asset ${newAsset.filePath}: ${errorMessage}`;
            __classPrivateFieldGet(this, _ExperimentalAssetUploader_cmd, "f").error(msg);
        }
        const uploadUrl = new URL(newAsset.uploadUrl);
        assetMap[newAsset.filePath] = uploadUrl.origin + uploadUrl.pathname;
        updateUploadMsg(newAsset.size);
    }, PARALLEL_UPLOADS);
    ux.action.stop(`${newAssets.length} new WebView assets uploaded.`);
    ux.action.start(`Finishing upload`);
    return assetMap;
}, _ExperimentalAssetUploader_mapAssets = async function _ExperimentalAssetUploader_mapAssets(assets, statuses, areWebviewAssets = false) {
    const assetsByFilePath = Object.fromEntries(assets.map((a) => [a.filePath, a]));
    const newAssets = [];
    const duplicateAssets = [];
    const existingAssets = {};
    statuses.forEach((status) => {
        const asset = assetsByFilePath[status.filePath];
        if (!asset) {
            throw new Error(`Backend returned new asset with path ${status.filePath} that we don't know about..?`);
        }
        if (status.isNew) {
            // The user may have the same asset in multiple places, but we need to
            // only upload it once
            if (newAssets.find((a) => a.hash === asset.hash && a.size === asset.size)) {
                duplicateAssets.push(asset);
            }
            else {
                if (!areWebviewAssets) {
                    newAssets.push(asset);
                    return;
                }
                if (!status.uploadUrl) {
                    throw new Error(`Backend didn't return an upload URL for new webview asset ${status.filePath} - this shouldn't happen, contact us!`);
                }
                newAssets.push({
                    ...asset,
                    uploadUrl: status.uploadUrl,
                    uploadHeaders: status.uploadHeaders,
                });
            }
        }
        else {
            if (status.existingMediaId) {
                existingAssets[asset.filePath] = status.existingMediaId;
            }
            else {
                throw new Error(`Backend doesn't have an ID for ${status.filePath} but says it isn't new..? This shouldn't happen, contact the Devvit team!`);
            }
        }
    });
    return { newAssets, duplicateAssets, existingAssets };
};
/**
 * Read assets from disk and transform them.
 *
 * Asset kind controls transform. Client (historically webroot/) is for web view
 * assets. Media (historically assets/) is for everything else.
 *
 * @internal
 */
export async function queryAssets(dir, allowedExtensions, assetKind, clientVersionNum, skipWebViewScriptInjection) {
    if (!(await dirExists(dir))) {
        // Return early if there isn't an assets directory
        return [];
    }
    const assetsGlob = path
        .join(dir, '**', '*')
        // Note: tiny-glob *always* uses `/` as its path separator, even on Windows, so we need to
        // replace whatever the system path separator is with `/`
        .replaceAll(path.sep, '/');
    const assets = (await tinyglob(assetsGlob, { filesOnly: true, absolute: true })).filter((asset) => allowedExtensions.length === 0 || allowedExtensions.includes(path.extname(asset)));
    return await Promise.all(assets.map(async (asset) => {
        const filename = path.relative(dir, asset).replaceAll(path.sep, '/');
        let file = await fsp.readFile(asset);
        // If the webview assets is an HTML file, inject the Devvit analytics
        // script.
        if (assetKind === 'Client' && filename.match(/\.html?$/) && !skipWebViewScriptInjection) {
            file = transformHTMLBuffer(file, clientVersionNum);
        }
        const size = Buffer.byteLength(file);
        const contents = new Uint8Array(file);
        const hash = createHash(ASSET_HASHING_ALGO).update(new Uint8Array(file)).digest('hex');
        return {
            filePath: filename,
            size,
            hash,
            isWebviewAsset: assetKind === 'Client',
            contents,
        };
    }));
}
function readClientVersion(root) {
    try {
        const pkg = requireFromDir(root, '@devvit/client/package.json');
        return pkg.version;
    }
    catch {
        return;
    }
}
function transformHTMLBuffer(buf, clientVersionNum) {
    const inStr = new TextDecoder('utf-8').decode(buf);
    const out = transformHTML(inStr, clientVersionNum);
    return Buffer.from(out);
}
export function transformHTML(str, clientVersionNum) {
    const { document } = new JSDOM(str).window;
    // if no html tag, return early
    const htmlTag = document.querySelector('html');
    if (htmlTag == null) {
        return str;
    }
    const clientVersionQueryArg = clientVersionNum
        ? `${clientVersionQueryParam}=${clientVersionNum}`
        : '';
    const scriptTag = `<script src="${DEVVIT_JS_URL}?${clientVersionQueryArg}"></script>`;
    // if no head tag, create one after the html tag
    const headTag = document.querySelector('head');
    if (headTag == null) {
        htmlTag.insertAdjacentHTML('afterbegin', `<head>${scriptTag}</head>`); // eslint-disable-line no-unsanitized/method
    }
    else {
        headTag.insertAdjacentHTML('afterbegin', scriptTag); // eslint-disable-line no-unsanitized/method
    }
    return document.documentElement.outerHTML;
}

var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _NotificationsClient_instances, _NotificationsClient_metadata_get, _NotificationsClient_plugin_get;
import { NotificationsDefinition, } from '@devvit/protos/types/devvit/plugin/notifications/notifications_svc.js';
import { context } from '@devvit/server';
import { getDevvitConfig } from '@devvit/shared-types/server/get-devvit-config.js';
import { isT1, isT2, isT3, T2 } from '@devvit/shared-types/tid.js';
export class NotificationsClient {
    constructor() {
        _NotificationsClient_instances.add(this);
    }
    /**
     * Queue push notifications to a single or multiple users.
     * @param options The push notifications to queue
     * @returns Response with success/failure counts and errors
     */
    async enqueue(options) {
        const request = {
            title: options.title,
            body: options.body,
            recipients: options.recipients.map((recipient) => ({
                userId: recipient.userId,
                data: recipient.data,
                comment: isT1(recipient.link) ? recipient.link : undefined,
                post: isT3(recipient.link) ? recipient.link : undefined,
            })),
        };
        const response = await __classPrivateFieldGet(this, _NotificationsClient_instances, "a", _NotificationsClient_plugin_get).Enqueue(request, __classPrivateFieldGet(this, _NotificationsClient_instances, "a", _NotificationsClient_metadata_get));
        return {
            successCount: response.successCount ?? 0,
            failureCount: response.failureCount ?? 0,
            errors: response.errors?.map((error) => ({
                userId: isT2(error.userId) ? T2(error.userId) : undefined,
                message: error.message ?? '',
            })) ?? [],
        };
    }
    /**
     * Opt the current user in to receiving push notifications.
     * @returns A promise that resolves when the operation is complete
     */
    async optInCurrentUser() {
        return await __classPrivateFieldGet(this, _NotificationsClient_instances, "a", _NotificationsClient_plugin_get).OptInCurrentUser({}, __classPrivateFieldGet(this, _NotificationsClient_instances, "a", _NotificationsClient_metadata_get));
    }
    /**
     * Opt the current user out of receiving push notifications.
     * @returns A promise that resolves when the operation is complete
     */
    async optOutCurrentUser() {
        return await __classPrivateFieldGet(this, _NotificationsClient_instances, "a", _NotificationsClient_plugin_get).OptOutCurrentUser({}, __classPrivateFieldGet(this, _NotificationsClient_instances, "a", _NotificationsClient_metadata_get));
    }
    /**
     * List users who have opted in to receive push notifications.
     * @param options Options for listing opted-in users
     * @returns Response with a list of opted-in users
     */
    async listOptedInUsers(options) {
        return await __classPrivateFieldGet(this, _NotificationsClient_instances, "a", _NotificationsClient_plugin_get).ListOptedInUsers(options, __classPrivateFieldGet(this, _NotificationsClient_instances, "a", _NotificationsClient_metadata_get));
    }
    /**
     * Checks if a specific user has opted in to receive notifications.
     * @param request Request containing user id
     * @returns Response indicating opt-in status
     */
    async isOptedIn(userId) {
        return (await __classPrivateFieldGet(this, _NotificationsClient_instances, "a", _NotificationsClient_plugin_get).IsOptedIn({ userId }, __classPrivateFieldGet(this, _NotificationsClient_instances, "a", _NotificationsClient_metadata_get))).optedIn;
    }
    /**
     * Iterate over all user IDs who have opted in to receive notifications.
     *
     * Usage:
     *   // Iterate from the beginning
     *   for await (const userId of notifications.listOptedInUsersIterator()) {
     *     // userId is a t2_... string
     *   }
     *
     *   // Resume from a known cursor
     *   for await (const userId of notifications.listOptedInUsersIterator({ after: 'cursor' })) {
     *     // ...
     *   }
     *
     * Details:
     * - Internally pages with a default limit of 250 per request.
     * - Continues fetching while there are results and a `next` cursor.
     * - Stops automatically when there are no more results.
     */
    async *listOptedInUsersIterator(options) {
        const pageSize = 250;
        let after = options?.after;
        while (true) {
            const response = await __classPrivateFieldGet(this, _NotificationsClient_instances, "a", _NotificationsClient_plugin_get).ListOptedInUsers({ limit: pageSize, after }, __classPrivateFieldGet(this, _NotificationsClient_instances, "a", _NotificationsClient_metadata_get));
            const ids = response.userIds ?? [];
            if (ids.length === 0)
                break;
            for (const id of ids)
                yield id;
            if (!response.next)
                break;
            after = response.next;
        }
    }
    /**
     * Request to show a badge in the games drawer for a given app, linking to a given post
     * @param options Request containing post id and expiration, as duration or expiration time. If no expiration time is set, default to 24 hours from now.
     * @returns Response indicating success or failure
     */
    async requestShowGamesDrawerBadge(options) {
        return await __classPrivateFieldGet(this, _NotificationsClient_instances, "a", _NotificationsClient_plugin_get).ShowGamesDrawerBadge(options, __classPrivateFieldGet(this, _NotificationsClient_instances, "a", _NotificationsClient_metadata_get));
    }
    /**
     * Dismiss all active games drawer badges
     * @returns Response indicating success or failure
     */
    async dismissGamesDrawerBadge() {
        return await __classPrivateFieldGet(this, _NotificationsClient_instances, "a", _NotificationsClient_plugin_get).DismissGamesDrawerBadge({}, __classPrivateFieldGet(this, _NotificationsClient_instances, "a", _NotificationsClient_metadata_get));
    }
    /**
     * Get the status of active games drawer badges for an app
     * @returns Response indicating the present of an active badge and the expiration time if present
     */
    async getGamesDrawerBadgeStatus() {
        return await __classPrivateFieldGet(this, _NotificationsClient_instances, "a", _NotificationsClient_plugin_get).GetGamesDrawerBadgeStatus({}, __classPrivateFieldGet(this, _NotificationsClient_instances, "a", _NotificationsClient_metadata_get));
    }
}
_NotificationsClient_instances = new WeakSet(), _NotificationsClient_metadata_get = function _NotificationsClient_metadata_get() {
    return context.metadata;
}, _NotificationsClient_plugin_get = function _NotificationsClient_plugin_get() {
    return getDevvitConfig().use(NotificationsDefinition);
};

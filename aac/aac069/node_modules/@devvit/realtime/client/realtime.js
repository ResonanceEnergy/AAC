import { EffectType } from '@devvit/protos/json/devvit/ui/effects/v1alpha/effect.js';
import { RealtimeSubscriptionStatus } from '@devvit/protos/json/devvit/ui/effects/v1alpha/realtime_subscriptions.js';
import { emitEffect } from '@devvit/shared-types/client/emit-effect.js';
const connectionsByChannel = new Map();
/**
 * Connects to a realtime channel for receiving messages.
 *
 * @param opts - Connection options including channel name and callbacks
 * @returns A Connection object with a disconnect method
 *
 * @example
 *
 * ```ts
 * import {connectRealtime, context} from '@devvit/web/client'
 * import type {T2} from '@devvit/web/shared'
 *
 * type RealtimeMessage = {x: number, y: number, t2: T2}
 *
 * connectRealtime<RealtimeMessage>({
 *   channel: context.postId,
 *   onConnect() {
 *     console.log(`${context.userId} connected`)
 *   },
 *   onDisconnect() {
 *     console.log(`${context.userId} disconnected`)
 *   },
 *   onMessage(msg) {
 *     // Filter out current user across all sessions.
 *     if (msg.t2 === context.userId) return
 *
 *     console.log(`user ${msg.t2} at (${msg.x}, ${msg.y})`)
 *   }
 * })
 * ```
 */
export const connectRealtime = (opts) => {
    if (!opts.channel || /[^a-zA-Z0-9_]/.test(opts.channel))
        throw Error(`invalid channel name "${opts.channel}"; channels may only contain letters, numbers, and underscores`);
    if (connectionsByChannel.has(opts.channel)) {
        return connectionsByChannel.get(opts.channel);
    }
    const connection = new Connection(opts);
    connectionsByChannel.set(opts.channel, connection);
    addEventListener('message', connection.onMessage);
    emitConnectionsEffect();
    return connection;
};
export function disconnectRealtime(channel) {
    const connection = connectionsByChannel.get(channel);
    if (!connection)
        return;
    connectionsByChannel.delete(channel);
    removeEventListener('message', connection.onMessage);
    if (connection.connected)
        connection.opts.onDisconnect?.(channel);
    connection.connected = false;
    emitConnectionsEffect();
}
/** True if the channel socket is connected. */
export function isRealtimeConnected(channel) {
    return !!connectionsByChannel.get(channel)?.connected;
}
/**
 * Clears all connections. Used for testing purposes.
 * @internal
 */
export const __clearConnections = () => {
    connectionsByChannel.clear();
};
/** Emits open connections which may cause subscribe / unsubscribe. */
function emitConnectionsEffect() {
    emitEffect({
        realtime: { subscriptionIds: [...connectionsByChannel.keys()] },
        type: EffectType.EFFECT_REALTIME_SUB,
    });
}
export class Connection {
    constructor(opts) {
        /** @internal */
        this.connected = false;
        /** @internal */
        this.onMessage = (ev) => {
            const { type, data } = ev.data;
            if (type !== 'devvit-message') {
                return;
            }
            if (!data?.realtimeEvent) {
                return;
            }
            const { status, event } = data.realtimeEvent;
            if (!event?.channel.endsWith(this.opts.channel)) {
                return;
            }
            // Normalize the channel name (remove namespacing)
            event.channel = this.opts.channel;
            if (status === RealtimeSubscriptionStatus.REALTIME_SUBSCRIBED) {
                this.connected = true;
                this.opts.onConnect?.(this.opts.channel);
            }
            else if (status === RealtimeSubscriptionStatus.REALTIME_UNSUBSCRIBED) {
                this.connected = false;
                this.opts.onDisconnect?.(this.opts.channel);
            }
            else if (event.data) {
                this.opts.onMessage(event.data.msg);
            }
            else {
                console.error('[realtime] Received event without data:', {
                    channel: this.opts.channel,
                    event,
                });
            }
        };
        this.opts = opts;
    }
    /**
     * Disconnects from the realtime channel.
     *
     * @deprecated Use `disconnectRealtime()`.
     */
    async disconnect() {
        await disconnectRealtime(this.opts.channel);
    }
}

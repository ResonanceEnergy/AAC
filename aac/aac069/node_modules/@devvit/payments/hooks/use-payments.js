var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _UsePaymentsHook_context, _UsePaymentsHook_callback, _UsePaymentsHook_debug, _UsePaymentsHook_debugLog;
import { EffectType } from '@devvit/protos/types/devvit/ui/effects/v1alpha/effect.js';
import { registerHook } from '@devvit/public-api/devvit/internals/blocks/handler/BlocksHandler.js';
import { Header } from '@devvit/shared-types/Header.js';
import { orderStatusProtoToHook } from './hook-types.js';
class UsePaymentsHook {
    constructor(callback, params) {
        _UsePaymentsHook_context.set(this, void 0);
        _UsePaymentsHook_callback.set(this, void 0);
        _UsePaymentsHook_debug.set(this, void 0);
        this.state = {};
        _UsePaymentsHook_debugLog.set(this, (msg) => {
            if (__classPrivateFieldGet(this, _UsePaymentsHook_debug, "f")) {
                console.debug(`[payments] ${msg}`);
            }
        });
        __classPrivateFieldSet(this, _UsePaymentsHook_debug, !!params.context._devvitContext?.debug.payments, "f");
        __classPrivateFieldSet(this, _UsePaymentsHook_context, params.context, "f");
        __classPrivateFieldSet(this, _UsePaymentsHook_callback, callback, "f");
        this.hookId = params.hookId;
        __classPrivateFieldGet(this, _UsePaymentsHook_debugLog, "f").call(this, `usePurchase hook created (${this.hookId})`);
    }
    async onUIEvent(event) {
        if (event.orderResult && event.hook === this.hookId) {
            __classPrivateFieldGet(this, _UsePaymentsHook_debugLog, "f").call(this, `Received an order result: hookId: ${this.hookId}; Status: ${event.orderResult.status}; Order ID: ${event.orderResult.orderId}; Error Code: ${event.orderResult.errorCode}; Error Message: ${event.orderResult.errorMessage}`);
            const { status, errorCode, errorMessage, order, orderId } = event.orderResult;
            if (!order) {
                throw new Error('Invalid response: missing original order');
            }
            await __classPrivateFieldGet(this, _UsePaymentsHook_callback, "f").call(this, {
                status: orderStatusProtoToHook(status),
                errorCode,
                errorMessage,
                orderId,
                sku: order.skus[0],
                metadata: order.metadata,
            });
        }
    }
    purchase(sku, metadata = {}) {
        if (!sku.trim()) {
            throw new Error('Invalid purchase; no SKU provided');
        }
        __classPrivateFieldGet(this, _UsePaymentsHook_debugLog, "f").call(this, `Requesting a purchase for product: ${sku}`);
        // inject post id into metadata to be read by the order handler
        const devvitMetadata = {
            [Header.Post]: __classPrivateFieldGet(this, _UsePaymentsHook_context, "f")._devvitContext?.postId ?? '',
        };
        __classPrivateFieldGet(this, _UsePaymentsHook_context, "f").emitEffect('createOrder', {
            type: EffectType.EFFECT_CREATE_ORDER,
            createOrder: {
                id: this.hookId,
                skus: [sku],
                metadata: {
                    ...metadata,
                    ...devvitMetadata,
                },
            },
        });
    }
}
_UsePaymentsHook_context = new WeakMap(), _UsePaymentsHook_callback = new WeakMap(), _UsePaymentsHook_debug = new WeakMap(), _UsePaymentsHook_debugLog = new WeakMap();
/**
 * Creates a reusable hook to trigger purchases in an app and handle
 * the results in a single callback
 *
 * @param callback A function to call when a purchase flow is completed
 */
export function usePayments(callback) {
    return registerHook({
        namespace: 'payments',
        initializer: (params) => new UsePaymentsHook(callback, params),
    });
}

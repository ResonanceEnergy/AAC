import { PaymentProcessorDefinition } from '@devvit/protos/payments.js';
import { Devvit } from '@devvit/public-api';
import { makeAPIClients } from '@devvit/public-api/apis/makeAPIClients.js';
import { getContextFromMetadata } from '@devvit/public-api/devvit/internals/context.js';
import { Header } from '@devvit/shared-types/Header.js';
import { orderFromProto } from '@devvit/shared-types/payments/Order.js';
// The typed for this are copied over into `packages/build-pack/src/esbuild/templatizer/blocks.template.tsx`
// to avoid exposing the unnecessary internal-only function to Webbit users. If you change this here,
// change it there too.
export function addPaymentHandler(paymentHandler) {
    Devvit.provide(PaymentProcessorDefinition);
    Object.assign(Devvit.prototype, makeWrappedHandler(paymentHandler));
}
export function makeWrappedHandler(userDefinedHandler) {
    return {
        async FulfillOrder(req, md) {
            if (req.order == null || req.order.products.length === 0) {
                return {};
            }
            const context = Object.assign(makeAPIClients({ metadata: md }), getContextFromMetadata(md, req.order.metadata[Header.Post]));
            const order = mapOrder(req.order);
            const response = await userDefinedHandler.fulfillOrder(order, context);
            if (!response || response.success) {
                return { acknowledged: true };
            }
            else {
                return { rejectionReason: response.reason };
            }
        },
        async RefundOrder(req, md) {
            if (req.order == null || !userDefinedHandler.refundOrder) {
                return {};
            }
            const context = Object.assign(makeAPIClients({ metadata: md }), getContextFromMetadata(md));
            const order = mapOrder(req.order);
            await userDefinedHandler.refundOrder(order, context);
            return {};
        },
    };
}
// A utility mapper function that maps between the Order protobuf message and the Order type
// it also does some basic order validation (e.g. ensuring there is exactly one product)
function mapOrder(order) {
    const outOrder = orderFromProto(order);
    if (outOrder.products.length > 1) {
        throw new Error('Multi-product orders not supported');
    }
    if (outOrder.products.length === 0) {
        throw new Error('No products in order');
    }
    return outOrder;
}

import '@devvit/shared-types/polyfill/fetch.polyfill.js';
import { randomUUID } from 'node:crypto';
import { MediaMock } from '@devvit/media/test';
import { NotificationsMock } from '@devvit/notifications/test';
// eslint-disable-next-line no-restricted-imports
import { RealtimeDefinition } from '@devvit/protos/types/devvit/events/v1alpha/realtime.js';
// eslint-disable-next-line no-restricted-imports
import { HTTPDefinition } from '@devvit/protos/types/devvit/plugin/http/http.js';
// eslint-disable-next-line no-restricted-imports
import { MediaServiceDefinition } from '@devvit/protos/types/devvit/plugin/media/media.js';
// eslint-disable-next-line no-restricted-imports
import { NotificationsDefinition } from '@devvit/protos/types/devvit/plugin/notifications/notifications_svc.js';
// eslint-disable-next-line no-restricted-imports
import { RedisAPIDefinition } from '@devvit/protos/types/devvit/plugin/redis/redisapi.js';
// eslint-disable-next-line no-restricted-imports
import { SchedulerDefinition } from '@devvit/protos/types/devvit/plugin/scheduler/scheduler.js';
// eslint-disable-next-line no-restricted-imports
import { SettingsDefinition } from '@devvit/protos/types/devvit/plugin/settings/v1alpha/settings.js';
import { RealtimeMock } from '@devvit/realtime/server/test';
import { RedditPluginMock } from '@devvit/reddit/test';
import { RedisMock } from '@devvit/redis/test';
import { SchedulerMock } from '@devvit/scheduler/test';
import { Context, runWithContext } from '@devvit/server';
import { SettingsMock } from '@devvit/settings/test';
import { Header } from '@devvit/shared-types/Header.js';
import { getDefaultAppConfig, makeConfig, MOCK_HEADERS as headersMock, } from '@devvit/shared-types/test/index.js';
import { Redis } from 'ioredis';
import { RedisMemoryServer } from 'redis-memory-server';
import { test as baseTest, vi } from 'vitest';
import { HTTPMock } from '../mocks/http/httpMock.js';
import { installDevvitInterceptors, runWithTestContext } from './context.js';
installDevvitInterceptors();
const redisServer = new RedisMemoryServer();
const host = await redisServer.getHost();
const port = await redisServer.getPort();
const sharedRedisConn = new Redis({ host, port });
function createWrappedTestApi(target, setup) {
    return new Proxy(target, {
        // Handles: test(...), test.only(...), test.skip(...),
        // test.each(table)(...), test.concurrent(...), etc.
        apply(fn, thisArg, argArray) {
            const args = [...argArray];
            // Find the last function argument (the test body / hook body)
            let lastFnIndex = -1;
            for (let i = args.length - 1; i >= 0; i--) {
                if (typeof args[i] === 'function') {
                    lastFnIndex = i;
                    break;
                }
            }
            if (lastFnIndex !== -1) {
                const userFn = args[lastFnIndex];
                // Wrap the user's test function
                args[lastFnIndex] = async (...fnArgs) => {
                    const { reqCtx, fixtures, testContext } = setup();
                    try {
                        // Heuristic to detect Vitest TestContext
                        // Standard test() calls receive a single TestContext object.
                        // test.each() calls receive the parameters as arguments.
                        const isTestContext = fnArgs.length === 1 &&
                            fnArgs[0] &&
                            (typeof fnArgs[0] === 'object' || typeof fnArgs[0] === 'function') &&
                            'task' in fnArgs[0] &&
                            // Vitest context usually has these lifecycle methods
                            'onTestFailed' in fnArgs[0];
                        if (isTestContext) {
                            const mergedCtx = { ...fixtures, ...fnArgs[0] };
                            return await runWithContext(reqCtx, () => runWithTestContext(testContext, () => userFn(mergedCtx)));
                        }
                        return await runWithContext(reqCtx, () => runWithTestContext(testContext, () => userFn(...fnArgs)));
                    }
                    finally {
                        vi.restoreAllMocks();
                        await fixtures.mocks.redis.clear();
                    }
                };
            }
            const result = Reflect.apply(fn, thisArg, args);
            // IMPORTANT for `.each` (and any curried API):
            // if the result is a function, wrap it too so subsequent call(s)
            // also get fixtures + ALS.
            if (typeof result === 'function') {
                return createWrappedTestApi(result, setup);
            }
            return result;
        },
        // Handles property access: test.only, test.skip, test.each, test.concurrent, ...
        get(fn, prop, receiver) {
            const value = Reflect.get(fn, prop, receiver);
            if (typeof value === 'function') {
                return createWrappedTestApi(value, setup);
            }
            return value;
        },
    });
}
const setup = (config) => {
    const username = config.username ?? 'testuser';
    const userId = config.userId ?? 't2_testuser';
    const subredditName = config.subredditName ?? 'testsub';
    const subredditId = config.subredditId ?? 't5_testsub';
    const settings = config.settings ?? {};
    const appConfig = config.appConfig;
    const headers = {
        ...headersMock,
        [Header.User]: userId,
        [Header.Username]: username,
        [Header.AppUser]: userId,
        [Header.Subreddit]: subredditId,
        [Header.SubredditName]: subredditName,
    };
    const mediaMock = new MediaMock();
    const redisMock = new RedisMock(sharedRedisConn, randomUUID());
    const httpMock = new HTTPMock();
    const redditMock = new RedditPluginMock();
    const realtimeMock = new RealtimeMock();
    const settingsMock = new SettingsMock(settings);
    const schedulerMock = new SchedulerMock();
    const notificationsMock = new NotificationsMock();
    // Seed default context data so helpers like getCurrentUser/subreddit work.
    redditMock.users.addUser({ id: userId, name: username });
    redditMock.subreddits.addSubreddit({
        id: subredditId,
        displayName: subredditName,
        title: subredditName,
    });
    const cfg = makeConfig({
        plugins: {
            [MediaServiceDefinition.fullName]: mediaMock.plugin,
            [RedisAPIDefinition.fullName]: redisMock.plugin,
            [HTTPDefinition.fullName]: httpMock.plugin,
            [RealtimeDefinition.fullName]: realtimeMock.plugin,
            [SettingsDefinition.fullName]: settingsMock.plugin,
            [SchedulerDefinition.fullName]: schedulerMock.plugin,
            [NotificationsDefinition.fullName]: notificationsMock.plugin,
            ...redditMock.getPluginRegistrations(),
        },
    });
    const contextAppConfig = appConfig ?? getDefaultAppConfig();
    const reqCtx = Context(headers);
    const fixtures = {
        config: cfg,
        headers,
        settings,
        username,
        userId,
        subredditName,
        subredditId,
        mocks: {
            media: mediaMock,
            redis: redisMock,
            http: httpMock,
            reddit: redditMock,
            realtime: realtimeMock,
            settings: settingsMock,
            scheduler: schedulerMock,
            notifications: notificationsMock,
        },
    };
    return { reqCtx, fixtures, testContext: { config: cfg, appConfig: contextAppConfig } };
};
/**
 * Creates a test runner with customized Devvit environment.
 *
 * @example
 * const test = createDevvitTest({
 *   username: 'moderator_bob',
 *   settings: { enable_ban_hammer: true }
 * });
 *
 * test('mod action works', async ({ config, headers }) => {
 *   // ...
 * });
 */
export const createDevvitTest = (config = {}) => {
    return createWrappedTestApi(baseTest, () => setup(config));
};
